================================================================================
PROJETO: COMPRAS-ESTOQUE-SISTEMA
DATA GERACAO: compras-estoque-sistema
================================================================================

ESTRUTURA DE DIRET√ìRIOS:
----------------------------------------
‚îú‚îÄ‚îÄ .pytest_cache
‚îÇ   ‚îú‚îÄ‚îÄ v
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ lastfailed
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ nodeids
‚îÇ   ‚îú‚îÄ‚îÄ .gitignore
‚îÇ   ‚îú‚îÄ‚îÄ CACHEDIR.TAG
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ backups
‚îÇ   ‚îî‚îÄ‚îÄ antes_melhorias
‚îÇ       ‚îú‚îÄ‚îÄ estoque_math.py
‚îÇ       ‚îú‚îÄ‚îÄ excel_exporter.py
‚îÇ       ‚îî‚îÄ‚îÄ gerar_relatorio_final.py
‚îú‚îÄ‚îÄ config
‚îÇ   ‚îî‚îÄ‚îÄ parametros.yaml
‚îú‚îÄ‚îÄ docs
‚îú‚îÄ‚îÄ scripts
‚îÇ   ‚îú‚îÄ‚îÄ auditor_item.py
‚îÇ   ‚îú‚îÄ‚îÄ calcular_sazonalidade.py
‚îÇ   ‚îú‚îÄ‚îÄ debug_item.py
‚îÇ   ‚îú‚îÄ‚îÄ export_project_context.py
‚îÇ   ‚îú‚îÄ‚îÄ fix_toml.py
‚îÇ   ‚îú‚îÄ‚îÄ gerar_relatorio_final.py
‚îÇ   ‚îú‚îÄ‚îÄ inspect_db.py
‚îÇ   ‚îú‚îÄ‚îÄ setup_database.py
‚îÇ   ‚îú‚îÄ‚îÄ test_abc.py
‚îÇ   ‚îú‚îÄ‚îÄ test_calculo_estoque.py
‚îÇ   ‚îú‚îÄ‚îÄ test_xyz.py
‚îÇ   ‚îú‚îÄ‚îÄ testar_analytics.py
‚îÇ   ‚îú‚îÄ‚îÄ teste_giro.py
‚îÇ   ‚îú‚îÄ‚îÄ teste_matematica.py
‚îÇ   ‚îú‚îÄ‚îÄ teste_score.py
‚îÇ   ‚îî‚îÄ‚îÄ verificar_ambiente.py
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îî‚îÄ‚îÄ compras_sistema
‚îÇ       ‚îú‚îÄ‚îÄ cache
‚îÇ       ‚îú‚îÄ‚îÄ core
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ system_guard.py
‚îÇ       ‚îú‚îÄ‚îÄ data_engine
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ queries
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ abc_financeiro.sql
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ estatisticas_vendas.sql
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ analytics_service.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ analytics_service.py.backup2
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ duckdb_manager.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ history_recorder.py
‚îÇ       ‚îú‚îÄ‚îÄ export
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ templates
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ excel_exporter.py
‚îÇ       ‚îú‚îÄ‚îÄ pipeline
‚îÇ       ‚îú‚îÄ‚îÄ rule_engine
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ analysis
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ classification
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ abc_classifier.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trend_classifier.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ xyz_classifier.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ purchase
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ risk
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ scoring
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ stock
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ estoque_math.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ validators
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ input_schema.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ base_rule.py
‚îÇ       ‚îú‚îÄ‚îÄ ui
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ screens
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ themes
‚îÇ       ‚îú‚îÄ‚îÄ utils
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ logging
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ performance
‚îÇ       ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îú‚îÄ‚îÄ fixtures
‚îÇ   ‚îú‚îÄ‚îÄ integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_classifiers.py
‚îÇ   ‚îú‚îÄ‚îÄ unit
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_estoque_math.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_validator.py
‚îÇ   ‚îî‚îÄ‚îÄ conftest.py
‚îú‚îÄ‚îÄ excel_exporter.py.backup
‚îú‚îÄ‚îÄ export_full_project.py
‚îú‚îÄ‚îÄ gerar_relatorio_final.py.backup
‚îú‚îÄ‚îÄ launcher_gui.py
‚îú‚îÄ‚îÄ launcher_gui_gemini.py
‚îú‚îÄ‚îÄ launcher_guiantesdaatualizacaodashboard16122025.py
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ rodar.sh
‚îú‚îÄ‚îÄ rodar.sh.save
‚îî‚îÄ‚îÄ verificar_ambiente.py

================================================================================

START FILE: launcher_guiantesdaatualizacaodashboard16122025.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURA√á√ÉO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # Configura√ß√£o da Janela
        self.title("NewCompras v6.5 - Central de Intelig√™ncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINI√á√ÉO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARI√ÅVEIS DE CONTROLE ---
        # Par√¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em mem√≥ria

        # KPIs - Sugest√£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRU√á√ÉO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | Conte√∫do Din√¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZA√á√ÉO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para n√£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURA√á√ïES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / T√≠tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de Reposi√ß√£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PAR√ÇMETROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time Padr√£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINI√á√ÉO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # Espa√ßador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # Bot√µes de Manuten√ß√£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="üîÑ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="üíæ Salvar Configura√ß√£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. √ÅREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("üìä PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("üìù LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """Constr√≥i a interface visual de decis√£o"""
        
        # --- BLOCO 1: SELE√á√ÉO DE MARCA (Cacheado e R√°pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="üîç Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de Bot√µes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: A√á√ïES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="üîç PROCESSAR SIMULA√á√ÉO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="üì• GERAR RELAT√ìRIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # Come√ßa desativado por seguran√ßa
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRAT√âGICO DA AN√ÅLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PE√áAS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. L√ìGICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser r√°pido. Se falhar, l√™ do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("üìÇ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"‚úÖ {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"‚ö†Ô∏è Cache corrompido, recriando... ({e})")
        
        # Se n√£o tem cache ou deu erro, for√ßa leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """L√™ do DuckDB (Lento) e salva no JSON"""
        self.log_msg("‚è≥ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("‚ùå Banco de dados n√£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas √∫nicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"‚úÖ Indexa√ß√£o conclu√≠da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"‚ùå Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de bot√µes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # L√≥gica visual de sele√ß√£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem est√° selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECU√á√ÉO DO MOTOR DE C√ÅLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for c√°lculo real (gerar Excel), foca na aba de Log para o usu√°rio ver o progresso
        if not simulacao:
            self.tabs.set("üìù LOG DO SISTEMA")
        
        # Trava bot√µes
        self.btn_simular.configure(state="disabled", text="‚è≥ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
            try:
                marca = self.var_marca.get()
                
                # --- CORRE√á√ÉO DE AMBIENTE VIRTUAL ---
                # Define qual Python usar. Tenta achar o do .venv automaticamente.
                python_exec = sys.executable # Padr√£o (caso j√° esteja ativado)
                
                # Caminhos comuns de ambiente virtual no Linux
                possivel_venv = self.root_dir / ".venv" / "bin" / "python"
                possivel_venv_simples = self.root_dir / "venv" / "bin" / "python"
                
                # Se acharmos o Python do ambiente virtual, usamos ele for√ßadamente
                if possivel_venv.exists():
                    python_exec = str(possivel_venv)
                elif possivel_venv_simples.exists():
                    python_exec = str(possivel_venv_simples)
                # ------------------------------------

                cmd = [python_exec, str(self.script_path), "--marca", marca]
                if simulacao:
                    cmd.append("--simulacao")

                self.log_msg(f"üöÄ Iniciando motor de c√°lculo para: {marca}")
                self.log_msg(f"üêç Usando Python em: {python_exec}") # Debug para garantir
                
                # Executa o script Python como subprocesso
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    encoding='utf-8', 
                    errors='replace'
                )

                # L√™ a sa√≠da em tempo real
                for line in process.stdout:
                    line_clean = line.strip()
                    
                    # Intercepta o JSON de estat√≠sticas para atualizar o Dashboard
                    if "STATS_DATA=" in line_clean:
                        try:
                            json_str = line_clean.replace("STATS_DATA=", "")
                            data = json.loads(json_str)
                            self.after(0, lambda d=data: self.atualizar_kpis(d))
                        except Exception as e:
                            self.log_msg(f"‚ö†Ô∏è Erro ao ler KPIs: {e}")
                    elif "--- LOG START ---" not in line_clean:
                        self.after(0, self.log_msg, line_clean)

                process.wait()
                
                # Verifica erros
                stderr = process.stderr.read()
                if stderr:
                    self.after(0, self.log_msg, f"üî¥ ERRO INTERNO:\n{stderr}")

                self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

            except Exception as e:
                self.after(0, self.log_msg, f"‚ùå ERRO CR√çTICO: {e}")
                self.after(0, lambda: self.finalizar_processo(simulacao, 1))
            
    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura bot√µes
        self.btn_simular.configure(state="normal", text="üîç PROCESSAR SIMULA√á√ÉO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exporta√ß√£o
                self.log_msg("‚úÖ Simula√ß√£o conclu√≠da com sucesso.")
                # Volta para o dashboard para ver os n√∫meros
                self.tabs.set("üìä PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "C√°lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("‚úÖ Relat√≥rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("üìù LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURA√á√ÉO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("Configura√ß√£o", "Par√¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_guiantesdaatualizacaodashboard16122025.py


START FILE: launcher_gui.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURA√á√ÉO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # Configura√ß√£o da Janela
        self.title("NewCompras v6.5 - Central de Intelig√™ncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINI√á√ÉO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARI√ÅVEIS DE CONTROLE ---
        # Par√¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em mem√≥ria

        # KPIs - Sugest√£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRU√á√ÉO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | Conte√∫do Din√¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZA√á√ÉO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para n√£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURA√á√ïES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / T√≠tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de Reposi√ß√£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PAR√ÇMETROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time Padr√£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINI√á√ÉO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # Espa√ßador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # Bot√µes de Manuten√ß√£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="üîÑ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="üíæ Salvar Configura√ß√£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. √ÅREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("üìä PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("üìù LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """Constr√≥i a interface visual de decis√£o"""
        
        # --- BLOCO 1: SELE√á√ÉO DE MARCA (Cacheado e R√°pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="üîç Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de Bot√µes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: A√á√ïES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="üîç PROCESSAR SIMULA√á√ÉO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="üì• GERAR RELAT√ìRIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # Come√ßa desativado por seguran√ßa
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRAT√âGICO DA AN√ÅLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PE√áAS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. L√ìGICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser r√°pido. Se falhar, l√™ do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("üìÇ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"‚úÖ {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"‚ö†Ô∏è Cache corrompido, recriando... ({e})")
        
        # Se n√£o tem cache ou deu erro, for√ßa leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """L√™ do DuckDB (Lento) e salva no JSON"""
        self.log_msg("‚è≥ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("‚ùå Banco de dados n√£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas √∫nicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"‚úÖ Indexa√ß√£o conclu√≠da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"‚ùå Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de bot√µes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # L√≥gica visual de sele√ß√£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem est√° selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECU√á√ÉO DO MOTOR DE C√ÅLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for c√°lculo real (gerar Excel), foca na aba de Log para o usu√°rio ver o progresso
        if not simulacao:
            self.tabs.set("üìù LOG DO SISTEMA")
        
        # Trava bot√µes
        self.btn_simular.configure(state="disabled", text="‚è≥ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
            try:
                marca = self.var_marca.get()
                
                # --- CORRE√á√ÉO DE AMBIENTE VIRTUAL ---
                # Define qual Python usar. Tenta achar o do .venv automaticamente.
                python_exec = sys.executable # Padr√£o (caso j√° esteja ativado)
                
                # Caminhos comuns de ambiente virtual no Linux
                possivel_venv = self.root_dir / ".venv" / "bin" / "python"
                possivel_venv_simples = self.root_dir / "venv" / "bin" / "python"
                
                # Se acharmos o Python do ambiente virtual, usamos ele for√ßadamente
                if possivel_venv.exists():
                    python_exec = str(possivel_venv)
                elif possivel_venv_simples.exists():
                    python_exec = str(possivel_venv_simples)
                # ------------------------------------

                cmd = [python_exec, str(self.script_path), "--marca", marca]
                if simulacao:
                    cmd.append("--simulacao")

                self.log_msg(f"üöÄ Iniciando motor de c√°lculo para: {marca}")
                self.log_msg(f"üêç Usando Python em: {python_exec}") # Debug para garantir
                
                # Executa o script Python como subprocesso
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    encoding='utf-8', 
                    errors='replace'
                )

                # L√™ a sa√≠da em tempo real
                for line in process.stdout:
                    line_clean = line.strip()
                    
                    # Intercepta o JSON de estat√≠sticas para atualizar o Dashboard
                    if "STATS_DATA=" in line_clean:
                        try:
                            json_str = line_clean.replace("STATS_DATA=", "")
                            data = json.loads(json_str)
                            self.after(0, lambda d=data: self.atualizar_kpis(d))
                        except Exception as e:
                            self.log_msg(f"‚ö†Ô∏è Erro ao ler KPIs: {e}")
                    elif "--- LOG START ---" not in line_clean:
                        self.after(0, self.log_msg, line_clean)

                process.wait()
                
                # Verifica erros
                stderr = process.stderr.read()
                if stderr:
                    self.after(0, self.log_msg, f"üî¥ ERRO INTERNO:\n{stderr}")

                self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

            except Exception as e:
                self.after(0, self.log_msg, f"‚ùå ERRO CR√çTICO: {e}")
                self.after(0, lambda: self.finalizar_processo(simulacao, 1))
            
    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura bot√µes
        self.btn_simular.configure(state="normal", text="üîç PROCESSAR SIMULA√á√ÉO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exporta√ß√£o
                self.log_msg("‚úÖ Simula√ß√£o conclu√≠da com sucesso.")
                # Volta para o dashboard para ver os n√∫meros
                self.tabs.set("üìä PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "C√°lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("‚úÖ Relat√≥rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("üìù LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURA√á√ÉO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("Configura√ß√£o", "Par√¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_gui.py


START FILE: launcher_gui_gemini.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURA√á√ÉO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # Configura√ß√£o da Janela
        self.title("NewCompras v6.5 - Central de Intelig√™ncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINI√á√ÉO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARI√ÅVEIS DE CONTROLE ---
        # Par√¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em mem√≥ria

        # KPIs - Sugest√£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRU√á√ÉO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | Conte√∫do Din√¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZA√á√ÉO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para n√£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURA√á√ïES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / T√≠tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de Reposi√ß√£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PAR√ÇMETROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time Padr√£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINI√á√ÉO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # Espa√ßador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # Bot√µes de Manuten√ß√£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="üîÑ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="üíæ Salvar Configura√ß√£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. √ÅREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("üìä PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("üìù LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """Constr√≥i a interface visual de decis√£o"""
        
        # --- BLOCO 1: SELE√á√ÉO DE MARCA (Cacheado e R√°pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="üîç Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de Bot√µes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: A√á√ïES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="üîç PROCESSAR SIMULA√á√ÉO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="üì• GERAR RELAT√ìRIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # Come√ßa desativado por seguran√ßa
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRAT√âGICO DA AN√ÅLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PE√áAS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. L√ìGICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser r√°pido. Se falhar, l√™ do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("üìÇ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"‚úÖ {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"‚ö†Ô∏è Cache corrompido, recriando... ({e})")
        
        # Se n√£o tem cache ou deu erro, for√ßa leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """L√™ do DuckDB (Lento) e salva no JSON"""
        self.log_msg("‚è≥ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("‚ùå Banco de dados n√£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas √∫nicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"‚úÖ Indexa√ß√£o conclu√≠da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"‚ùå Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de bot√µes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # L√≥gica visual de sele√ß√£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem est√° selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECU√á√ÉO DO MOTOR DE C√ÅLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for c√°lculo real (gerar Excel), foca na aba de Log para o usu√°rio ver o progresso
        if not simulacao:
            self.tabs.set("üìù LOG DO SISTEMA")
        
        # Trava bot√µes
        self.btn_simular.configure(state="disabled", text="‚è≥ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
        try:
            marca = self.var_marca.get()
            cmd = [sys.executable, str(self.script_path), "--marca", marca]
            if simulacao:
                cmd.append("--simulacao")

            self.log_msg(f"üöÄ Iniciando motor de c√°lculo para: {marca}")
            
            # Executa o script Python como subprocesso
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
                encoding='utf-8', 
                errors='replace'
            )

            # L√™ a sa√≠da em tempo real
            for line in process.stdout:
                line_clean = line.strip()
                
                # Intercepta o JSON de estat√≠sticas para atualizar o Dashboard
                if "STATS_DATA=" in line_clean:
                    try:
                        json_str = line_clean.replace("STATS_DATA=", "")
                        data = json.loads(json_str)
                        # Atualiza GUI na thread principal
                        self.after(0, lambda d=data: self.atualizar_kpis(d))
                    except Exception as e:
                        self.log_msg(f"‚ö†Ô∏è Erro ao ler KPIs: {e}")
                elif "--- LOG START ---" not in line_clean:
                    # Todo o resto vai pro Log visual
                    self.after(0, self.log_msg, line_clean)

            process.wait()
            
            # Verifica erros
            stderr = process.stderr.read()
            if stderr:
                self.after(0, self.log_msg, f"üî¥ ERRO INTERNO:\n{stderr}")

            self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

        except Exception as e:
            self.after(0, self.log_msg, f"‚ùå ERRO CR√çTICO: {e}")
            self.after(0, lambda: self.finalizar_processo(simulacao, 1))

    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura bot√µes
        self.btn_simular.configure(state="normal", text="üîç PROCESSAR SIMULA√á√ÉO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exporta√ß√£o
                self.log_msg("‚úÖ Simula√ß√£o conclu√≠da com sucesso.")
                # Volta para o dashboard para ver os n√∫meros
                self.tabs.set("üìä PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "C√°lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("‚úÖ Relat√≥rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("üìù LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURA√á√ÉO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("Configura√ß√£o", "Par√¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_gui_gemini.py


START FILE: export_full_project.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

# --- CONFIGURA√á√ïES ---
PROJECT_ROOT = Path(__file__).parent
OUTPUT_FILE = "contexto_completo_do_sistema.txt"

# Pastas para ignorar (n√£o entra nem l√™ nada dentro)
IGNORE_DIRS = {
    ".git", 
    ".venv", 
    "venv", 
    "env", 
    "__pycache__", 
    ".idea", 
    ".vscode", 
    "data",       # Ignora bancos de dados bin√°rios
    "logs",       # Ignora logs de execu√ß√£o
    "exports",    # Ignora os Excels gerados
    "build",
    "dist"
}

# Extens√µes permitidas (s√≥ salva arquivos deste tipo)
INCLUDE_EXTS = {
    ".py", 
    ".yaml", 
    ".yml", 
    ".sql", 
    ".json", 
    ".md", 
    ".txt", 
    ".toml", 
    ".ini"
}

# Arquivos espec√≠ficos para ignorar (caso necess√°rio)
IGNORE_FILES = {
    OUTPUT_FILE, # N√£o ler o pr√≥prio arquivo de sa√≠da
    "package-lock.json",
    ".DS_Store"
}

def generate_tree(path, prefix=""):
    """Gera uma string visual da estrutura de pastas."""
    tree_str = ""
    try:
        # Pega itens e ordena (pastas primeiro, depois arquivos)
        items = list(path.iterdir())
        items.sort(key=lambda x: (not x.is_dir(), x.name.lower()))
        
        # Filtra itens ignorados
        items = [i for i in items if i.name not in IGNORE_DIRS and i.name not in IGNORE_FILES]
        
        count = len(items)
        for i, item in enumerate(items):
            is_last = (i == count - 1)
            connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
            
            tree_str += f"{prefix}{connector}{item.name}\n"
            
            if item.is_dir():
                extension = "    " if is_last else "‚îÇ   "
                tree_str += generate_tree(item, prefix + extension)
                
    except PermissionError:
        tree_str += f"{prefix}‚îî‚îÄ‚îÄ [Acesso Negado]\n"
        
    return tree_str

def main():
    print(f"üöÄ Iniciando exporta√ß√£o do projeto em: {PROJECT_ROOT}")
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # 1. Cabe√ßalho Principal
        out.write("="*80 + "\n")
        out.write(f"PROJETO: COMPRAS-ESTOQUE-SISTEMA\n")
        out.write(f"DATA GERACAO: {os.path.basename(str(PROJECT_ROOT))}\n")
        out.write("="*80 + "\n\n")

        # 2. Estrutura de Diret√≥rios (√Årvore)
        out.write("ESTRUTURA DE DIRET√ìRIOS:\n")
        out.write("-" * 40 + "\n")
        out.write(generate_tree(PROJECT_ROOT))
        out.write("\n" + "="*80 + "\n\n")
        
        # 3. Conte√∫do dos Arquivos
        file_count = 0
        
        for root, dirs, files in os.walk(PROJECT_ROOT):
            # Modifica dirs in-place para pular pastas ignoradas no walk
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            
            for file in files:
                if file in IGNORE_FILES:
                    continue
                
                file_path = Path(root) / file
                
                # Verifica extens√£o
                if file_path.suffix.lower() not in INCLUDE_EXTS:
                    continue

                # Caminho relativo para exibi√ß√£o
                rel_path = file_path.relative_to(PROJECT_ROOT)
                
                try:
                    content = file_path.read_text(encoding="utf-8", errors="ignore")
                    
                    # Escreve separador e conte√∫do
                    out.write(f"START FILE: {rel_path}\n")
                    out.write("-" * 80 + "\n")
                    out.write(content)
                    out.write("\n")
                    out.write("-" * 80 + "\n")
                    out.write(f"END FILE: {rel_path}\n")
                    out.write("\n\n")
                    
                    file_count += 1
                    print(f"‚úÖ Inclu√≠do: {rel_path}")
                    
                except Exception as e:
                    print(f"‚ùå Erro ao ler {rel_path}: {e}")

    print(f"\n‚ú® Conclu√≠do! {file_count} arquivos salvos em '{OUTPUT_FILE}'.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: export_full_project.py


START FILE: verificar_ambiente.py
--------------------------------------------------------------------------------
import sys
import os
import subprocess
from pathlib import Path

def diagnostico():
    print("--- üîç DIAGN√ìSTICO DE AMBIENTE ---")
    print(f"Caminho do Execut√°vel Python: {sys.executable}")
    print(f"Vers√£o do Python: {sys.version}")
    print(f"Pasta Atual (CWD): {os.getcwd()}")
    
    # 1. Tenta importar pandera
    print("\n--- üì¶ TESTE DE BIBLIOTECAS ---")
    try:
        import pandera
        print(f"‚úÖ Pandera: Instalado (Vers√£o: {pandera.__version__})")
        print(f"   Local: {pandera.__file__}")
    except ImportError:
        print("‚ùå Pandera: N√ÉO ENCONTRADO neste ambiente.")

    try:
        import matplotlib
        print(f"‚úÖ Matplotlib: Instalado")
    except ImportError:
        print("‚ùå Matplotlib: N√ÉO ENCONTRADO.")

    # 2. Verifica estrutura do venv
    print("\n--- üìÅ ESTRUTURA DE PASTAS ---")
    venv_path = Path("./venv/bin/python")
    print(f"O arquivo ./venv/bin/python existe? {'‚úÖ Sim' if venv_path.exists() else '‚ùå N√£o'}")

    # 3. Testa como o subprocesso seria chamado
    print("\n--- üöÄ TESTE DE CHAMADA (SUBPROCESSO) ---")
    try:
        # Tenta rodar o python do venv pedindo a vers√£o
        res = subprocess.run([str(venv_path), "--version"], capture_output=True, text=True)
        print(f"Chamada './venv/bin/python --version' retornou: {res.stdout.strip()}")
    except Exception as e:
        print(f"‚ùå Erro ao tentar chamar o python do venv: {e}")

if __name__ == "__main__":
    diagnostico()
--------------------------------------------------------------------------------
END FILE: verificar_ambiente.py


START FILE: pyproject.toml
--------------------------------------------------------------------------------
[project]
name = "compras-estoque-sistema"
version = "1.0.0"
description = "Sistema modular de compras e gest√£o de estoque"
requires-python = ">=3.11"
dependencies = [
    "duckdb>=1.1.0",
    "polars-lts-cpu>=1.12.0",
    "pyarrow>=14.0.0",
    "pydantic>=2.9.0",
    "pyyaml>=6.0.2",
    "pandera[polars]>=0.20.4",
    "structlog>=24.4.0",
    "openpyxl>=3.1.5",
    "reportlab>=4.2.5",
    "pyinstaller>=6.11.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.3",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "hypothesis>=6.115.6",
    "ruff>=0.7.4",
    "mypy>=1.13.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
dev-dependencies = ["ruff", "mypy", "pytest"]

[tool.hatch.build.targets.wheel]
packages = ["src/compras_sistema"]

--------------------------------------------------------------------------------
END FILE: pyproject.toml


START FILE: tests/conftest.py
--------------------------------------------------------------------------------
# tests/conftest.py
import pytest
import polars as pl
from datetime import datetime, timedelta
import sys
from pathlib import Path

# Adiciona o src ao path para importar os m√≥dulos do sistema
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

@pytest.fixture
def config_mock():
    """Simula o objeto de configura√ß√£o carregado do YAML."""
    class MockConfig:
        def __init__(self):
            # Simula a estrutura h√≠brida (Objeto/Dict) que o seu sistema usa
            self.compras = {'meses_cobertura': 1.5}
            self.produto = {'dias_lancamento': 60}
            self.lead_time = {'padrao_dias': 10}
            
            # Permite acesso via dicion√°rio tamb√©m (para compatibilidade com _ler_config)
            self._data = {
                'compras': self.compras,
                'produto': self.produto,
                'lead_time': self.lead_time
            }
        
        def __getitem__(self, item):
            return self._data[item]

    return MockConfig()

@pytest.fixture
def df_produto_base():
    """Retorna um DataFrame Polars b√°sico para testes de c√°lculo."""
    return pl.DataFrame({
        "cod_produto": ["PROD-001"],
        "data_cadastro": [datetime.now() - timedelta(days=365)], # Item velho
        "saldo_estoque": [100],
        "saldo_oc": [0],
        "media_venda_dia": [2.0],
        "std_venda_dia": [0.5],
        "lead_time_dias": [10],
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "lote_economico": [10],
        "custo_unitario": [50.0],
        "dias_sem_venda": [0],
        "ativo": ["SIM"]
    })
--------------------------------------------------------------------------------
END FILE: tests/conftest.py


START FILE: tests/integration/test_classifiers.py
--------------------------------------------------------------------------------
# tests/integration/test_classifiers.py
import pytest
import duckdb
import polars as pl
from datetime import datetime, timedelta
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier

@pytest.fixture
def db_manager_mock():
    """Cria um DuckDB em mem√≥ria com dados falsos de venda."""
    conn = duckdb.connect(":memory:")
    
    # Cria estrutura simulando o attach do SQLite
    conn.execute("CREATE SCHEMA sqlite_db")
    
    # Cria tabela de vendas fake
    conn.execute("""
        CREATE TABLE sqlite_db.vendas (
            cod_produto VARCHAR,
            data_movimento DATE,
            quantidade INTEGER,
            valor_total DECIMAL(10,2),
            cod_clifor INTEGER
        )
    """)
    
    # Classe Mock para substituir o DuckDBManager real
    class MockDB:
        def get_connection(self):
            # Retorna um context manager falso que devolve a conex√£o aberta
            class ConnContext:
                def __enter__(ctx): return conn
                def __exit__(ctx, exc_type, exc_val, exc_tb): pass
            return ConnContext()
            
    return MockDB()

def test_abc_classifier(db_manager_mock):
    """Testa se a classifica√ß√£o ABC (Pareto 80/15/5) funciona."""
    conn = db_manager_mock.get_connection().__enter__()
    
    # Insere dados:
    # Prod A: R$ 8000 (80%)
    # Prod B: R$ 1500 (15%)
    # Prod C: R$ 500  (5%)
    hoje = datetime.now().strftime("%Y-%m-%d")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-A', '{hoje}', 10, 8000, 1)")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-B', '{hoje}', 10, 1500, 1)")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-C', '{hoje}', 10, 500, 1)")
    
    classifier = ABCClassifier(db_manager_mock)
    
    # Como o ABCClassifier l√™ um arquivo SQL externo, precisamos garantir que
    # o arquivo exista. Se o teste falhar por FileNotFoundError, 
    # o caminho no ABCClassifier.__init__ precisa ser ajustado ou mockado.
    # Assumindo que o arquivo existe no disco:
    
    try:
        df = classifier.run()
        
        # Valida√ß√µes
        row_a = df.filter(pl.col("cod_produto") == "PROD-A").row(0, named=True)
        assert row_a["curva_abc"] == "A"
        
        row_b = df.filter(pl.col("cod_produto") == "PROD-B").row(0, named=True)
        assert row_b["curva_abc"] == "B"
        
    except FileNotFoundError:
        pytest.skip("Arquivo SQL abc_financeiro.sql n√£o encontrado no ambiente de teste")

def test_xyz_classifier_z_score(db_manager_mock, config_mock):
    """Testa a variabilidade (Coeficiente de Varia√ß√£o)."""
    conn = db_manager_mock.get_connection().__enter__()
    
    # Prod X: Venda muito est√°vel (10 todo dia)
    # Prod Z: Venda err√°tica (0, 100, 0, 0)
    
    base_date = datetime.now()
    for i in range(10):
        dt = (base_date - timedelta(days=i)).strftime("%Y-%m-%d")
        conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-X', '{dt}', 10, 100, 1)")
        
        qtd_z = 100 if i == 0 else 0
        conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-Z', '{dt}', {qtd_z}, 100, 1)")

    classifier = XYZClassifier(db_manager_mock, config_mock)
    df = classifier.run()
    
    xyz_x = df.filter(pl.col("cod_produto") == "PROD-X")["curva_xyz"].item()
    xyz_z = df.filter(pl.col("cod_produto") == "PROD-Z")["curva_xyz"].item()
    
    assert xyz_x == "X"  # CV baixo
    assert xyz_z == "Z"  # CV alto
--------------------------------------------------------------------------------
END FILE: tests/integration/test_classifiers.py


START FILE: tests/unit/test_estoque_math.py
--------------------------------------------------------------------------------
# tests/unit/test_estoque_math.py
import polars as pl
from datetime import datetime, timedelta
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

def test_calculo_estoque_seguranca(df_produto_base, config_mock):
    """Verifica se o c√°lculo do Z-Score para XYZ est√° correto."""
    df = EstoqueMath.calcular_seguranca(df_produto_base, config_mock)
    resultado = df["estoque_seguranca"].item()
    
    # 1.65 * 0.5 * sqrt(10) approx 2.61
    assert resultado > 2.0
    assert resultado < 3.0

def test_ponto_suprimento_e_meta(df_produto_base, config_mock):
    """Testa a l√≥gica principal de reposi√ß√£o."""
    
    # Precisamos calcular a seguran√ßa antes, pois calcular_necessidades depende dela
    df = EstoqueMath.calcular_seguranca(df_produto_base, config_mock)
    df = EstoqueMath.calcular_necessidades(df, config_mock)
    
    row = df.row(0, named=True)
    
    # Ponto Suprimento = (2 * 10) + ES(~2.6) ‚âà 22.6 -> Arredonda 23
    # Estoque Meta = (2 * 45) + ES(~2.6) ‚âà 92.6 -> Arredonda 93
    assert row["ponto_suprimento"] >= 22
    assert row["estoque_meta"] >= 92

def test_boost_anti_ruptura(df_produto_base, config_mock):
    """Valida a regra de aumentar a m√©dia se o item A/B estiver zerado."""
    # Cen√°rio: Estoque 0, Curva A, Item Antigo
    df_ruptura = df_produto_base.with_columns([
        pl.lit(0).alias("saldo_estoque"),
        pl.lit("A").alias("curva_abc"),
        pl.lit(31).alias("dias_sem_venda"), # > 30 dias parado
        pl.lit(0.0).alias("estoque_seguranca") # <--- CORRE√á√ÉO: Coluna necess√°ria para o c√°lculo
    ])
    
    df = EstoqueMath.calcular_necessidades(df_ruptura, config_mock)
    
    media_original = 2.0
    media_calculada = df["media_calculo"].item()
    
    # Regra: Se > 30 dias sem venda, boost de 20%
    assert media_calculada == media_original * 1.20

def test_item_novo_sem_movimento(df_produto_base, config_mock):
    """Valida a l√≥gica de diagn√≥stico para item rec√©m cadastrado."""
    # Item com 10 dias de vida (menor que config 60)
    df_novo = df_produto_base.with_columns([
        pl.lit(datetime.now() - timedelta(days=10)).alias("data_cadastro"),
        pl.lit(0).alias("media_venda_dia"),
        pl.lit(0).alias("saldo_estoque"),
        pl.lit(0).alias("saldo_oc"),
        pl.lit(100).alias("score") # <--- CORRE√á√ÉO: Coluna necess√°ria para recalculo de score
    ])
    
    # Gera sugest√£o for√ßada para testar bloqueio/libera√ß√£o
    df_novo = df_novo.with_columns(pl.lit(100).alias("sugestao_final"))
    
    df = EstoqueMath.gerar_diagnostico(df_novo, config_mock)
    diag = df["validacao_giro"].item()
    
    # Deve identificar como item novo
    assert "ITEM NOVO" in diag 
    # Item novo deve sugerir compra m√≠nima (1 lote)
    assert df["sugestao_final"].item() == df["lote_economico"].item()
    # Score deve ser boostado para 9999
    assert df["score"].item() == 9999

def test_lote_economico(df_produto_base, config_mock):
    """Testa arredondamento para lotes."""
    # Sugest√£o Bruta: 15
    # Lote: 10
    # Deve virar 20 (2 lotes)
    
    df = df_produto_base.with_columns([
        pl.lit(15).alias("sugestao_bruta"),
        pl.lit(10).alias("lote_economico")
    ])
    
    df = EstoqueMath.aplicar_lote_economico(df, config_mock)
    assert df["sugestao_final"].item() == 20
--------------------------------------------------------------------------------
END FILE: tests/unit/test_estoque_math.py


START FILE: tests/unit/test_validator.py
--------------------------------------------------------------------------------
import polars as pl
import pytest
from datetime import date
from compras_sistema.rule_engine.validators.input_schema import InputCalcSchema
from pandera.errors import SchemaError

def test_validador_sucesso():
    # Dados corretos
    df = pl.DataFrame({
        "cod_produto": ["A"],
        "saldo_estoque": [10],
        "saldo_oc": [0],
        "media_venda_dia": [1.5],
        "std_venda_dia": [0.1],
        "lead_time_dias": [10.0],
        "lote_economico": [12],
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "data_cadastro": [date(2023, 1, 1)]
    })
    # N√£o deve levantar erro
    InputCalcSchema.validate(df)

def test_validador_falha_lote_zero():
    # Lote = 0 (Erro)
    df = pl.DataFrame({
        "cod_produto": ["A"],
        "saldo_estoque": [10],
        "saldo_oc": [0],
        "media_venda_dia": [1.5],
        "std_venda_dia": [0.1],
        "lead_time_dias": [10.0],
        "lote_economico": [0], # <--- ERRO AQUI (gt=0)
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "data_cadastro": [date(2023, 1, 1)]
    })
    
    with pytest.raises(SchemaError):
        InputCalcSchema.validate(df)
--------------------------------------------------------------------------------
END FILE: tests/unit/test_validator.py


START FILE: src/compras_sistema/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/__init__.py


START FILE: src/compras_sistema/core/system_guard.py
--------------------------------------------------------------------------------
import psutil
import logging
import sys
from pathlib import Path
from datetime import datetime

class SystemGuard:
    def __init__(self, log_dir: Path):
        self.log_dir = log_dir
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.setup_logger()

    def setup_logger(self):
        filename = f"mrp_log_{datetime.now().strftime('%Y-%m-%d')}.txt"
        log_path = self.log_dir / filename
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s | %(levelname)s | %(message)s',
            handlers=[
                logging.FileHandler(log_path),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger("MRP_Guard")

    def log(self, message):
        self.logger.info(message)

    def check_memory(self, min_mb=500):
        """
        Verifica se h√° mem√≥ria RAM dispon√≠vel suficiente.
        Se houver menos que 'min_mb', avisa ou aborta.
        """
        mem = psutil.virtual_memory()
        available_mb = mem.available / (1024 * 1024)
        
        self.logger.info(f"RAM Dispon√≠vel: {available_mb:.0f} MB")

        if available_mb < min_mb:
            self.logger.warning(f"‚ö†Ô∏è PERIGO: Mem√≥ria cr√≠tica! Apenas {available_mb:.0f}MB livres.")
            self.logger.warning("‚ö†Ô∏è Feche o navegador (Chrome/Firefox) imediatamente.")
            # Opcional: input("Pressione Enter quando liberar mem√≥ria...") 
            # No seu caso, vamos apenas logar o perigo.

    def log_performance(self, task_name, start_time):
        elapsed = (datetime.now() - start_time).total_seconds()
        self.logger.info(f"‚è±Ô∏è Tarefa '{task_name}' conclu√≠da em {elapsed:.2f} segundos.")
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/system_guard.py


START FILE: src/compras_sistema/core/config.py
--------------------------------------------------------------------------------
from pathlib import Path
from typing import Any, Dict
import yaml
from pydantic import BaseModel, Field

class XYZConfig(BaseModel):
    threshold: float
    z_score: float

class LoteConfig(BaseModel):
    minima_absoluta: int
    limite_virada: float

# --- CLASSES NOVAS NECESS√ÅRIAS PARA O C√ÅLCULO FUNCIONAR ---
class LeadTimeConfig(BaseModel):
    padrao_dias: float
    desvio_padrao: float

class ComprasConfig(BaseModel):
    meses_cobertura: float
# ----------------------------------------------------------

class ParametrosConfig(BaseModel):
    # Aqui definimos que lead_time n√£o √© mais dict, e sim LeadTimeConfig
    lead_time: LeadTimeConfig 
    compras: ComprasConfig
    
    historico: Dict[str, int]
    produto: Dict[str, int]
    xyz: Dict[str, XYZConfig]
    abc: Dict[str, float]
    tolerancia_abc: Dict[str, float]
    lote: LoteConfig
    outlier: Dict[str, float]
    giro: Dict[str, int]
    risco: Dict[str, Any]
    sazonalidade: Dict[str, Any]
    ruptura: Dict[str, float]
    
    @classmethod
    def from_yaml(cls, path: Path) -> "ParametrosConfig":
        if not path.exists():
            raise FileNotFoundError(f"Arquivo de configura√ß√£o n√£o encontrado: {path}")
        with open(path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        return cls(**data)

class ConfigManager:
    """Singleton para gerenciamento de configura√ß√µes."""
    
    _instance = None
    _parametros: ParametrosConfig | None = None
    _pesos_score: dict | None = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def load_configs(self, config_dir: Path):
        """Carrega todos os arquivos de configura√ß√£o."""
        self._parametros = ParametrosConfig.from_yaml(
            config_dir / "parametros.yaml"
        )
        
        score_path = config_dir / "pesos_score.yaml"
        if score_path.exists():
            with open(score_path, 'r', encoding='utf-8') as f:
                self._pesos_score = yaml.safe_load(f)
        else:
            self._pesos_score = {}

    @property
    def parametros(self) -> ParametrosConfig:
        if self._parametros is None:
            raise RuntimeError("Configura√ß√µes n√£o carregadas. Chame load_configs() primeiro.")
        return self._parametros
    
    @property
    def pesos_score(self) -> dict:
        if self._pesos_score is None:
            raise RuntimeError("Pesos de score n√£o carregados.")
        return self._pesos_score
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/config.py


START FILE: src/compras_sistema/core/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/__init__.py


START FILE: src/compras_sistema/export/excel_exporter.py
--------------------------------------------------------------------------------
import polars as pl
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)


class ExcelExporter:
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def exportar_sugestao(self, df: pl.DataFrame, filename: str = None):
        if filename is None:
            data_hoje = datetime.now().strftime("%Y%m%d_%H%M")
            filename = f"sugestao_compras_{data_hoje}.xlsx"
        
        filepath = self.output_dir / filename
        logger.info("iniciando_export_excel", path=str(filepath))
        
        # ======== ORDEM DAS COLUNAS (REORGANIZADA) ========
        cols_export = [
            "status_diagnostico",
            "cod_produto",
            "descricao",
            "ref_fornecedor",
            "marca",
            "curva_abc",
            "curva_xyz",
            "sugestao_final",           # Sugest√£o Final (Resultado)
            
            # --- BLOCO DE AN√ÅLISE DO C√ÅLCULO ---
            "sugestao_calculada",       # 1. Matem√°tica Pura
            "alerta_dados",             # 2. Auditoria (Posi√ß√£o Solicitada)
            "calculado_mas_bloqueado",  # 3. Flag de Bloqueio
            "motivo_bloqueio",          # 4. Raz√£o
            # -----------------------------------
            
            "meta_pos_compra",
            "fator_sazonal",
            "lote_economico",
            "subtotal",
            "saldo_estoque",
            "saldo_oc",
            "cobertura_virtual_meses",
            "media_venda_base",
            "media_venda_dia",
            "tendencia_vendas",
            "tendencia_clientes",
            "perfil_cliente",
            "validacao_giro",
            "custo_unitario",
            "score"
        ]
        
        cols_presentes = [c for c in cols_export if c in df.columns]
        records = df.select(cols_presentes).to_dicts()
        
        # ======== CRIA√á√ÉO DO EXCEL ========
        wb = Workbook()
        ws = wb.active
        ws.title = "Analise Compras"
        
        # Estilos Gerais
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        center_align = Alignment(horizontal="center")
        left_align = Alignment(horizontal="left")
        thin_border = Border(
            left=Side(style="thin"), right=Side(style="thin"),
            top=Side(style="thin"), bottom=Side(style="thin")
        )
        
        # Cores
        fill_green = PatternFill(start_color="CCFFCC", fill_type="solid")
        fill_yellow = PatternFill(start_color="FFFFE0", fill_type="solid")
        fill_orange = PatternFill(start_color="FFD700", fill_type="solid")
        fill_blue_light = PatternFill(start_color="E6F3FF", fill_type="solid")
        fill_implanta = PatternFill(start_color="E0FFFF", fill_type="solid")
        fill_red = PatternFill(start_color="FFB6C1", fill_type="solid")
        fill_alert = PatternFill(start_color="FFFF00", fill_type="solid") # Amarelo forte
        
        # Mapeamento de nomes
        mapa_nomes = {
            "ALERTA_DADOS": "‚ö†Ô∏è ALERTA DADOS",
            "META_POS_COMPRA": "POSI√á√ÉO FINAL",
            "FATOR_SAZONAL": "IDX SAZONAL",
            "MEDIA_VENDA_DIA": "GIRO DIA (AJUST)",
            "MEDIA_VENDA_BASE": "GIRO DIA (BASE)",
            "COBERTURA_VIRTUAL_MESES": "COBERTURA MESES",
            "REF_FORNECEDOR": "REF. FABRICA",
            "SUGESTAO_CALCULADA": "CALC. ORIGINAL",
            "CALCULADO_MAS_BLOQUEADO": "BLOQUEADO?",
            "MOTIVO_BLOQUEIO": "MOTIVO BLOQUEIO"
        }
        
        headers = [c.replace("_", " ").upper() for c in cols_presentes]
        headers = [mapa_nomes.get(h, h) for h in headers]
        
        ws.append(headers)
        
        # Formata cabe√ßalho
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_align
        
        # Preenche dados
        for row_idx, row_data in enumerate(records, 2):
            for col_idx, col_name in enumerate(cols_presentes, 1):
                val = row_data[col_name]
                cell = ws.cell(row=row_idx, column=col_idx, value=val)
                cell.border = thin_border
                
                # Alinhamento
                if col_name == "descricao":
                    cell.alignment = left_align
                else:
                    cell.alignment = center_align
                
                # Formata√ß√£o num√©rica
                if col_name in ["custo_unitario", "subtotal"]:
                    cell.number_format = 'R$ #,##0.00'
                elif col_name in ["media_venda_dia", "media_venda_base", "fator_sazonal"]:
                    cell.number_format = '0.00'
                elif col_name in ["cobertura_virtual_meses"]:
                    cell.number_format = '0.0'
                elif col_name == "score":
                    cell.number_format = '#,##0'
                
                # ======== FORMATA√á√ÉO CONDICIONAL ========
                
                # 1. ALERTA DE DADOS
                if col_name == "alerta_dados" and val:
                    cell.font = Font(bold=True, color="FF0000")
                    cell.fill = fill_alert
                
                # 2. Sugest√µes de compra
                if col_name in ["sugestao_final", "subtotal"] and row_data.get("sugestao_final", 0) > 0:
                    cell.font = Font(bold=True, color="006400")
                    cell.fill = fill_green
                
                # 3. Produtos bloqueados
                if col_name == "calculado_mas_bloqueado" and val == "SIM":
                    cell.fill = fill_red
                    cell.font = Font(bold=True, color="8B0000")
                
                # 4. Motivo do bloqueio
                if col_name == "motivo_bloqueio" and val:
                    cell.font = Font(color="DC143C", italic=True)
                
                # 5. Fator sazonal
                if col_name == "fator_sazonal":
                    if isinstance(val, (int, float)):
                        if val < 0.90:
                            cell.font = Font(color="0000FF")
                            cell.fill = fill_blue_light
                        elif val > 1.10:
                            cell.font = Font(color="B22222", bold=True)
                
                # 6. Status diagn√≥stico
                if col_name == "status_diagnostico":
                    val_str = str(val).upper()
                    if "IMPLANTA√á√ÉO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "RUPTURA" in val_str:
                        cell.fill = PatternFill(start_color="FF0000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "BLOQUEADO" in val_str:
                        cell.fill = PatternFill(start_color="808080", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "INATIVO" in val_str:
                        cell.fill = PatternFill(start_color="000000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "ALERTA" in val_str:
                        cell.fill = PatternFill(start_color="FF8C00", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "EXCESSO" in val_str:
                        cell.fill = fill_yellow
                    elif "COMPRAR" in val_str:
                        cell.fill = fill_green
                
                # 7. Tend√™ncia
                if col_name == "tendencia_vendas":
                    val_str = str(val).upper()
                    if "ALTA" in val_str:
                        cell.font = Font(color="006400", bold=True)
                    elif "QUEDA" in val_str:
                        cell.font = Font(color="FF0000", bold=True)
                
                # 8. Valida√ß√£o Giro
                if col_name == "validacao_giro":
                    val_str = str(val)
                    if "ITEM NOVO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "SEM MOVIMENTO" in val_str:
                        cell.font = Font(color="808080", italic=True)
                    elif "Excesso" in val_str:
                        cell.font = Font(bold=True, color="B22222")
                        cell.fill = fill_orange
        
        # Ajuste de largura
        for col_idx, column_cells in enumerate(ws.columns, 1):
            max_length = 0
            column = get_column_letter(col_idx)
            limit = 60 if cols_presentes[col_idx-1] == "descricao" else 40
            
            for cell in column_cells:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            ws.column_dimensions[column].width = min(max_length + 3, limit)
        
        wb.save(filepath)
        logger.info("export_excel_concluido")
        return filepath
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/export/excel_exporter.py


START FILE: src/compras_sistema/data_engine/analytics_service.py
--------------------------------------------------------------------------------
import polars as pl
import duckdb
from datetime import datetime

class AnalyticsService:
    def __init__(self, db_manager):
        """
        Servi√ßo de Intelig√™ncia de Dados.
        Respons√°vel por transformar dados brutos do DuckDB em KPIs e Tend√™ncias.
        """
        self.db_manager = db_manager

    def _obter_conexao_segura(self):
        """Garante que a conex√£o seja extra√≠da corretamente do db_manager."""
        try:
            return self.db_manager.get_connection()
        except Exception as e:
            if "inicializado" in str(e).lower():
                raise RuntimeError("DuckDB n√£o inicializado. Chame initialize() no Launcher.")
            raise e

    def get_kpis_atuais(self, marca="TODAS"):
        """
        Calcula os KPIs financeiros e operacionais do √∫ltimo snapshot.
        Permite filtragem din√¢mica por marca.
        """
        try:
            # SQL din√¢mico para filtragem por marca
            condicao_marca = "" if marca == "TODAS" else f"AND marca = '{marca}'"
            
            query = f"""
                WITH ultimo_snapshot AS (
                    SELECT MAX(data_snapshot) as data_viga FROM historico_snapshots
                )
                SELECT 
                    CAST(MAX(data_snapshot) AS TIMESTAMP) as data_referencia,
                    SUM(saldo_estoque * custo_unitario) as valor_estoque,
                    SUM(sugestao_final * custo_unitario) as investimento_pendente,
                    AVG(cobertura_meses) as cobertura_media
                FROM historico_snapshots
                WHERE data_snapshot = (SELECT data_viga FROM ultimo_snapshot)
                {condicao_marca}
            """
            
            print(f"üîç [Analytics] Buscando KPIs atuais para marca: {marca}")
            
            with self._obter_conexao_segura() as conn:
                res = conn.execute(query).df()
            
            if res.empty or res["valor_estoque"][0] is None:
                print(f"‚ö†Ô∏è [Analytics] Nenhum dado encontrado para a marca: {marca}")
                return {
                    "status": "vazio",
                    "data_referencia": datetime.now(),
                    "valor_estoque": 0.0,
                    "investimento_pendente": 0.0,
                    "cobertura_media": 0.0
                }

            return {
                "status": "ok",
                "data_referencia": res["data_referencia"][0],
                "valor_estoque": float(res["valor_estoque"][0]),
                "investimento_pendente": float(res["investimento_pendente"][0]),
                "cobertura_media": float(res["cobertura_media"][0])
            }

        except Exception as e:
            print(f"‚ùå [Analytics] Erro cr√≠tico ao buscar KPIs: {str(e)}")
            return {"status": "erro", "erro_msg": str(e)}

    def get_tendencia_cobertura(self, marca="TODAS", dias_historico=90):
        """Busca a evolu√ß√£o da cobertura por Curva ABC para o gr√°fico."""
        try:
            condicao_marca = "" if marca == "TODAS" else f"WHERE marca = '{marca}'"
            
            query = f"""
                SELECT 
                    CAST(data_snapshot AS DATE) as data,
                    curva_abc,
                    AVG(cobertura_meses) as cobertura_meses
                FROM historico_snapshots
                {condicao_marca}
                GROUP BY 1, 2
                HAVING data >= CURRENT_DATE - INTERVAL {dias_historico} DAY
                ORDER BY 1 ASC, 2 ASC
            """
            
            print(f"üìà [Analytics] Gerando tend√™ncia de cobertura (Marca: {marca})")
            
            with self._obter_conexao_segura() as conn:
                return conn.execute(query).pl()

        except Exception as e:
            print(f"‚ùå [Analytics] Erro ao processar tend√™ncia: {str(e)}")
            return pl.DataFrame()
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/analytics_service.py


START FILE: src/compras_sistema/data_engine/duckdb_manager.py
--------------------------------------------------------------------------------
"""
Gerenciador de conex√µes DuckDB com pool thread-safe.
Implementa federa√ß√£o com SQLite.
"""
import duckdb
from pathlib import Path
from contextlib import contextmanager
from threading import Lock
import structlog

logger = structlog.get_logger(__name__)

class DuckDBManager:
    """
    Gerenciador singleton de conex√µes DuckDB.
    Implementa connection pooling para queries paralelas.
    """
    
    def __init__(self, memory_limit: str = "2GB", threads: int = 4):
        self.memory_limit = memory_limit
        self.threads = threads
        self._conn = None
        self._lock = Lock()
        
    def initialize(self, sqlite_path: Path):
        """
        Inicializa conex√£o DuckDB e configura federa√ß√£o com SQLite.
        
        Args:
            sqlite_path: Caminho para o banco SQLite (vendas e estoque)
        """
        if not sqlite_path.exists():
            logger.warning("sqlite_not_found", path=str(sqlite_path))

        with self._lock:
            if self._conn is None:
                self._conn = duckdb.connect(":memory:")
                
                # Configura√ß√µes de performance
                self._conn.execute(f"SET memory_limit='{self.memory_limit}'")
                self._conn.execute(f"SET threads TO {self.threads}")
                self._conn.execute("SET enable_progress_bar=true")
                
                # Attach SQLite
                # Agora assumimos que a tabela 'saldo_custo_entrada' est√° dentro deste banco
                try:
                    self._conn.execute(f"""
                        ATTACH '{str(sqlite_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)
                    """)
                    logger.info("sqlite_attached", path=str(sqlite_path))
                except Exception as e:
                    logger.error("sqlite_attach_error", error=str(e))
                    raise

                logger.info("duckdb_initialized")

    @contextmanager
    def get_connection(self):
        """Context manager para obter conex√£o thread-safe."""
        with self._lock:
            if self._conn is None:
                raise RuntimeError("DuckDB n√£o inicializado. Chame initialize() primeiro.")
            yield self._conn

    def execute_query_file(self, query_file: Path) -> duckdb.DuckDBPyRelation:
        """Executa query SQL de arquivo."""
        if not query_file.exists():
            raise FileNotFoundError(f"Arquivo de query n√£o encontrado: {query_file}")

        with open(query_file, 'r', encoding='utf-8') as f:
            query = f.read()
        
        with self.get_connection() as conn:
            return conn.execute(query)

    def close(self):
        """Fecha conex√£o DuckDB."""
        if self._conn:
            self._conn.close()
            self._conn = None
            logger.info("duckdb_closed")
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/duckdb_manager.py


START FILE: src/compras_sistema/data_engine/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/__init__.py


START FILE: src/compras_sistema/data_engine/history_recorder.py
--------------------------------------------------------------------------------
import polars as pl
import duckdb
from datetime import datetime
from pathlib import Path
import structlog

logger = structlog.get_logger(__name__)

class HistoryRecorder:
    def __init__(self, db_manager):
        self.history_db_path = Path("data/analytics.duckdb")
        self.db_manager = db_manager

    def inicializar_tabela(self):
        """Cria a tabela no arquivo analytics.duckdb se n√£o existir."""
        try:
            with duckdb.connect(str(self.history_db_path)) as conn:
                # A ORDEM AQUI √â CR√çTICA:
                # 1. data_snapshot
                # 2. cod_produto
                # ...
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS historico_snapshots (
                        data_snapshot TIMESTAMP,
                        cod_produto VARCHAR,
                        curva_abc VARCHAR,
                        saldo_estoque INTEGER,
                        media_venda_dia DOUBLE,
                        custo_unitario DOUBLE,
                        sugestao_final INTEGER
                    )
                """)
                logger.info("tabela_historico_verificada", path=str(self.history_db_path))
        except Exception as e:
            logger.error("erro_inicializar_historico", error=str(e))

    def gravar_snapshot(self, df_final: pl.DataFrame):
        """Grava o resumo do dia no arquivo persistente."""
        try:
            logger.info("gravando_snapshot_historico")
            
            # Adiciona data de hoje
            df_history = df_final.with_columns(
                pl.lit(datetime.now()).alias("data_snapshot")
            )
            
            # CORRE√á√ÉO CR√çTICA: 
            # Reordenamos as colunas do DataFrame para bater EXATAMENTE com a tabela SQL.
            # Se a ordem estiver diferente, o DuckDB tenta inserir produto na coluna de data.
            cols_ordenadas = [
                "data_snapshot",      # 1
                "cod_produto",        # 2
                "curva_abc",          # 3
                "saldo_estoque",      # 4
                "media_venda_dia",    # 5
                "custo_unitario",     # 6
                "sugestao_final"      # 7
            ]
            
            # Seleciona apenas o que existe e na ordem certa
            df_history = df_history.select([
                c for c in cols_ordenadas if c in df_history.columns
            ])
            
            # 2. Conecta no arquivo F√çSICO e insere
            with duckdb.connect(str(self.history_db_path)) as conn:
                conn.execute("INSERT INTO historico_snapshots SELECT * FROM df_history")
                
            logger.info("snapshot_gravado_sucesso", linhas=len(df_history))
            
        except Exception as e:
            logger.error("erro_gravar_snapshot", error=str(e))
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/history_recorder.py


START FILE: src/compras_sistema/data_engine/queries/abc_financeiro.sql
--------------------------------------------------------------------------------
/*
  C√°lculo da Curva ABC Financeira (Pareto)
  Regra: 
    A = At√© 80% do faturamento acumulado
    B = De 80% at√© 95%
    C = Restante
*/

WITH vendas_por_produto AS (
    SELECT 
        cod_produto,
        SUM(valor_total) as total_vendido
    FROM sqlite_db.vendas
    WHERE 
        -- Converte texto para data e pega os √∫ltimos 12 meses
        TRY_CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '12 months')
    GROUP BY cod_produto
    HAVING total_vendido > 0
),

calculo_acumulado AS (
    SELECT 
        cod_produto,
        total_vendido,
        -- Soma acumulada ordenada do maior para o menor
        SUM(total_vendido) OVER (ORDER BY total_vendido DESC) as valor_acumulado,
        -- Valor total geral de todas as vendas
        SUM(total_vendido) OVER () as valor_total_geral
    FROM vendas_por_produto
)

SELECT 
    cod_produto,
    total_vendido,
    valor_acumulado,
    (valor_acumulado / valor_total_geral) as percentual_acumulado,
    CASE 
        WHEN (valor_acumulado / valor_total_geral) <= 0.80 THEN 'A'
        WHEN (valor_acumulado / valor_total_geral) <= 0.95 THEN 'B'
        ELSE 'C'
    END as curva_abc
FROM calculo_acumulado
ORDER BY total_vendido DESC;
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/queries/abc_financeiro.sql


START FILE: src/compras_sistema/data_engine/queries/estatisticas_vendas.sql
--------------------------------------------------------------------------------
/*
  C√°lculo de Estat√≠sticas Avan√ßadas: Tend√™ncias e Valida√ß√£o de Giro (12m)
  Corre√ß√£o: Reintrodu√ß√£o da coluna dias_com_venda necess√°ria para o XYZ.
*/

WITH vendas_tratadas AS (
    SELECT 
        cod_produto,
        TRY_CAST(data_movimento AS DATE) as data_venda,
        quantidade,
        cod_clifor,
        MAX(ref_fornecedor) OVER (PARTITION BY cod_produto) as ref_fornecedor,
        MAX(marca) OVER (PARTITION BY cod_produto) as marca
    FROM sqlite_db.vendas
    WHERE 
        -- Pega hist√≥rico longo para c√°lculo de Dias de Vida
        TRY_CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '48 months')
),

periodos AS (
    SELECT
        cod_produto,
        MAX(marca) as marca,
        MAX(ref_fornecedor) as ref_fornecedor,
        
        -- Per√≠odos Curtos para Tend√™ncia (90 dias)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '90 days') THEN quantidade ELSE 0 END) as qtd_trimestre_atual,
        COUNT(DISTINCT CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '90 days') THEN cod_clifor END) as clientes_trimestre_atual,
        SUM(CASE WHEN data_venda < (CURRENT_DATE - INTERVAL '90 days') AND data_venda >= (CURRENT_DATE - INTERVAL '180 days') THEN quantidade ELSE 0 END) as qtd_trimestre_anterior,
        COUNT(DISTINCT CASE WHEN data_venda < (CURRENT_DATE - INTERVAL '90 days') AND data_venda >= (CURRENT_DATE - INTERVAL '180 days') THEN cod_clifor END) as clientes_trimestre_anterior,

        -- Venda 12 Meses (Cr√≠tico para Valida√ß√£o de Giro)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '12 months') THEN quantidade ELSE 0 END) as venda_total_12m,

        -- Dados Gerais (Baseados no parametro meses_analise)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '{meses_analise} months') THEN quantidade ELSE 0 END) as total_vendido,
        
        -- A COLUNA QUE FALTAVA FOI REINSERIDA ABAIXO:
        COUNT(DISTINCT CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '{meses_analise} months') THEN data_venda END) as dias_com_venda,
        
        MAX(data_venda) as ultima_venda,
        MIN(data_venda) as primeira_venda,
        COUNT(DISTINCT cod_clifor) as total_clientes_unicos,
        STDDEV_POP(quantidade) as std_venda_dia_amostra
    FROM vendas_tratadas
    GROUP BY cod_produto
)

SELECT 
    *,
    DATE_DIFF('day', primeira_venda, ultima_venda) + 1 as dias_intervalo,
    CASE 
        WHEN (DATE_DIFF('day', primeira_venda, ultima_venda) + 1) <= 1 THEN total_vendido 
        ELSE CAST(total_vendido AS DOUBLE) / (DATE_DIFF('day', primeira_venda, ultima_venda) + 1)
    END as media_venda_dia,
    COALESCE(std_venda_dia_amostra, 0.0) as std_venda_dia
FROM periodos;

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/queries/estatisticas_vendas.sql


START FILE: src/compras_sistema/rule_engine/base_rule.py
--------------------------------------------------------------------------------
from abc import ABC, abstractmethod
import polars as pl
from typing import Dict, Any

class BaseRule(ABC):
    """
    Classe abstrata para todas as regras de neg√≥cio.
    Garante que toda regra tenha um m√©todo 'apply'.
    """
    
    @abstractmethod
    def apply(self, df: pl.LazyFrame, config: Any) -> pl.LazyFrame:
        """
        Aplica a regra de neg√≥cio ao DataFrame.
        """
        pass
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/base_rule.py


START FILE: src/compras_sistema/rule_engine/stock/estoque_math.py
--------------------------------------------------------------------------------
import polars as pl
import numpy as np
from datetime import datetime

class EstoqueMath:
    """Classe com m√©todos est√°ticos para c√°lculos de estoque"""
    
    @staticmethod
    def _ler_config(objeto_config, atributo_ou_chave):
        """
        Tenta ler uma configura√ß√£o seja ela um Atributo (Objeto) ou Chave (Dict).
        """
        try:
            return getattr(objeto_config, atributo_ou_chave)
        except AttributeError:
            return objeto_config[atributo_ou_chave]

    @staticmethod
    def aplicar_sazonalidade_projetada(df: pl.DataFrame, indices_dict: dict) -> pl.DataFrame:
        """
        Calcula o fator sazonal baseando-se na DATA DE CHEGADA da mercadoria.
        """
        if not indices_dict or len(indices_dict) != 12:
            return df.with_columns(pl.lit(1.0).alias("fator_sazonal_projetado"))
        
        lista_indices = [indices_dict.get(m, 1.0) for m in range(1, 13)]
        mes_atual = datetime.now().month
        
        def calcular_fator_futuro(leadtime):
            if leadtime is None:
                leadtime = 7
            
            meses_espera = leadtime / 30.0
            duracao_estoque = 1.5
            soma_indices = 0.0
            pontos_verificados = 0
            cursor = meses_espera
            fim_janela = meses_espera + duracao_estoque
            
            while cursor < fim_janela:
                mes_futuro_absoluto = mes_atual + int(cursor)
                index_lista = (mes_futuro_absoluto - 1) % 12
                soma_indices += lista_indices[index_lista]
                pontos_verificados += 1
                cursor += 0.5
            
            if pontos_verificados == 0:
                return 1.0
            
            fator = soma_indices / pontos_verificados
            return max(0.5, min(fator, 2.5))
        
        return df.with_columns([
            pl.col("lead_time_dias").map_elements(
                calcular_fator_futuro, return_dtype=pl.Float64
            ).alias("fator_sazonal_projetado")
        ])

    @staticmethod
    def calcular_tendencias(df: pl.DataFrame) -> pl.DataFrame:
        """
        Calcula as classifica√ß√µes de Tend√™ncia e Perfil de Cliente.
        """
        if "var_vendas" not in df.columns:
            df = df.with_columns([
                pl.lit(0.0).alias("var_vendas"),
                pl.lit(0).alias("saldo_clientes"),
                pl.lit(0).alias("qtd_clientes_ativos")
            ])
        
        return df.with_columns([
            # 1. TEND√äNCIA VENDAS
            pl.when(pl.col("var_vendas").fill_null(0.0) > 0.20).then(pl.lit("EM ALTA"))
            .when(pl.col("var_vendas").fill_null(0.0) < -0.20).then(pl.lit("EM QUEDA"))
            .otherwise(pl.lit("EST√ÅVEL")).alias("tendencia_vendas"),
            
            # 2. TEND√äNCIA CLIENTES
            pl.when(pl.col("saldo_clientes").fill_null(0) > 0)
            .then(pl.format("GANHO +{}", pl.col("saldo_clientes")))
            .when(pl.col("saldo_clientes").fill_null(0) < 0)
            .then(pl.format("PERDA {}", pl.col("saldo_clientes")))
            .otherwise(pl.lit("MANTEVE")).alias("tendencia_clientes"),
            
            # 3. PERFIL CLIENTE
            pl.when(pl.col("qtd_clientes_ativos").fill_null(0) == 0).then(pl.lit("Sem Venda"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 2).then(pl.lit("Dedicado (1-2)"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 9).then(pl.lit("Concentrado (3-9)"))
            .otherwise(pl.lit("Pulverizado (10+)")).alias("perfil_cliente")
        ])

    @staticmethod
    def calcular_seguranca(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Estoque de Seguran√ßa."""
        def get_z_factor(xyz):
            if xyz == "X":
                return 1.65
            if xyz == "Y":
                return 1.28
            return 0.84
        
        return df.with_columns([
            pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64).alias("fator_z"),
            (
                pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64) *
                pl.col("std_venda_dia") *
                pl.col("lead_time_dias").fill_null(7).sqrt()
            ).fill_null(0).alias("estoque_seguranca")
        ])

    @staticmethod
    def calcular_necessidades(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Calcula Ponto de Suprimento e Estoque Meta.
        CORRIGIDO: C√°lculo de datas (dias_vida)
        """
        # 1. Acessa as se√ß√µes de forma segura
        cfg_compras = EstoqueMath._ler_config(config, 'compras')
        cfg_produto = EstoqueMath._ler_config(config, 'produto')

        # 2. Acessa os valores
        meses_cobertura = EstoqueMath._ler_config(cfg_compras, 'meses_cobertura')
        dias_novo = EstoqueMath._ler_config(cfg_produto, 'dias_lancamento')
        
        # MELHORIA 1: Calcula dias_vida com sintaxe CORRIGIDA
        # (Agora - Data).total_days()
        df = df.with_columns([
            (pl.lit(datetime.now()) - pl.col("data_cadastro").cast(pl.Datetime)).dt.total_days().alias("dias_vida")
        ])
        
        # MELHORIA 2: Boost anti-ruptura apenas para itens VELHOS
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                pl.col("curva_abc").is_in(["A", "B"]) &
                (pl.col("dias_vida") > dias_novo) 
            )
            .then(
                pl.when(pl.col("dias_sem_venda") > 30).then(pl.col("media_venda_dia") * 1.20)
                .when(pl.col("dias_sem_venda") > 90).then(pl.col("media_venda_dia") * 1.50)
                .otherwise(pl.col("media_venda_dia") * 2.00)
            )
            .otherwise(pl.col("media_venda_dia"))
            .alias("media_calculo")
        ])
        
        return df.with_columns([
            (pl.col("media_calculo") * pl.col("lead_time_dias") + pl.col("estoque_seguranca")).round(0).alias("ponto_suprimento"),
            (pl.col("media_calculo") * 30 * meses_cobertura + pl.col("estoque_seguranca")).round(0).alias("estoque_meta")
        ]).with_columns([
            (pl.col("estoque_meta") - pl.col("saldo_estoque") - pl.col("saldo_oc")).alias("sugestao_bruta")
        ])

    @staticmethod
    def aplicar_lote_economico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Arredonda para lotes econ√¥micos"""
        return df.with_columns([
            pl.when(pl.col("sugestao_bruta") <= 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("necessidade_liquida")
        ]).with_columns([
            (pl.col("necessidade_liquida") / pl.col("lote_economico")).ceil().alias("lotes_cheios")
        ]).with_columns([
            (pl.col("lotes_cheios") * pl.col("lote_economico")).cast(pl.Int32).alias("sugestao_final")
        ]).with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal")
        ])

    @staticmethod
    def calcular_score(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula pontua√ß√£o inicial de prioridade"""
        return df.with_columns([
            (
                pl.when(pl.col("saldo_estoque") == 0).then(5000).otherwise(0) +
                pl.when(pl.col("saldo_estoque") < pl.col("media_venda_dia") * pl.col("lead_time_dias")).then(2500).otherwise(0) +
                pl.when(pl.col("curva_abc") == "A").then(1000).when(pl.col("curva_abc") == "B").then(500).otherwise(100) +
                pl.when(pl.col("tendencia_vendas") == "EM ALTA").then(500).otherwise(0) +
                (pl.col("media_venda_dia") * pl.col("custo_unitario")).fill_null(0)
            ).round(0).cast(pl.Int32).alias("score")
        ])

    @staticmethod
    def gerar_diagnostico(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Gera diagn√≥sticos e aplica a l√≥gica de ITEM NOVO.
        CORRIGIDO: C√°lculo de datas (dias_vida)
        """
        estoque_total = pl.col("saldo_estoque") + pl.col("saldo_oc")
        venda_mensal = pl.col("media_venda_dia") * 30
        
        # 1. Acesso seguro
        cfg_produto = EstoqueMath._ler_config(config, 'produto')
        dias_novo = EstoqueMath._ler_config(cfg_produto, 'dias_lancamento')
        
        # Calcula dias_vida se ainda n√£o existir (CORRIGIDO)
        if "dias_vida" not in df.columns:
            df = df.with_columns([
                (pl.lit(datetime.now()) - pl.col("data_cadastro").cast(pl.Datetime)).dt.total_days().alias("dias_vida")
            ])
        
        # C√°lculo de Cobertura
        base_calc = pl.when(estoque_total == 0).then(0.0).otherwise(estoque_total / venda_mensal)
        calc_cobertura = pl.when(base_calc.is_infinite()).then(99.0).otherwise(base_calc).fill_nan(99.0)
        
        df = df.with_columns([calc_cobertura.alias("cobertura_virtual_meses")])
        
        # 1. VALIDA√á√ÉO DE GIRO (O Juiz)
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                (pl.col("saldo_oc") == 0) &
                (pl.col("media_venda_dia") == 0)
            )
            .then(
                pl.when(pl.col("dias_vida") <= dias_novo)
                .then(pl.lit("SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)"))
                .otherwise(pl.lit("SEM MOVIMENTO (Item velho parado)"))
            )
            .when(pl.col("cobertura_virtual_meses") > 6).then(pl.lit("ALERTA: Excesso > 6m"))
            .when((pl.col("media_venda_dia") < 0.05) & (pl.col("sugestao_final") > 0)).then(pl.lit("ALERTA: Sem Venda Recente"))
            .otherwise(pl.lit("COERENTE")).alias("validacao_giro")
        ])
        
        # MELHORIA: Salva sugest√£o original antes do bloqueio
        df = df.with_columns([
            pl.col("sugestao_final").alias("sugestao_calculada")
        ])
        
        # 2. APLICA BLOQUEIOS E DEFINE MOTIVO
        df = df.with_columns([
            # Define motivo do bloqueio
            pl.when(pl.col("ativo") == "NO").then(pl.lit("Produto inativo no cadastro"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.col("validacao_giro"))
            .otherwise(pl.lit("")).alias("motivo_bloqueio"),
            
            # Flag: Foi calculado mas bloqueado?
            pl.when(
                (pl.col("sugestao_final") > 0) &
                ((pl.col("ativo") == "NO") | pl.col("validacao_giro").str.contains("ALERTA"))
            ).then(pl.lit("SIM")).otherwise(pl.lit("N√ÉO")).alias("calculado_mas_bloqueado"),
            
            # Aplica bloqueio na sugest√£o
            pl.when(pl.col("ativo") == "NO").then(0)
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)")
            .then(pl.col("lote_economico"))  # Item novo = 1 lote
            .otherwise(pl.col("sugestao_final")).alias("sugestao_final")
        ])
        
        # MELHORIA 3: RECALCULA SCORE AP√ìS BLOQUEIOS
        df = df.with_columns([
            pl.when(pl.col("sugestao_final") == 0).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)").then(pl.lit(9999))
            .otherwise(pl.col("score")).alias("score")
        ])
        
        # 4. STATUS DIAGN√ìSTICO FINAL
        df = df.with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal"),
            
            pl.when(pl.col("ativo") == "NO").then(pl.lit("INATIVO"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.lit("BLOQUEADO"))
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)").then(pl.lit("IMPLANTA√á√ÉO"))
            .when(pl.col("saldo_estoque") == 0).then(pl.lit("RUPTURA"))
            .when(pl.col("sugestao_final") > 0).then(pl.lit("COMPRAR"))
            .when(pl.col("cobertura_virtual_meses") > 12).then(pl.lit("EXCESSO"))
            .otherwise(pl.lit("OK")).alias("status_diagnostico")
        ])
        
        return df
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/stock/estoque_math.py


START FILE: src/compras_sistema/rule_engine/validators/input_schema.py
--------------------------------------------------------------------------------
import pandera.polars as pa
import polars as pl

class InputCalcSchema(pa.DataFrameModel):
    """
    Contrato de dados obrigat√≥rio antes de entrar no Motor Matem√°tico.
    Garante que n√£o existem nulos onde n√£o deve e que os tipos est√£o certos.
    """
    
    # Identifica√ß√£o
    cod_produto: str
    
    # Dados de Estoque (N√£o podem ser nulos)
    # coerce=True tenta converter string "10" para int 10 automaticamente
    saldo_estoque: int = pa.Field(coerce=True) 
    saldo_oc: int = pa.Field(coerce=True)
    
    # Dados de Venda (Essenciais para o c√°lculo)
    media_venda_dia: float = pa.Field(ge=0.0, coerce=True)
    std_venda_dia: float = pa.Field(ge=0.0, coerce=True)
    
    # Par√¢metros Log√≠sticos
    lead_time_dias: float = pa.Field(ge=0, coerce=True)
    
    # CR√çTICO: Lote 0 causa divis√£o por zero no script
    lote_economico: int = pa.Field(gt=0, coerce=True) 
    
    # Classifica√ß√µes
    curva_abc: str = pa.Field(isin=["A", "B", "C"])
    curva_xyz: str = pa.Field(isin=["X", "Y", "Z"])
    
    # Datas (Essencial para a l√≥gica de Item Novo)
    data_cadastro: pl.Date

    class Config:
        # strict=False permite que o DataFrame tenha colunas extras (descricao, marca, etc)
        # sem dar erro. Validamos apenas as colunas essenciais listadas acima.
        strict = False
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/validators/input_schema.py


START FILE: src/compras_sistema/rule_engine/validators/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/validators/__init__.py


START FILE: src/compras_sistema/rule_engine/classification/xyz_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

class XYZClassifier:
    def __init__(self, db_manager: DuckDBManager, config):
        self.db = db_manager
        self.config = config

    def run(self) -> pl.DataFrame:
        # A Query continua a mesma (Corrigida para olhar apenas os √∫ltimos 365 dias)
        query = """
        WITH vendas_recentes AS (
            -- 1. Pega apenas vendas dos √∫ltimos 365 dias
            SELECT 
                cod_produto,
                CAST(data_movimento AS DATE) as data,
                SUM(quantidade) as qtd_dia
            FROM sqlite_db.vendas
            WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            GROUP BY 1, 2
        ),
        estatisticas AS (
            SELECT 
                cod_produto,
                -- Desvio padr√£o das vendas nos dias que houve venda
                STDDEV(qtd_dia) as std_venda_dia,
                
                -- M√âDIA CORRETA: Total vendido no ano / 365 dias
                -- (Isso garante que dias sem venda puxem a m√©dia para baixo)
                SUM(qtd_dia) / 365.0 as media_venda_dia,
                
                -- Coeficiente de Varia√ß√£o (CV)
                (STDDEV(qtd_dia) / NULLIF(AVG(qtd_dia), 0)) as cv
            FROM vendas_recentes
            GROUP BY 1
        )
        SELECT 
            CAST(cod_produto AS VARCHAR) as cod_produto,
            COALESCE(media_venda_dia, 0.0) as media_venda_dia,
            COALESCE(std_venda_dia, 0.0) as std_venda_dia,
            CASE 
                WHEN media_venda_dia <= 0 THEN 'Z' -- Se m√©dia √© 0, √© Z (Morto)
                WHEN cv <= 0.5 THEN 'X'  -- Muito est√°vel
                WHEN cv <= 1.0 THEN 'Y'  -- Vari√°vel
                ELSE 'Z'                 -- Imprevis√≠vel
            END as curva_xyz
        FROM estatisticas
        """
        
        # --- CORRE√á√ÉO AQUI ---
        # Usamos o gerenciador de contexto para abrir a conex√£o de forma segura
        with self.db.get_connection() as conn:
            # Executa a query e converte direto para Polars
            df = conn.execute(query).pl()
        
        return df
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/xyz_classifier.py


START FILE: src/compras_sistema/rule_engine/classification/abc_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from pathlib import Path
from ...data_engine.duckdb_manager import DuckDBManager
import structlog

logger = structlog.get_logger(__name__)

class ABCClassifier:
    """Calcula a Curva ABC Financeira usando DuckDB."""
    
    def __init__(self, db_manager: DuckDBManager):
        self.db = db_manager
        # Caminho autom√°tico para o arquivo SQL
        self.query_path = Path(__file__).parent.parent.parent / "data_engine" / "queries" / "abc_financeiro.sql"

    def run(self) -> pl.DataFrame:
        """Executa a classifica√ß√£o ABC e retorna DataFrame Polars."""
        logger.info("iniciando_curva_abc")
        
        if not self.query_path.exists():
            raise FileNotFoundError(f"Query n√£o encontrada: {self.query_path}")

        # L√™ o arquivo SQL
        with open(self.query_path, 'r', encoding='utf-8') as f:
            query = f.read()

        # Executa no banco e converte para Polars
        with self.db.get_connection() as conn:
            df = conn.execute(query).pl()
            
        logger.info("curva_abc_concluida", total_produtos=len(df))
        return df

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/abc_classifier.py


START FILE: src/compras_sistema/rule_engine/classification/trend_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

class TrendClassifier:
    def __init__(self, db_manager: DuckDBManager):
        self.db = db_manager

    def run(self) -> pl.DataFrame:
        """
        Calcula tend√™ncias de Vendas, Clientes e DIAS SEM VENDA (Ruptura Temporal).
        """
        query = """
        WITH periodos AS (
            SELECT 
                cod_produto,
                MAX(data_movimento) as ultima_venda,
                -- Vendas Recentes (90 dias) vs Ano (365 dias)
                SUM(CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '90 days') THEN quantidade ELSE 0 END) as qtd_90d,
                SUM(CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days') THEN quantidade ELSE 0 END) as qtd_365d,
                
                -- Contagem de Clientes √önicos
                COUNT(DISTINCT CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '90 days') THEN cod_clifor END) as clientes_atuais,
                COUNT(DISTINCT CASE WHEN CAST(data_movimento AS DATE) < (CURRENT_DATE - INTERVAL '90 days') 
                                     AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '180 days') THEN cod_clifor END) as clientes_anteriores
            FROM sqlite_db.vendas
            WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            GROUP BY 1
        )
        SELECT 
            CAST(cod_produto AS VARCHAR) as cod_produto,
            
            -- C√°lculo de dias sem venda (usado para boost de ruptura)
            date_diff('day', CAST(ultima_venda AS DATE), CURRENT_DATE) as dias_sem_venda,

            -- Varia√ß√£o de Vendas (%)
            CASE 
                WHEN qtd_365d = 0 THEN 0
                ELSE ((qtd_90d * 4.0) / qtd_365d) - 1.0 
            END as var_vendas,
            
            -- Saldo de Clientes
            (clientes_atuais - clientes_anteriores) as saldo_clientes,
            clientes_atuais as qtd_clientes_ativos
        FROM periodos
        """
        
        with self.db.get_connection() as conn:
            return conn.execute(query).pl()
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/trend_classifier.py


START FILE: scripts/teste_matematica.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

# Configura√ß√£o de Caminho para importar o c√≥digo fonte
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.core.config import ConfigManager # <--- Importante!

def main():
    print("\nüßÆ --- CALCULADORA DE COMPRAS (PROVA REAL) ---")
    print("Digite os dados para simular um produto:\n")

    try:
        # 1. Coleta de Dados
        media_venda = float(input("M√©dia Venda Di√°ria (ex: 1.5): "))
        std_venda = float(input("Desvio Padr√£o Venda (ex: 0.5): "))
        lead_time = int(input("Lead Time em dias (ex: 10): "))
        class_xyz = input("Classe XYZ (X/Y/Z): ").upper()
        estoque_atual = int(input("Saldo F√≠sico Atual: "))
        oc_atual = int(input("Saldo em OC (Carteira): "))
        lote = int(input("Lote M√∫ltiplo (ex: 12): "))
        
        # 2. Carregar Configura√ß√£o REAL do projeto
        config_mgr = ConfigManager()
        config_mgr.load_configs(PROJECT_ROOT / "config")
        config = config_mgr.parametros
        
        # Sobrescrevemos o Lead Time padr√£o com o que voc√™ digitou no teste
        config.lead_time.padrao_dias = lead_time
        
        # 3. Cria√ß√£o do DataFrame Fake
        df = pl.DataFrame({
            "cod_produto": ["TESTE-01"],
            "media_venda_dia": [media_venda],
            "std_venda_dia": [std_venda],
            "lead_time_dias": [lead_time],
            "curva_xyz": [class_xyz],
            "saldo_estoque": [estoque_atual],
            "saldo_oc": [oc_atual],
            "lote_economico": [lote],
            "custo_unitario": [10.0] # Fict√≠cio
        })

        # 4. Execu√ß√£o das F√≥rmulas Reais
        print("\n‚öôÔ∏è  Rodando c√°lculos do sistema...")
        df = EstoqueMath.calcular_seguranca(df, config)
        df = EstoqueMath.calcular_necessidades(df, config)
        df = EstoqueMath.aplicar_lote_economico(df, config)

        # 5. Resultados
        res = df.row(0, named=True)
        
        print(f"\nüìä RESULTADOS PARA O PRODUTO:")
        print(f"-----------------------------------")
        print(f"Estoque de Seguran√ßa: {res['estoque_seguranca']} pe√ßas")
        print(f"Ponto de Suprimento:  {res['ponto_suprimento']} pe√ßas")
        print(f"Estoque Meta:         {res['estoque_meta']} pe√ßas")
        print(f"Sugest√£o Bruta:       {res['sugestao_bruta']} pe√ßas")
        print(f"-----------------------------------")
        print(f"SUGEST√ÉO FINAL:       {res['sugestao_final']} pe√ßas (Arredondado)")
        print(f"Lotes Cheios:         {res['lotes_cheios']}")
        print(f"Subtotal Estimado:    R$ {res['subtotal']:.2f}")

    except Exception as e:
        print(f"\n‚ùå Erro nos dados: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/teste_matematica.py


START FILE: scripts/gerar_relatorio_final.py
--------------------------------------------------------------------------------
import sys
import argparse
import json
from pathlib import Path
from datetime import datetime
import polars as pl
import traceback
from pandera.errors import SchemaError

# Configura√ß√£o de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

# Imports do Sistema
from compras_sistema.core.config import ConfigManager
from compras_sistema.core.system_guard import SystemGuard
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.history_recorder import HistoryRecorder
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.classification.trend_classifier import TrendClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.export.excel_exporter import ExcelExporter

# Import do Validador
try:
    from compras_sistema.rule_engine.validators.input_schema import InputCalcSchema
except ImportError:
    InputCalcSchema = None

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--marca", type=str, default="TODAS", help="Filtrar por marca")
    parser.add_argument("--simulacao", action="store_true", help="N√£o gera Excel, apenas calcula")
    args = parser.parse_args()
    
    guard = SystemGuard(PROJECT_ROOT / "logs")
    print(f"--- LOG START ---")
    guard.log(f"Processamento Iniciado - Marca: {args.marca}")
    
    # Inicializa√ß√£o
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")
    
    recorder = HistoryRecorder(db) if not args.simulacao else None
    if recorder:
        recorder.inicializar_tabela()
    
    try:
        # --- 1. CLASSIFICA√á√ïES ESTAT√çSTICAS ---
        guard.log("Calculando Classifica√ß√µes ABC, XYZ, Tend√™ncias...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        trend_engine = TrendClassifier(db)
        
        df_abc = abc_engine.run()
        df_xyz = xyz_engine.run()
        df_trend = trend_engine.run()
        
        # --- 2. LEITURA DE DADOS (SNAPSHOT) ---
        guard.log("Lendo Estoques e Cadastro Completo...")
        with db.get_connection() as conn:
            # L√™ saldos
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto,
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
            """).pl()
            
            # Leitura din√¢mica do cadastro
            try:
                cols_db = [c[1] for c in conn.execute("PRAGMA table_info(sqlite_db.produtos_gerais)").fetchall()]
                
                col_desc = "descricao_produto" if "descricao_produto" in cols_db else ("descricao" if "descricao" in cols_db else "''")
                col_data = "CAST(data_cadastro AS DATE)" if "data_cadastro" in cols_db else "CAST('2000-01-01' AS DATE)"
                col_ref = "ref_fornecedor" if "ref_fornecedor" in cols_db else "''"
                
                df_cadastro = conn.execute(f"""
                    SELECT 
                        CAST(cod_produto AS VARCHAR) as cod_produto,
                        CAST(qtd_economica AS INTEGER) as lote_economico,
                        marca,
                        {col_desc} as descricao,
                        {col_ref} as ref_fornecedor,
                        ativo,
                        {col_data} as data_cadastro
                    FROM sqlite_db.produtos_gerais
                """).pl()
            except Exception as e:
                guard.log(f"Erro ao ler cadastro: {e}. Usando estrutura vazia de seguran√ßa.")
                df_cadastro = pl.DataFrame(schema={
                    "cod_produto": pl.Utf8, "lote_economico": pl.Int64, "marca": pl.Utf8,
                    "descricao": pl.Utf8, "ref_fornecedor": pl.Utf8, "ativo": pl.Utf8,
                    "data_cadastro": pl.Date
                })
        
        # Carrega Sazonalidade
        indices_dict = {}
        try:
            analytics_path = PROJECT_ROOT / "data" / "analytics.duckdb"
            if analytics_path.exists():
                with db.get_connection() as conn:
                    conn.execute(f"ATTACH '{analytics_path}' AS analytics")
                    rows = conn.execute("SELECT mes, indice_sazonal FROM analytics.indices_sazonais").fetchall()
                    conn.execute("DETACH analytics")
                    for r in rows:
                        indices_dict[r[0]] = r[1]
        except Exception as e:
            guard.log(f"Aviso: Sazonalidade n√£o carregada ({e}). Usando padr√£o 1.0.")
            pass
        
        # --- 3. UNIFICA√á√ÉO (JOIN) ---
        guard.log("Cruzando dados...")
        
        df_universe = pl.concat([
            df_xyz.select("cod_produto"),
            df_saldo.select("cod_produto"),
            df_cadastro.select("cod_produto")
        ]).unique(subset="cod_produto")
        
        df_final = (df_universe
            .join(df_xyz, on="cod_produto", how="left")
            .join(df_abc, on="cod_produto", how="left")
            .join(df_trend, on="cod_produto", how="left")
            .join(df_saldo, on="cod_produto", how="left")
            .join(df_cadastro, on="cod_produto", how="left"))
        
        if "descricao" not in df_final.columns:
            if "descricao_right" in df_final.columns:
                df_final = df_final.rename({"descricao_right": "descricao"})
            else:
                df_final = df_final.with_columns(pl.lit("SEM DESCRI√á√ÉO").alias("descricao"))
        
        # --- 4. TRATAMENTO, DETEC√á√ÉO E VALIDA√á√ÉO ---
        
        lead_time_padrao = config_mgr.parametros.lead_time.padrao_dias
        if isinstance(lead_time_padrao, dict):
            lead_time_padrao = lead_time_padrao.get('padrao_dias', 10)
            
        # A. Preenchimento B√°sico (Nulos viram Zero, Negativos s√£o mantidos)
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").fill_null(0.0),
            pl.col("std_venda_dia").fill_null(0.0),
            pl.col("curva_xyz").fill_null("Z"),
            pl.col("dias_sem_venda").fill_null(0).alias("dias_sem_venda"),
            
            # Aqui permitimos negativos para o relat√≥rio
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            
            pl.col("custo_unitario").fill_null(0.0),
            pl.col("curva_abc").fill_null("C"),
            pl.col("marca").fill_null("N/D"),
            pl.col("descricao").fill_null("DESCRI√á√ÉO N√ÉO ENCONTRADA"),
            pl.col("ref_fornecedor").fill_null(""),
            pl.col("lote_economico").fill_null(1).map_elements(lambda x: max(1, x), return_dtype=pl.Int64),
            pl.col("ativo").fill_null("SIM"),
            pl.col("data_cadastro").fill_null(pl.lit(datetime(2000,1,1)).cast(pl.Date)),
            pl.lit(lead_time_padrao).alias("lead_time_dias"),
        ])

        # B. Detec√ß√£o de Anomalias (Cria√ß√£o de Alertas)
        df_final = df_final.with_columns([
            pl.when(pl.col("saldo_estoque") < 0)
            .then(pl.lit("ESTOQUE NEGATIVO"))
            .when(pl.col("saldo_oc") < 0)
            .then(pl.lit("OC NEGATIVA (ERRO ERP)"))
            .otherwise(None)
            .alias("alerta_dados")
        ])

        # C. Log de Problemas (Console)
        df_problemas = df_final.filter(pl.col("alerta_dados").is_not_null())
        if not df_problemas.is_empty():
            guard.log(f"‚ö†Ô∏è ATEN√á√ÉO: Encontrados {len(df_problemas)} produtos com anomalias de dados!")
            for row in df_problemas.head(3).iter_rows(named=True):
                guard.log(f"   -> Produto {row['cod_produto']}: {row['alerta_dados']} (Est: {row['saldo_estoque']} | OC: {row['saldo_oc']})")

        # D. Valida√ß√£o Pandera (Agora permite negativos, mas garante integridade estrutural)
        if InputCalcSchema:
            guard.log("Validando integridade dos dados (Pandera)...")
            try:
                df_final = InputCalcSchema.validate(df_final)
                guard.log("‚úÖ Dados estruturais validados!")
            except SchemaError as e:
                guard.log(f"‚ùå ERRO DE VALIDA√á√ÉO DE DADOS:")
                guard.log(f"Falha na coluna: {e.schema.name if e.schema else 'Schema Global'}")
                guard.log(f"Motivo: {e.check}")
                if e.failure_cases is not None:
                     print("\nüìã REGISTROS QUE FALHARAM NA VALIDA√á√ÉO (Top 5):")
                     print(e.failure_cases.head(5))
                sys.exit(1)
        else:
            guard.log("‚ö†Ô∏è Aviso: InputCalcSchema n√£o encontrado. Pulando valida√ß√£o.")

        # --- 5. MOTOR DE C√ÅLCULO ---
        guard.log("Executando Motor Matem√°tico...")
        
        # Salva m√©dia base
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").alias("media_venda_base")
        ])
        
        # Sazonalidade
        df_final = EstoqueMath.aplicar_sazonalidade_projetada(df_final, indices_dict)
        
        df_final = df_final.with_columns([
            pl.col("fator_sazonal_projetado").alias("fator_sazonal"),
            (pl.col("media_venda_base") * pl.col("fator_sazonal_projetado")).alias("media_venda_dia")
        ])
        
        # PREPARA√á√ÉO PARA MATEM√ÅTICA (Sanitiza√ß√£o Tempor√°ria)
        # O motor matem√°tico n√£o deve receber OC negativa, pois distorce o c√°lculo.
        # Mas o estoque negativo √© OK (aumenta a necessidade).
        df_math = df_final.with_columns([
            pl.col("saldo_oc").clip(lower_bound=0) # Sanitiza apenas para o c√°lculo
        ])
        
        # Executa C√°lculos no DF Sanitizado
        df_math = EstoqueMath.calcular_tendencias(df_math)
        df_math = EstoqueMath.calcular_seguranca(df_math, config_mgr.parametros)
        df_math = EstoqueMath.calcular_necessidades(df_math, config_mgr.parametros)
        df_math = EstoqueMath.aplicar_lote_economico(df_math, config_mgr.parametros)
        df_math = EstoqueMath.calcular_score(df_math)
        df_math = EstoqueMath.gerar_diagnostico(df_math, config_mgr.parametros)
        
        # Recupera as colunas calculadas de volta para o df_final (que tem os dados originais/negativos)
        # Assim o Excel mostra a OC negativa (alerta) mas a sugest√£o de compra est√° correta (ignorando o erro)
        cols_calculadas = [
            "tendencia_vendas", "tendencia_clientes", "perfil_cliente", # Tendencias
            "estoque_seguranca", "fator_z",                             # Seguranca
            "ponto_suprimento", "estoque_meta", "sugestao_bruta",       # Necessidades
            "media_calculo", "dias_vida",                               # Necessidades Aux
            "lotes_cheios", "sugestao_final", "subtotal",               # Lote
            "score",                                                    # Score
            "validacao_giro", "motivo_bloqueio",                        # Diagnostico
            "calculado_mas_bloqueado", "status_diagnostico", 
            "cobertura_virtual_meses", "sugestao_calculada"
        ]
        
        # Junta os resultados calculados de volta no dataframe principal
        df_final = df_final.with_columns(df_math.select(cols_calculadas))
        
        # KPI Final de Posi√ß√£o
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") + pl.col("saldo_oc") + pl.col("sugestao_final")).alias("meta_pos_compra")
        ])
        
        # --- 6. FILTROS E EXPORTA√á√ÉO ---
        
        if args.marca and args.marca != "TODAS":
            guard.log(f"Filtrando relat√≥rio para marca: {args.marca}")
            df_final = df_final.filter(pl.col("marca") == args.marca)
        
        # C√°lculo de Estat√≠sticas
        try:
            val_estoque_atual = df_final.select((pl.col("saldo_estoque") * pl.col("custo_unitario")).sum()).item()
            val_venda_mensal = df_final.select((pl.col("media_venda_dia") * 30 * pl.col("custo_unitario")).sum()).item()
            
            if val_venda_mensal > 0:
                cobertura = val_estoque_atual / val_venda_mensal
            else:
                cobertura = 0.0
        except:
            val_estoque_atual = 0.0
            cobertura = 0.0
        
        df_compra = df_final.filter(pl.col("sugestao_final") > 0)
        
        stats = {
            "total_valor": df_compra["subtotal"].sum(),
            "total_skus": len(df_compra),
            "total_pecas": df_compra["sugestao_final"].sum(),
            "estoque_atual": val_estoque_atual,
            "cobertura_meses": cobertura
        }
        
        print(f"STATS_DATA={json.dumps(stats)}")
        
        # Exporta√ß√£o Excel
        if not args.simulacao:
            guard.log("Gerando relat√≥rio Excel...")
            exporter = ExcelExporter(PROJECT_ROOT / "data" / "exports")
            # Ordena com prioridade para Alertas de Dados
            df_final = df_final.sort(["alerta_dados", "score"], descending=[True, True])
            arquivo = exporter.exportar_sugestao(df_final)
            guard.log(f"Relat√≥rio gerado: {arquivo}")
            
            if recorder:
                recorder.gravar_snapshot(df_final)
        
        guard.log("Processamento conclu√≠do com sucesso!")
        
    except Exception as e:
        guard.log(f"ERRO CR√çTICO: {e}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/gerar_relatorio_final.py


START FILE: scripts/export_project_context.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

# Configura√ß√£o
PROJECT_ROOT = Path(__file__).parent.parent
OUTPUT_FILE = PROJECT_ROOT / "contexto_completo_para_ia.txt"

# Pastas e arquivos que queremos incluir
INCLUDED_DIRS = [
    PROJECT_ROOT / "src",
    PROJECT_ROOT / "scripts",
    PROJECT_ROOT / "config",
]

# Arquivos espec√≠ficos para ignorar (opcional)
IGNORE_FILES = ["__pycache__", ".DS_Store", "vendas.db", "analytics.duckdb", ".git", ".vscode"]

def generate_tree(root_dir):
    """Gera uma representa√ß√£o visual da √°rvore de arquivos."""
    tree_str = "PROJECT STRUCTURE:\n"
    for path in sorted(root_dir.rglob('*')):
        if any(part.startswith('.') or part == "__pycache__" for part in path.parts):
            continue
        if path.is_file() and path.suffix in ['.py', '.yaml', '.json', '.sql']:
            depth = len(path.relative_to(root_dir).parts)
            indent = '    ' * (depth - 1)
            tree_str += f"{indent}‚îú‚îÄ‚îÄ {path.name}\n"
    return tree_str + "\n" + "="*50 + "\n\n"

def main():
    print(f"üì¶ Empacotando projeto em: {OUTPUT_FILE}")
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # 1. Escreve o Cabe√ßalho e Estrutura
        out.write("CONTEXTO DO PROJETO DE COMPRAS E ESTOQUE\n")
        out.write("Linguagem: Python 3.11\n")
        out.write("Libs principais: Polars, DuckDB, OpenPyXL\n\n")
        out.write(generate_tree(PROJECT_ROOT))
        
        # 2. Varre os arquivos e escreve o conte√∫do
        for folder in INCLUDED_DIRS:
            if not folder.exists(): continue
            
            for root, dirs, files in os.walk(folder):
                # Filtra pastas ignoradas
                dirs[:] = [d for d in dirs if d not in IGNORE_FILES]
                
                for file in files:
                    if file in IGNORE_FILES or not file.endswith(('.py', '.yaml')):
                        continue
                        
                    file_path = Path(root) / file
                    rel_path = file_path.relative_to(PROJECT_ROOT)
                    
                    # Escreve o separador e o nome do arquivo
                    out.write(f"FILE: {rel_path}\n")
                    out.write("-" * 50 + "\n")
                    
                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            content = f.read()
                            out.write(content)
                    except Exception as e:
                        out.write(f"# Erro ao ler arquivo: {e}")
                    
                    out.write("\n\n" + "="*50 + "\n\n")
    
    print("‚úÖ Arquivo gerado com sucesso!")
    print("Agora voc√™ pode anexar 'contexto_completo_para_ia.txt' no chat da IA.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/export_project_context.py


START FILE: scripts/auditor_item.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb
from datetime import datetime
import math

# Configura√ß√£o de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    print("üïµÔ∏è  AUDITOR DE C√ÅLCULO DE COMPRAS (RAIO-X - DB INTEGRADO)")
    print("==========================================")
    cod_alvo = input("Digite o C√ìDIGO DO PRODUTO para auditar: ").strip()

    # 1. CONEX√ÉO COM DADOS
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    
    if not db_path.exists():
        print("‚ùå Banco de dados vendas.db n√£o encontrado!")
        return

    conn = duckdb.connect()
    conn.execute("INSTALL sqlite; LOAD sqlite;")
    conn.execute(f"ATTACH '{db_path}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
    
    print(f"\nüîç 1. DADOS BRUTOS (Banco de Dados)")
    print("-" * 50)

    # --- BUSCA DADOS CADASTRAIS ---
    try:
        cadastro = conn.execute(f"""
            SELECT ativo, qtd_economica, marca 
            FROM sqlite_db.produtos_gerais 
            WHERE cod_produto = '{cod_alvo}'
        """).fetchone()
        
        ativo = cadastro[0] if cadastro else "SIM (N√£o encontrado)"
        lote = cadastro[1] if cadastro and cadastro[1] else 1
        marca = cadastro[2] if cadastro else "N/D"
    except:
        ativo = "ERRO LEITURA"
        lote = 1
        marca = "?"
    
    print(f"‚Ä¢ Cadastro: Ativo={ativo} | Lote={lote} | Marca={marca}")

    # --- BUSCA ESTOQUE (NOVA TABELA) ---
    try:
        estoque_data = conn.execute(f"""
            SELECT saldo_estoque, saldo_oc, custo_unitario, ultima_entrada
            FROM sqlite_db.saldo_custo_entrada
            WHERE CAST(cod_produto AS VARCHAR) = '{cod_alvo}'
        """).fetchone()
    except Exception as e:
        print(f"‚ùå Erro ao ler tabela 'saldo_custo_entrada': {e}")
        estoque_data = None
    
    if not estoque_data:
        print("‚ùå ERRO: Item n√£o encontrado na tabela de saldo!")
        return

    saldo = estoque_data[0] if estoque_data[0] else 0
    saldo_oc = estoque_data[1] if estoque_data[1] else 0
    custo = estoque_data[2] if estoque_data[2] else 0.0
    ult_entrada = estoque_data[3]
    
    print(f"‚Ä¢ Estoque: F√≠sico={saldo} | OC={saldo_oc} | Custo=R${custo:.2f}")
    print(f"‚Ä¢ √öltima Entrada: {ult_entrada}")

    # --- BUSCA VENDAS (M√âDIA REAL 365 DIAS) ---
    vendas_365 = conn.execute(f"""
        SELECT SUM(quantidade) 
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
        AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
    """).fetchone()
    
    total_vendas_ano = vendas_365[0] if vendas_365[0] else 0
    media_diaria_real = total_vendas_ano / 365.0
    
    print(f"‚Ä¢ Vendas 365 dias: {total_vendas_ano} pe√ßas")
    print(f"‚Ä¢ M√©dia Di√°ria (Total/365): {media_diaria_real:.4f}")

    # ... (O restante do c√≥digo de c√°lculo permanece igual, pois usa as vari√°veis carregadas acima) ...
    # Para economizar espa√ßo, mantive apenas a parte de extra√ß√£o de dados que mudou.
    
    # ... [C√ìDIGO DE C√ÅLCULO MANTIDO IGUAL AO ORIGINAL] ...

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/auditor_item.py


START FILE: scripts/teste_score.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

def main():
    print("\nüèÜ --- CALCULADORA DE SCORE (GAMIFICATION) ---")
    
    try:
        curva_abc = input("Curva ABC (A/B/C): ").upper()
        sugestao = int(input("Sugest√£o de Compra (>0?): "))
        estoque = int(input("Saldo de Estoque (pode ser 0 ou negativo): "))
        
        print("\n--- Dados Auxiliares ---")
        media_dia = float(input("M√©dia Venda Dia: "))
        custo = float(input("Custo Unit√°rio (R$): "))
        lead_time = int(input("Lead Time (dias): "))
        crescimento = float(input("Crescimento Vendas % (ex: 0.25 para 25%): "))

        # DataFrame Fake
        df = pl.DataFrame({
            "cod_produto": ["TESTE-SCORE"],
            "curva_abc": [curva_abc],
            "sugestao_final": [sugestao],
            "saldo_estoque": [estoque],
            "media_venda_dia": [media_dia],
            "custo_unitario": [custo],
            "lead_time_dias": [lead_time],
            "var_vendas": [crescimento],
            # Campos necess√°rios para rodar sem erro
            "curva_xyz": ["X"], 
            "std_venda_dia": [0]
        })

        print("\n‚öôÔ∏è  Calculando pontos...")
        df = EstoqueMath.calcular_score(df)
        
        score = df['score'][0]
        
        print(f"\nüéñÔ∏è  PONTUA√á√ÉO FINAL: {score} PONTOS")
        print(f"-----------------------------------")
        print("Crit√©rios Atendidos:")
        if sugestao > 0:
            if estoque <= 0: print("‚úÖ Ruptura Total (+5000)")
            elif (estoque / media_dia) < lead_time: print("‚úÖ Risco Iminente (+2500)")
            
            if curva_abc == "A": print("‚úÖ Curva A (+1000)")
            elif curva_abc == "B": print("‚úÖ Curva B (+500)")
            
            if crescimento > 0.20: print("‚úÖ Tend√™ncia Alta (+500)")
            
            giro_diario = media_dia * custo
            print(f"‚úÖ Giro Financeiro (+{int(giro_diario)})")
        else:
            print("üö´ Sem Sugest√£o de Compra (Score zerado)")

    except Exception as e:
        print(f"\n‚ùå Erro: {e}")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/teste_score.py


START FILE: scripts/fix_toml.py
--------------------------------------------------------------------------------
from pathlib import Path

# Conte√∫do correto do pyproject.toml
content = """[project]
name = "compras-estoque-sistema"
version = "1.0.0"
description = "Sistema modular de compras e gest√£o de estoque"
requires-python = ">=3.11"
dependencies = [
    "duckdb>=1.1.0",
    "polars>=1.12.0",
    "pydantic>=2.9.0",
    "pyyaml>=6.0.2",
    "pandera[polars]>=0.20.4",
    "structlog>=24.4.0",
    "openpyxl>=3.1.5",
    "reportlab>=4.2.5",
    "pyinstaller>=6.11.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.3",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "hypothesis>=6.115.6",
    "ruff>=0.7.4",
    "mypy>=1.13.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
dev-dependencies = ["ruff", "mypy", "pytest"]

# Esta se√ß√£o ensina o hatchling onde encontrar o c√≥digo
[tool.hatch.build.targets.wheel]
packages = ["src/compras_sistema"]
"""

# Reescreve o arquivo na raiz do projeto
root_dir = Path(__file__).parent.parent
toml_path = root_dir / "pyproject.toml"

print(f"üîß Corrigindo: {toml_path}")
with open(toml_path, "w", encoding="utf-8") as f:
    f.write(content)

print("‚úÖ pyproject.toml corrigido com sucesso!")
--------------------------------------------------------------------------------
END FILE: scripts/fix_toml.py


START FILE: scripts/test_calculo_estoque.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

structlog.configure(processors=[structlog.processors.JSONRenderer()])

def main():
    print("üöÄ Iniciando C√°lculo Completo de Estoque (DB Integrado)...")
    
    # 1. Config e Banco
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    # ATUALIZADO: Inicializa apenas com o SQLite
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")

    try:
        # 2. Rodar Classificadores (ABC + XYZ)
        print("‚ö° Calculando ABC e XYZ...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        
        df_abc = abc_engine.run() 
        df_xyz = xyz_engine.run() 

        # 3. Buscar Dados de Estoque (Agora da tabela SQL)
        print("üì¶ Buscando Saldos no Banco de Dados...")
        with db.get_connection() as conn:
            # ATUALIZADO: Query na tabela sqlite_db.saldo_custo_entrada
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto, 
                    saldo_estoque, 
                    saldo_oc, 
                    custo_unitario
                FROM sqlite_db.saldo_custo_entrada
            """).pl()

        # 4. O Grande Join (Unindo tudo)
        print("üîó Unificando dados...")
        df_final = (
            df_xyz
            .join(df_abc, on="cod_produto", how="left")
            .join(df_saldo, on="cod_produto", how="left")
        )
        
        # Preenche nulos
        df_final = df_final.with_columns([
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            pl.col("curva_abc").fill_null("C")
        ])

        # 5. Aplicar Matem√°tica de Estoque
        print("üßÆ Calculando ES, PS e EM...")
        df_final = EstoqueMath.calcular_seguranca(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_necessidades(df_final, config_mgr.parametros)

        # 6. Calcular Sugest√£o
        df_final = df_final.with_columns([
            (pl.col("estoque_meta") - (pl.col("saldo_estoque") + pl.col("saldo_oc"))).alias("sugestao_bruta")
        ]).with_columns([
            pl.when(pl.col("sugestao_bruta") < 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("sugestao_final")
        ])

        # 7. Mostrar Resultados
        print("\n‚úÖ C√°lculo Finalizado!")
        print("-" * 50)
        
        compras = df_final.filter(pl.col("sugestao_final") > 0).sort("sugestao_final", descending=True)
        
        print(f"üì¶ Total de Produtos Analisados: {len(df_final)}")
        print(f"üí∞ Produtos com Sugest√£o de Compra: {len(compras)}")
        
        print("\nüèÜ Top 5 Sugest√µes de Compra (Volume):")
        cols_show = ["cod_produto", "curva_abc", "curva_xyz", "saldo_estoque", "estoque_seguranca", "estoque_meta", "sugestao_final"]
        print(compras.select(cols_show).head(5))

    except Exception as e:
        print(f"\n‚ùå Erro Cr√≠tico: {e}")
        import traceback
        traceback.print_exc()
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/test_calculo_estoque.py


START FILE: scripts/test_xyz.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Setup
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier

structlog.configure(processors=[structlog.processors.JSONRenderer()])

def main():
    print("üöÄ Testando Classifica√ß√£o XYZ (Previsibilidade)...")
    
    # 1. Carregar Configura√ß√µes (Importante para pegar os thresholds X e Y)
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    # 2. Inicializar Banco
    db = DuckDBManager()
    db.initialize(
        PROJECT_ROOT / "data" / "vendas.db",
        PROJECT_ROOT / "data" / "Saldo Estoque OC Custo Ultima Entrada Spaal.csv"
    )
    
    try:
        # 3. Executar XYZ
        classifier = XYZClassifier(db, config_mgr.parametros)
        df_xyz = classifier.run()
        
        print(f"\n‚úÖ Sucesso! Classifica√ß√£o gerada.")
        
        print("\nüìä Resumo da Distribui√ß√£o XYZ:")
        print(df_xyz.group_by("curva_xyz").len().sort("curva_xyz"))
        
        print("\nüîç Exemplo de Produto X (Reloginho):")
        print(df_xyz.filter(df_xyz["curva_xyz"] == "X").head(3).select([
            "cod_produto", "media_venda_dia", "coeficiente_variacao", "curva_xyz"
        ]))

        print("\nüîç Exemplo de Produto Z (Imprevis√≠vel):")
        print(df_xyz.filter(df_xyz["curva_xyz"] == "Z").head(3).select([
            "cod_produto", "media_venda_dia", "coeficiente_variacao", "curva_xyz"
        ]))

    except Exception as e:
        print(f"\n‚ùå Erro: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/test_xyz.py


START FILE: scripts/setup_database.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path
import sys

# Setup de caminhos
ROOT_DIR = Path(__file__).parent.parent
DATA_DIR = ROOT_DIR / "data"
DB_PATH = DATA_DIR / "vendas.db"

def setup_database():
    print("üöÄ Iniciando cria√ß√£o do Banco de Dados de Vendas...")
    
    # 1. Encontrar o arquivo de vendas (CSV)
    # Procura arquivos que contenham "Movimento" ou "Vendas" no nome
    sales_files = list(DATA_DIR.glob("*ovimento*.csv")) + list(DATA_DIR.glob("*endas*.csv"))
    
    if not sales_files:
        print("‚ùå Nenhum arquivo de vendas encontrado na pasta 'data/'!")
        print("   Por favor, coloque o arquivo CSV de vendas (ex: 'Movimento.csv') l√°.")
        return
    
    csv_path = sales_files[0]
    print(f"üìÇ Arquivo de origem detectado: {csv_path.name}")

    # 2. Conectar ao DuckDB (em mem√≥ria para processamento r√°pido)
    con = duckdb.connect()
    
    try:
        # 3. Ler o CSV e tratar colunas
        # Baseado no PDF, mapeamos os nomes originais para o padr√£o do sistema
        print("‚è≥ Lendo CSV e convertendo dados...")
        
        # Cria uma view tempor√°ria lendo o CSV
        con.execute(f"""
            CREATE VIEW raw_vendas AS 
            SELECT * FROM read_csv_auto('{str(csv_path)}', normalize_names=True)
        """)
        
        # Verifica quais colunas existem para garantir o mapeamento
        columns = [c[0] for c in con.execute("DESCRIBE raw_vendas").fetchall()]
        print(f"   Colunas detectadas: {columns}")
        
        # Query de transforma√ß√£o (Adapte os nomes 'cod_produto', 'data', etc se necess√°rio)
        # O DuckDB normalize_names remove acentos e espa√ßos (ex: "C√≥d. Produto" vira "cod_produto")
        query = """
            SELECT 
                CAST(cod_produto AS VARCHAR) as cod_produto,
                CAST(data AS DATE) as data_movimento,
                CAST(qtde AS INTEGER) as quantidade,
                CAST(total AS DECIMAL(10,2)) as valor_total,
                CAST(cod_clifor AS INTEGER) as cod_cliente,
                uf as uf_cliente
            FROM raw_vendas
            WHERE data IS NOT NULL
        """
        
        # 4. Salvar no SQLite
        print(f"üíæ Salvando em {DB_PATH.name}...")
        
        # Remove banco antigo se existir para recriar do zero
        if DB_PATH.exists():
            DB_PATH.unlink()
            
        con.execute(f"ATTACH '{str(DB_PATH)}' AS sqlite_db (TYPE SQLITE)")
        con.execute(f"CREATE TABLE sqlite_db.vendas AS {query}")
        
        # Valida√ß√£o
        count = con.execute("SELECT COUNT(*) FROM sqlite_db.vendas").fetchone()[0]
        print(f"\n‚úÖ Sucesso! {count:,} registros de vendas importados.")
        
        # Mostra pr√©via
        print("\nüìä Amostra dos dados gravados:")
        print(con.execute("SELECT * FROM sqlite_db.vendas LIMIT 5").df())
        
    except Exception as e:
        print(f"\n‚ùå Erro durante a importa√ß√£o: {e}")
        print("Dica: Verifique se os nomes das colunas no CSV batem com a query.")
        
    finally:
        con.close()

if __name__ == "__main__":
    setup_database()
--------------------------------------------------------------------------------
END FILE: scripts/setup_database.py


START FILE: scripts/verificar_ambiente.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Adiciona o src ao path para poder importar os m√≥dulos
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

# Configurar logger simples para o teste
structlog.configure(
    processors=[structlog.processors.JSONRenderer()],
)

def main():
    print("üöÄ Iniciando verifica√ß√£o do ambiente...\n")
    
    # 1. Teste de Configura√ß√£o
    try:
        config_mgr = ConfigManager()
        config_mgr.load_configs(project_root / "config")
        print("‚úÖ Configura√ß√µes carregadas com sucesso!")
    except Exception as e:
        print(f"‚ùå Erro ao carregar configura√ß√µes: {e}")
        return

    # 2. Teste de Banco de Dados
    sqlite_path = project_root / "data" / "vendas.db" 
    
    if not sqlite_path.exists():
        print(f"‚ö†Ô∏è  Banco de dados n√£o encontrado em: {sqlite_path}")
    
    try:
        db = DuckDBManager()
        db.initialize(sqlite_path)
        
        with db.get_connection() as conn:
            # Verifica se a nova tabela existe
            print("‚è≥ Verificando tabela 'saldo_custo_entrada'...")
            try:
                res = conn.execute("SELECT * FROM sqlite_db.saldo_custo_entrada LIMIT 3").pl()
                print("\n‚úÖ Tabela de Estoque encontrada no Banco de Dados!")
                print("\nüìä Pr√©via dos Dados:")
                print(res)
            except Exception as e:
                print(f"\n‚ùå Tabela 'saldo_custo_entrada' N√ÉO encontrada no banco! Erro: {e}")
                
    except Exception as e:
        print(f"‚ùå Erro no DuckDB: {e}")

    print("\nüèÅ Verifica√ß√£o conclu√≠da.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/verificar_ambiente.py


START FILE: scripts/teste_giro.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl
from datetime import datetime, timedelta

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.core.config import ConfigManager # <--- Importante!

def main():
    print("\nüõë --- VALIDADOR DE GIRO (FREIO DE M√ÉO v23.0) ---")
    print("Simule o cen√°rio para ver se o sistema aprova ou bloqueia.\n")

    try:
        # Inputs Focados na Regra
        dias_vida = int(input("Dias de Vida do Item (ex: 400 para antigo, 30 para novo): "))
        venda_12m = int(input("Venda Total dos √öltimos 12 Meses: "))
        estoque_total = int(input("Estoque Atual + OC: "))
        sugestao = int(input("Quanto o sistema sugeriu comprar? "))
        
        # Datas simuladas
        hoje = datetime.now().date()
        data_cadastro = hoje - timedelta(days=dias_vida)
        
        # DataFrame Fake
        df = pl.DataFrame({
            "cod_produto": ["TESTE-GIRO"],
            "primeira_venda": [data_cadastro],
            "ultima_venda": [hoje],
            "venda_total_12m": [venda_12m],
            "saldo_estoque": [estoque_total],
            "saldo_oc": [0],
            "sugestao_final": [sugestao],
            "media_venda_dia": [venda_12m/365 if venda_12m > 0 else 0], 
            "estoque_seguranca": [0],
            "total_clientes_unicos": [5]
        })

        print("\n‚öôÔ∏è  O Juiz est√° analisando...")
        
        # Carregar Configura√ß√£o REAL
        config_mgr = ConfigManager()
        config_mgr.load_configs(PROJECT_ROOT / "config")
        config = config_mgr.parametros
        
        # Executa APENAS o diagn√≥stico
        df = EstoqueMath.gerar_diagnostico(df, config)
        
        res = df.row(0, named=True)
        
        print(f"\n‚öñÔ∏è  VEREDITO DO SISTEMA:")
        print(f"-----------------------------------")
        print(f"Item Novo?           {'SIM' if dias_vida < 365 else 'N√ÉO'}")
        print(f"M√©dia Mensal (12m):  {res.get('media_mensal_real', venda_12m/12):.2f} pe√ßas/m√™s")
        if 'cobertura_projetada' in res:
            print(f"Cobertura Projetada: {res['cobertura_projetada']:.1f} meses")
        print(f"-----------------------------------")
        print(f"DECIS√ÉO FINAL:       {res['validacao_giro']}")
        
        if "Excesso" in res['validacao_giro']:
            print("üî¥ O sistema BLOQUEOU a compra por excesso de cobertura.")
        elif "Sem Venda" in res['validacao_giro']:
            print("üî¥ O sistema BLOQUEOU pois o item parece morto.")
        elif "COERENTE" in res['validacao_giro']:
            print("üü¢ Compra APROVADA.")

    except Exception as e:
        print(f"\n‚ùå Erro: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/teste_giro.py


START FILE: scripts/testar_analytics.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

# Setup de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.analytics_service import AnalyticsService

def main():
    print("--- üìä TESTE DO SERVI√áO DE ANALYTICS (CORRIGIDO) ---")
    
    # 1. Conex√£o
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    print(f"üìÇ Conectando ao banco: {db_path}")
    
    db = DuckDBManager()
    db.initialize(db_path)
    
    # --- DIAGN√ìSTICO DO BANCO DE DADOS ---
    print("\nüîç Verificando tabelas existentes no DuckDB:")
    with db.get_connection() as conn:
        tabelas = conn.execute("SHOW TABLES").fetchall()
        lista_tabelas = [t[0] for t in tabelas]
        print(f"   Tabelas encontradas: {lista_tabelas}")
        
        if "historico_snapshots" not in lista_tabelas:
            print("   ‚ö†Ô∏è AVISO CR√çTICO: Tabela 'historico_snapshots' N√ÉO EXISTE.")
            print("   -> Solu√ß√£o: Rode 'python scripts/gerar_relatorio_final.py' novamente para criar a tabela.")
        else:
            qtd = conn.execute("SELECT COUNT(*) FROM historico_snapshots").fetchone()[0]
            print(f"   ‚úÖ Tabela 'historico_snapshots' existe com {qtd} registros.")

    service = AnalyticsService(db)
    
    # 2. Teste de KPIs Atuais
    print("\n1. Buscando KPIs Atuais...")
    kpis = service.get_kpis_atuais()
    print(f"   Resultado: {kpis}")
    
    # 3. Teste de Tend√™ncia (Gr√°fico)
    print("\n2. Buscando Tend√™ncia de Cobertura (Hist√≥rico)...")
    
    # CORRE√á√ÉO AQUI: O par√¢metro correto √© 'dias_historico', n√£o 'dias'
    df_tendencia = service.get_tendencia_cobertura(dias_historico=30)
    
    if df_tendencia.is_empty():
        print("‚ö†Ô∏è DataFrame vazio! O servi√ßo rodou, mas n√£o achou dados no per√≠odo.")
    else:
        print(f"‚úÖ Sucesso! Retornou {len(df_tendencia)} linhas.")
        print(df_tendencia)
        
        print("\n--- Pr√©via dos Dados para o Gr√°fico ---")
        for row in df_tendencia.iter_rows(named=True):
            print(f"Data: {row['data']} | Curva: {row['curva_abc']} | Cobertura: {row['cobertura_meses']} meses")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/testar_analytics.py


START FILE: scripts/debug_item.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    cod_alvo = input("Digite o c√≥digo do produto problem√°tico: ")
    
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    conn = duckdb.connect()
    conn.execute("INSTALL sqlite; LOAD sqlite;")
    conn.execute(f"ATTACH '{db_path}' AS sqlite_db (TYPE SQLITE)")
    
    print(f"\nüîç INVESTIGANDO O ITEM: {cod_alvo}")
    print("-" * 50)
    
    # 1. Vendas Totais da Hist√≥ria
    total_hist = conn.execute(f"""
        SELECT SUM(quantidade), MIN(data_movimento), MAX(data_movimento) 
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
    """).fetchone()
    print(f"Hist√≥rico Completo: {total_hist[0]} pe√ßas vendidas de {total_hist[1]} at√© {total_hist[2]}")
    
    # 2. Vendas nos √öltimos 12 Meses (O que importa para o c√°lculo)
    venda_12m = conn.execute(f"""
        SELECT SUM(quantidade)
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
        AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
    """).fetchone()[0]
    
    venda_12m = venda_12m if venda_12m else 0
    media_calc = venda_12m / 365.0
    
    print(f"Venda √öltimos 365 dias: {venda_12m} pe√ßas")
    print(f"M√©dia Di√°ria Real (Total/365): {media_calc:.4f}")
    print("-" * 50)
    
    if venda_12m == 0:
        print("‚úÖ DIAGN√ìSTICO: O item est√° MORTO (0 vendas em 1 ano).")
        print("A m√©dia DEVE ser 0.00.")
    else:
        print("‚ö†Ô∏è DIAGN√ìSTICO: Existem vendas ocultas nos √∫ltimos 12 meses.")
        # Mostra as vendas fantasmas
        print("\nüìÖ Detalhe das vendas encontradas (√∫ltimos 12 meses):")
        detalhe = conn.execute(f"""
            SELECT data_movimento, quantidade 
            FROM sqlite_db.vendas 
            WHERE cod_produto = '{cod_alvo}'
            AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            ORDER BY data_movimento DESC
        """).df()
        print(detalhe)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/debug_item.py


START FILE: scripts/test_abc.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Setup de paths
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier

# Configura√ß√£o de Logs
structlog.configure(processors=[structlog.processors.JSONRenderer()])

def main():
    print("üöÄ Testando Curva ABC Financeira...")
    
    # 1. Inicializar Banco
    sqlite_path = PROJECT_ROOT / "data" / "vendas.db"
    csv_path = PROJECT_ROOT / "data" / "Saldo Estoque OC Custo Ultima Entrada Spaal.csv"
    
    db = DuckDBManager()
    db.initialize(sqlite_path, csv_path)
    
    try:
        # 2. Executar Classificador
        classifier = ABCClassifier(db)
        df_abc = classifier.run()
        
        # 3. Mostrar Resultados
        print(f"\n‚úÖ Sucesso! Classificamos {len(df_abc)} produtos.")
        
        print("\nüìä Resumo da Classifica√ß√£o:")
        resumo = df_abc.group_by("curva_abc").len().sort("curva_abc")
        print(resumo)
        
        print("\nüèÜ Top 5 Produtos Curva A:")
        print(df_abc.filter(df_abc["curva_abc"] == "A").head(5))

    except Exception as e:
        print(f"\n‚ùå Erro: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/test_abc.py


START FILE: scripts/calcular_sazonalidade.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    print("üåä Calculando √çndices de Sazonalidade...")
    
    # Caminhos dos arquivos
    sqlite_path = PROJECT_ROOT / "data" / "vendas.db"
    
    # Usaremos um arquivo DuckDB persistente para salvar os √≠ndices
    # Assim o outro script consegue ler depois
    duck_path = PROJECT_ROOT / "data" / "analytics.duckdb"
    
    # Conecta (ou cria) o banco anal√≠tico
    conn = duckdb.connect(str(duck_path))
    
    try:
        # 1. Instala suporte a SQLite (caso n√£o tenha)
        conn.execute("INSTALL sqlite; LOAD sqlite;")
        
        # 2. Anexa o banco de vendas (O PULO DO GATO QUE FALTAVA)
        # Agora o DuckDB enxerga o 'sqlite_db'
        print(f"üîå Conectando ao hist√≥rico: {sqlite_path}")
        conn.execute(f"ATTACH '{sqlite_path}' AS sqlite_db (TYPE SQLITE)")
        
        # 3. Cria tabela de √≠ndices
        print("üìä Processando estat√≠sticas mensais...")
        conn.execute("""
            CREATE OR REPLACE TABLE indices_sazonais AS
            WITH vendas_mensais AS (
                SELECT 
                    EXTRACT(MONTH FROM CAST(data_movimento AS DATE)) as mes,
                    SUM(quantidade) as qtd_total
                FROM sqlite_db.vendas
                WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '24 months')
                GROUP BY 1
            ),
            media_global AS (
                SELECT AVG(qtd_total) as media_ano FROM vendas_mensais
            )
            SELECT 
                mes,
                qtd_total / media_global.media_ano as indice_sazonal
            FROM vendas_mensais, media_global
            ORDER BY mes;
        """)
        
        print("‚úÖ √çndices calculados e salvos em 'analytics.duckdb':")
        print(conn.execute("SELECT * FROM indices_sazonais").df())
        
    except Exception as e:
        print(f"‚ùå Erro: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/calcular_sazonalidade.py


START FILE: scripts/inspect_db.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path

# Caminhos
BASE_DIR = Path(__file__).parent.parent
DB_PATH = BASE_DIR / "data" / "vendas.db"

def inspect():
    print(f"üîç Inspecionando banco de dados: {DB_PATH}")
    
    if not DB_PATH.exists():
        print("‚ùå ERRO: O arquivo 'vendas.db' n√£o foi encontrado na pasta 'data/'")
        return

    try:
        con = duckdb.connect(":memory:")
        con.execute(f"ATTACH '{str(DB_PATH)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
        
        # Verifica tabela
        print("\nüìã Estrutura da tabela 'vendas':")
        print(f"{'Nome da Coluna':<25} | {'Tipo de Dado'}")
        print("-" * 45)
        
        # CORRE√á√ÉO: Usamos fetchall() (listas nativas) em vez de .df()
        columns = con.execute("DESCRIBE sqlite_db.vendas").fetchall()
        
        for col in columns:
            name = col[0]
            dtype = col[1]
            print(f"{name:<25} | {dtype}")

        print("\nüìä Amostra de dados (Via Polars):")
        # Aqui usamos .pl() porque o Polars j√° est√° instalado e testado
        print(con.execute("SELECT * FROM sqlite_db.vendas LIMIT 3").pl())

    except Exception as e:
        print(f"‚ùå Erro ao ler o banco: {e}")

if __name__ == "__main__":
    inspect()

--------------------------------------------------------------------------------
END FILE: scripts/inspect_db.py


START FILE: .pytest_cache/README.md
--------------------------------------------------------------------------------
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

--------------------------------------------------------------------------------
END FILE: .pytest_cache/README.md


START FILE: backups/antes_melhorias/gerar_relatorio_final.py
--------------------------------------------------------------------------------
codigo_relatorio = '''"""
Script principal de gera√ß√£o de relat√≥rios - VERS√ÉO MELHORADA
Aplica sazonalidade preservando m√©dia base
"""
import sys
import argparse
import json
from pathlib import Path
from datetime import datetime
import polars as pl
import traceback

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.core.config import ConfigManager
from compras_sistema.core.system_guard import SystemGuard
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.history_recorder import HistoryRecorder
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.classification.trend_classifier import TrendClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.export.excel_exporter import ExcelExporter


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--marca", type=str, default="TODAS", help="Filtrar por marca")
    parser.add_argument("--simulacao", action="store_true", help="N√£o gera Excel, apenas calcula")
    args = parser.parse_args()
    
    guard = SystemGuard(PROJECT_ROOT / "logs")
    print(f"--- LOG START ---")
    guard.log(f"Processamento Iniciado - Marca: {args.marca}")
    
    # Inicializa√ß√£o
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")
    
    recorder = HistoryRecorder(db) if not args.simulacao else None
    if recorder:
        recorder.inicializar_tabela()
    
    try:
        # --- 1. CLASSIFICA√á√ïES ESTAT√çSTICAS ---
        guard.log("Calculando Classifica√ß√µes ABC, XYZ, Tend√™ncias...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        trend_engine = TrendClassifier(db)
        
        df_abc = abc_engine.run()
        df_xyz = xyz_engine.run()
        df_trend = trend_engine.run()
        
        # --- 2. LEITURA DE DADOS ---
        guard.log("Lendo Estoques e Cadastro Completo...")
        with db.get_connection() as conn:
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto,
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
            """).pl()
            
            # Leitura din√¢mica do cadastro
            try:
                cols_db = [c[1] for c in conn.execute("PRAGMA table_info(sqlite_db.produtos_gerais)").fetchall()]
                
                if "descricao_produto" in cols_db:
                    col_desc = "descricao_produto"
                elif "descricao" in cols_db:
                    col_desc = "descricao"
                else:
                    col_desc = "''" 
                
                col_data = "CAST(data_cadastro AS DATE)" if "data_cadastro" in cols_db else "CAST('2000-01-01' AS DATE)"
                col_ref = "ref_fornecedor" if "ref_fornecedor" in cols_db else "''"
                
                df_cadastro = conn.execute(f"""
                    SELECT 
                        CAST(cod_produto AS VARCHAR) as cod_produto,
                        CAST(qtd_economica AS INTEGER) as lote_economico,
                        marca,
                        {col_desc} as descricao,
                        {col_ref} as ref_fornecedor,
                        ativo,
                        {col_data} as data_cadastro
                    FROM sqlite_db.produtos_gerais
                """).pl()
            except Exception as e:
                guard.log(f"Erro ao ler cadastro: {e}. Usando estrutura vazia de seguran√ßa.")
                df_cadastro = pl.DataFrame(schema={
                    "cod_produto": pl.Utf8, "lote_economico": pl.Int64, "marca": pl.Utf8,
                    "descricao": pl.Utf8, "ref_fornecedor": pl.Utf8, "ativo": pl.Utf8,
                    "data_cadastro": pl.Date
                })
        
        # Carrega Sazonalidade
        indices_dict = {}
        try:
            analytics_path = PROJECT_ROOT / "data" / "analytics.duckdb"
            if analytics_path.exists():
                conn.execute(f"ATTACH '{analytics_path}' AS analytics")
                rows = conn.execute("SELECT mes, indice_sazonal FROM analytics.indices_sazonais").fetchall()
                for r in rows:
                    indices_dict[r[0]] = r[1]
        except:
            pass
        
        # --- 3. UNIFICA√á√ÉO (JOIN) ---
        guard.log("Cruzando dados...")
        df_universe = pl.concat([
            df_xyz.select("cod_produto"),
            df_saldo.select("cod_produto"),
            df_cadastro.select("cod_produto")
        ]).unique(subset="cod_produto")
        
        df_final = df_universe \\
            .join(df_xyz, on="cod_produto", how="left") \\
            .join(df_abc, on="cod_produto", how="left") \\
            .join(df_trend, on="cod_produto", how="left") \\
            .join(df_saldo, on="cod_produto", how="left") \\
            .join(df_cadastro, on="cod_produto", how="left")
        
        # Tratamento de descri√ß√£o duplicada
        if "descricao" not in df_final.columns:
            if "descricao_right" in df_final.columns:
                df_final = df_final.rename({"descricao_right": "descricao"})
            else:
                df_final = df_final.with_columns(pl.lit("SEM DESCRI√á√ÉO").alias("descricao"))
        
        # Preenchimento de Nulos
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").fill_null(0.0),
            pl.col("std_venda_dia").fill_null(0.0),
            pl.col("curva_xyz").fill_null("Z"),
            pl.col("dias_sem_venda").fill_null(0).alias("dias_sem_venda"),
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            pl.col("custo_unitario").fill_null(0.0),
            pl.col("curva_abc").fill_null("C"),
            pl.col("marca").fill_null("N/D"),
            pl.col("descricao").fill_null("DESCRI√á√ÉO N√ÉO ENCONTRADA"),
            pl.col("ref_fornecedor").fill_null(""),
            pl.col("lote_economico").fill_null(1),
            pl.col("ativo").fill_null("SIM"),
            pl.col("data_cadastro").fill_null(pl.lit(datetime(2000,1,1))),
            pl.lit(config_mgr.parametros.lead_time.padrao_dias).alias("lead_time_dias"),
        ])
        
        # --- 4. MOTOR DE C√ÅLCULO (COM MELHORIAS) ---
        guard.log("Executando Motor Matem√°tico...")
        
        # MELHORIA 1: Salva m√©dia base ANTES da sazonalidade
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").alias("media_venda_base")
        ])
        
        # Aplica sazonalidade
        df_final = EstoqueMath.aplicar_sazonalidade_projetada(df_final, indices_dict)
        
        # MELHORIA 2: Aplica sazonalidade SEM sobrescrever a base
        df_final = df_final.with_columns([
            pl.col("fator_sazonal_projetado").alias("fator_sazonal"),
            (pl.col("media_venda_base") * pl.col("fator_sazonal_projetado")).alias("media_venda_dia")
        ])
        
        # Continua com os c√°lculos
        df_final = EstoqueMath.calcular_tendencias(df_final)
        df_final = EstoqueMath.calcular_seguranca(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_necessidades(df_final, config_mgr.parametros)
        df_final = EstoqueMath.aplicar_lote_economico(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_score(df_final)
        df_final = EstoqueMath.gerar_diagnostico(df_final, config_mgr.parametros)
        
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") + pl.col("saldo_oc") + pl.col("sugestao_final")).alias("meta_pos_compra")
        ])
        
        # --- 5. FILTRO DE MARCA ---
        if args.marca and args.marca != "TODAS":
            guard.log(f"Filtrando relat√≥rio para marca: {args.marca}")
            df_final = df_final.filter(pl.col("marca") == args.marca)
        
        # --- 6. ESTAT√çSTICAS PARA GUI ---
        try:
            val_estoque_atual = df_final.select((pl.col("saldo_estoque") * pl.col("custo_unitario")).sum()).item()
            val_venda_mensal = df_final.select((pl.col("media_venda_dia") * 30 * pl.col("custo_unitario")).sum()).item()
            
            if val_venda_mensal > 0:
                cobertura = val_estoque_atual / val_venda_mensal
            else:
                cobertura = 0.0
        except:
            val_estoque_atual = 0.0
            cobertura = 0.0
        
        df_compra = df_final.filter(pl.col("sugestao_final") > 0)
        
        stats = {
            "total_valor": df_compra["subtotal"].sum(),
            "total_skus": len(df_compra),
            "total_pecas": df_compra["sugestao_final"].sum(),
            "estoque_atual": val_estoque_atual,
            "cobertura_meses": cobertura
        }
        
        print(f"STATS_DATA={json.dumps(stats)}")
        
        # --- 7. EXPORTA√á√ÉO ---
        if not args.simulacao:
            guard.log("Gerando relat√≥rio Excel...")
            exporter = ExcelExporter(PROJECT_ROOT / "data" / "exports")
            arquivo = exporter.exportar_sugestao(df_final.sort("score", descending=True))
            guard.log(f"Relat√≥rio gerado: {arquivo}")
            
            if recorder:
                recorder.gravar_snapshot(df_final)
        
        guard.log("Processamento conclu√≠do com sucesso!")
        
    except Exception as e:
        guard.log(f"ERRO CR√çTICO: {e}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        db.close()


if __name__ == "__main__":
    main()
'''

print("\n‚úÖ Arquivo gerar_relatorio_final.py melhorado criado!")
print("\nüìã MUDAN√áAS NO FLUXO:")
print("1. ‚úÖ Salva 'media_venda_base' ANTES da sazonalidade")
print("2. ‚úÖ Aplica sazonalidade criando nova coluna ao inv√©s de sobrescrever")
print("3. ‚úÖ Fluxo agora tem auditoria completa de valores intermedi√°rios")

--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/gerar_relatorio_final.py


START FILE: backups/antes_melhorias/excel_exporter.py
--------------------------------------------------------------------------------
codigo_excel = '''"""
Exportador de Excel com formata√ß√£o profissional - VERS√ÉO MELHORADA
Adiciona novas colunas para auditoria
"""
import polars as pl
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)


class ExcelExporter:
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def exportar_sugestao(self, df: pl.DataFrame, filename: str = None):
        if filename is None:
            data_hoje = datetime.now().strftime("%Y%m%d_%H%M")
            filename = f"sugestao_compras_{data_hoje}.xlsx"
        
        filepath = self.output_dir / filename
        logger.info("iniciando_export_excel", path=str(filepath))
        
        # ======== ORDEM DAS COLUNAS (COM NOVAS) ========
        cols_export = [
            "status_diagnostico",
            "cod_produto",
            "descricao",
            "ref_fornecedor",
            "marca",
            "curva_abc",
            "curva_xyz",
            "sugestao_final",
            "sugestao_calculada",  # NOVA: Antes do bloqueio
            "calculado_mas_bloqueado",  # NOVA: Flag
            "motivo_bloqueio",  # NOVA: Raz√£o do bloqueio
            "meta_pos_compra",
            "fator_sazonal",
            "lote_economico",
            "subtotal",
            "saldo_estoque",
            "saldo_oc",
            "cobertura_virtual_meses",
            "media_venda_base",  # NOVA: Sem sazonalidade
            "media_venda_dia",  # Ajustada
            "tendencia_vendas",
            "tendencia_clientes",
            "perfil_cliente",
            "validacao_giro",
            "custo_unitario",
            "score"
        ]
        
        cols_presentes = [c for c in cols_export if c in df.columns]
        records = df.select(cols_presentes).to_dicts()
        
        # ======== CRIA√á√ÉO DO EXCEL ========
        wb = Workbook()
        ws = wb.active
        ws.title = "Analise Compras"
        
        # Estilos
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        center_align = Alignment(horizontal="center")
        left_align = Alignment(horizontal="left")
        thin_border = Border(
            left=Side(style="thin"), right=Side(style="thin"),
            top=Side(style="thin"), bottom=Side(style="thin")
        )
        
        fill_green = PatternFill(start_color="CCFFCC", fill_type="solid")
        fill_yellow = PatternFill(start_color="FFFFE0", fill_type="solid")
        fill_orange = PatternFill(start_color="FFD700", fill_type="solid")
        fill_blue_light = PatternFill(start_color="E6F3FF", fill_type="solid")
        fill_implanta = PatternFill(start_color="E0FFFF", fill_type="solid")
        fill_red = PatternFill(start_color="FFB6C1", fill_type="solid")  # NOVA: Para bloqueados
        
        # Mapeamento de nomes amig√°veis
        mapa_nomes = {
            "META_POS_COMPRA": "POSI√á√ÉO FINAL",
            "FATOR_SAZONAL": "IDX SAZONAL",
            "MEDIA_VENDA_DIA": "GIRO DIA (AJUST)",
            "MEDIA_VENDA_BASE": "GIRO DIA (BASE)",  # NOVO
            "COBERTURA_VIRTUAL_MESES": "COBERTURA MESES",
            "REF_FORNECEDOR": "REF. FABRICA",
            "SUGESTAO_CALCULADA": "CALC. ORIGINAL",  # NOVO
            "CALCULADO_MAS_BLOQUEADO": "BLOQUEADO?",  # NOVO
            "MOTIVO_BLOQUEIO": "MOTIVO"  # NOVO
        }
        
        headers = [c.replace("_", " ").upper() for c in cols_presentes]
        headers = [mapa_nomes.get(h, h) for h in headers]
        
        ws.append(headers)
        
        # Formata cabe√ßalho
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_align
        
        # Preenche dados
        for row_idx, row_data in enumerate(records, 2):
            for col_idx, col_name in enumerate(cols_presentes, 1):
                val = row_data[col_name]
                cell = ws.cell(row=row_idx, column=col_idx, value=val)
                cell.border = thin_border
                
                # Alinhamento
                if col_name == "descricao":
                    cell.alignment = left_align
                else:
                    cell.alignment = center_align
                
                # Formata√ß√£o num√©rica
                if col_name in ["custo_unitario", "subtotal"]:
                    cell.number_format = 'R$ #,##0.00'
                elif col_name in ["media_venda_dia", "media_venda_base", "fator_sazonal"]:
                    cell.number_format = '0.00'
                elif col_name in ["cobertura_virtual_meses"]:
                    cell.number_format = '0.0'
                elif col_name == "score":
                    cell.number_format = '#,##0'
                
                # ======== FORMATA√á√ÉO CONDICIONAL ========
                
                # Sugest√µes de compra
                if col_name in ["sugestao_final", "subtotal"] and row_data.get("sugestao_final", 0) > 0:
                    cell.font = Font(bold=True, color="006400")
                    cell.fill = fill_green
                
                # NOVA: Destaque para produtos bloqueados
                if col_name == "calculado_mas_bloqueado" and val == "SIM":
                    cell.fill = fill_red
                    cell.font = Font(bold=True, color="8B0000")
                
                # NOVA: Motivo do bloqueio em vermelho
                if col_name == "motivo_bloqueio" and val:
                    cell.font = Font(color="DC143C", italic=True)
                
                # Fator sazonal
                if col_name == "fator_sazonal":
                    if isinstance(val, (int, float)):
                        if val < 0.90:
                            cell.font = Font(color="0000FF")
                            cell.fill = fill_blue_light
                        elif val > 1.10:
                            cell.font = Font(color="B22222", bold=True)
                
                # Status diagn√≥stico
                if col_name == "status_diagnostico":
                    val_str = str(val).upper()
                    if "IMPLANTA√á√ÉO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "RUPTURA" in val_str:
                        cell.fill = PatternFill(start_color="FF0000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "BLOQUEADO" in val_str:
                        cell.fill = PatternFill(start_color="808080", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "INATIVO" in val_str:
                        cell.fill = PatternFill(start_color="000000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "ALERTA" in val_str:
                        cell.fill = PatternFill(start_color="FF8C00", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "EXCESSO" in val_str:
                        cell.fill = fill_yellow
                    elif "COMPRAR" in val_str:
                        cell.fill = fill_green
                
                # Tend√™ncia vendas
                if col_name == "tendencia_vendas":
                    val_str = str(val).upper()
                    if "ALTA" in val_str:
                        cell.font = Font(color="006400", bold=True)
                    elif "QUEDA" in val_str:
                        cell.font = Font(color="FF0000", bold=True)
                
                # Valida√ß√£o de giro
                if col_name == "validacao_giro":
                    val_str = str(val)
                    if "ITEM NOVO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "SEM MOVIMENTO" in val_str:
                        cell.font = Font(color="808080", italic=True)
                    elif "Excesso" in val_str:
                        cell.font = Font(bold=True, color="B22222")
                        cell.fill = fill_orange
        
        # Auto-ajuste de largura
        for col_idx, column_cells in enumerate(ws.columns, 1):
            max_length = 0
            column = get_column_letter(col_idx)
            limit = 60 if cols_presentes[col_idx-1] == "descricao" else 40
            
            for cell in column_cells:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            ws.column_dimensions[column].width = min(max_length + 3, limit)
        
        wb.save(filepath)
        logger.info("export_excel_concluido")
        return filepath
'''

print("\n‚úÖ Arquivo excel_exporter.py melhorado criado!")
print("\nüìã NOVAS COLUNAS NO EXCEL:")
print("1. ‚úÖ MEDIA_VENDA_BASE (GIRO DIA BASE) - Sem ajuste sazonal")
print("2. ‚úÖ SUGESTAO_CALCULADA - Valor antes do bloqueio")
print("3. ‚úÖ CALCULADO_MAS_BLOQUEADO - Flag SIM/N√ÉO")
print("4. ‚úÖ MOTIVO_BLOQUEIO - Raz√£o espec√≠fica do bloqueio")
print("5. ‚úÖ Formata√ß√£o condicional para produtos bloqueados (vermelho)")
--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/excel_exporter.py


START FILE: backups/antes_melhorias/estoque_math.py
--------------------------------------------------------------------------------
# Vou criar o arquivo estoque_math.py melhorado

codigo_estoque_math = '''"""
M√≥dulo de c√°lculos matem√°ticos de estoque - VERS√ÉO MELHORADA
Implementa l√≥gica de reposi√ß√£o com valida√ß√µes aprimoradas
"""
import polars as pl
import numpy as np
from datetime import datetime


class EstoqueMath:
    """Classe com m√©todos est√°ticos para c√°lculos de estoque"""
    
    @staticmethod
    def aplicar_sazonalidade_projetada(df: pl.DataFrame, indices_dict: dict) -> pl.DataFrame:
        """
        Calcula o fator sazonal baseando-se na DATA DE CHEGADA da mercadoria.
        MELHORIA: Preserva media_venda_base antes de aplicar sazonalidade
        """
        if not indices_dict or len(indices_dict) != 12:
            return df.with_columns(pl.lit(1.0).alias("fator_sazonal_projetado"))
        
        lista_indices = [indices_dict.get(m, 1.0) for m in range(1, 13)]
        mes_atual = datetime.now().month
        
        def calcular_fator_futuro(leadtime):
            if leadtime is None:
                leadtime = 7
            
            meses_espera = leadtime / 30.0
            duracao_estoque = 1.5
            soma_indices = 0.0
            pontos_verificados = 0
            cursor = meses_espera
            fim_janela = meses_espera + duracao_estoque
            
            while cursor < fim_janela:
                mes_futuro_absoluto = mes_atual + int(cursor)
                index_lista = (mes_futuro_absoluto - 1) % 12
                soma_indices += lista_indices[index_lista]
                pontos_verificados += 1
                cursor += 0.5
            
            if pontos_verificados == 0:
                return 1.0
            
            fator = soma_indices / pontos_verificados
            return max(0.5, min(fator, 2.5))
        
        return df.with_columns([
            pl.col("lead_time_dias").map_elements(
                calcular_fator_futuro, return_dtype=pl.Float64
            ).alias("fator_sazonal_projetado")
        ])

    @staticmethod
    def calcular_tendencias(df: pl.DataFrame) -> pl.DataFrame:
        """
        Calcula as classifica√ß√µes de Tend√™ncia e Perfil de Cliente.
        Trata valores nulos como zero para evitar erro de classifica√ß√£o.
        """
        if "var_vendas" not in df.columns:
            df = df.with_columns([
                pl.lit(0.0).alias("var_vendas"),
                pl.lit(0).alias("saldo_clientes"),
                pl.lit(0).alias("qtd_clientes_ativos")
            ])
        
        return df.with_columns([
            # 1. TEND√äNCIA VENDAS
            pl.when(pl.col("var_vendas").fill_null(0.0) > 0.20).then(pl.lit("EM ALTA"))
            .when(pl.col("var_vendas").fill_null(0.0) < -0.20).then(pl.lit("EM QUEDA"))
            .otherwise(pl.lit("EST√ÅVEL")).alias("tendencia_vendas"),
            
            # 2. TEND√äNCIA CLIENTES
            pl.when(pl.col("saldo_clientes").fill_null(0) > 0)
            .then(pl.format("GANHO +{}", pl.col("saldo_clientes")))
            .when(pl.col("saldo_clientes").fill_null(0) < 0)
            .then(pl.format("PERDA {}", pl.col("saldo_clientes")))
            .otherwise(pl.lit("MANTEVE")).alias("tendencia_clientes"),
            
            # 3. PERFIL CLIENTE
            pl.when(pl.col("qtd_clientes_ativos").fill_null(0) == 0).then(pl.lit("Sem Venda"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 2).then(pl.lit("Dedicado (1-2)"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 9).then(pl.lit("Concentrado (3-9)"))
            .otherwise(pl.lit("Pulverizado (10+)")).alias("perfil_cliente")
        ])

    @staticmethod
    def calcular_seguranca(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Estoque de Seguran com proteo contra Lead Time Nulo."""
        def get_z_factor(xyz):
            if xyz == "X":
                return 1.65
            if xyz == "Y":
                return 1.28
            return 0.84
        
        return df.with_columns([
            pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64).alias("fator_z"),
            (
                pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64) *
                pl.col("std_venda_dia") *
                pl.col("lead_time_dias").fill_null(7).sqrt()
            ).fill_null(0).alias("estoque_seguranca")
        ])

    @staticmethod
    def calcular_necessidades(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Calcula Ponto de Suprimento e Estoque Meta
        MELHORIA: Valida dias_vida ANTES de aplicar boost anti-ruptura
        """
        meses_cobertura = config.compras.meses_cobertura
        dias_novo = config.produto.dias_lancamento  # Normalmente 60
        
        # MELHORIA 1: Calcula dias_vida ANTES do boost
        df = df.with_columns([
            (pl.lit(datetime.now()) - pl.col("data_cadastro").dt.total_days()).alias("dias_vida")
        ])
        
        # MELHORIA 2: Boost anti-ruptura apenas para itens VELHOS
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                pl.col("curva_abc").is_in(["A", "B"]) &
                (pl.col("dias_vida") > dias_novo)  # <-- NOVA CONDI√á√ÉO
            )
            .then(
                pl.when(pl.col("dias_sem_venda") > 30).then(pl.col("media_venda_dia") * 1.20)
                .when(pl.col("dias_sem_venda") > 90).then(pl.col("media_venda_dia") * 1.50)
                .otherwise(pl.col("media_venda_dia") * 2.00)
            )
            .otherwise(pl.col("media_venda_dia"))
            .alias("media_calculo")
        ])
        
        return df.with_columns([
            (pl.col("media_calculo") * pl.col("lead_time_dias") + pl.col("estoque_seguranca")).round(0).alias("ponto_suprimento"),
            (pl.col("media_calculo") * 30 * meses_cobertura + pl.col("estoque_seguranca")).round(0).alias("estoque_meta")
        ]).with_columns([
            (pl.col("estoque_meta") - pl.col("saldo_estoque") - pl.col("saldo_oc")).alias("sugestao_bruta")
        ])

    @staticmethod
    def aplicar_lote_economico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Arredonda para lotes econ√¥micos"""
        return df.with_columns([
            pl.when(pl.col("sugestao_bruta") <= 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("necessidade_liquida")
        ]).with_columns([
            (pl.col("necessidade_liquida") / pl.col("lote_economico")).ceil().alias("lotes_cheios")
        ]).with_columns([
            (pl.col("lotes_cheios") * pl.col("lote_economico")).cast(pl.Int32).alias("sugestao_final")
        ]).with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal")
        ])

    @staticmethod
    def calcular_score(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula pontua√ß√£o inicial de prioridade"""
        return df.with_columns([
            (
                pl.when(pl.col("saldo_estoque") == 0).then(5000).otherwise(0) +
                pl.when(pl.col("saldo_estoque") < pl.col("media_venda_dia") * pl.col("lead_time_dias")).then(2500).otherwise(0) +
                pl.when(pl.col("curva_abc") == "A").then(1000).when(pl.col("curva_abc") == "B").then(500).otherwise(100) +
                pl.when(pl.col("tendencia_vendas") == "EM ALTA").then(500).otherwise(0) +
                (pl.col("media_venda_dia") * pl.col("custo_unitario")).fill_null(0)
            ).round(0).cast(pl.Int32).alias("score")
        ])

    @staticmethod
    def gerar_diagnostico(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Gera diagn√≥sticos e aplica a l√≥gica de ITEM NOVO (Implanta√ß√£o)
        MELHORIAS:
        - Adiciona motivo_bloqueio
        - Adiciona calculado_mas_bloqueado
        - Recalcula score ap√≥s bloqueios
        """
        estoque_total = pl.col("saldo_estoque") + pl.col("saldo_oc")
        venda_mensal = pl.col("media_venda_dia") * 30
        dias_novo = config.produto.dias_lancamento
        
        # Calcula dias_vida se ainda n√£o existir
        if "dias_vida" not in df.columns:
            df = df.with_columns([
                (pl.lit(datetime.now()) - pl.col("data_cadastro").dt.total_days()).alias("dias_vida")
            ])
        
        # C√°lculo de Cobertura
        base_calc = pl.when(estoque_total == 0).then(0.0).otherwise(estoque_total / venda_mensal)
        calc_cobertura = pl.when(base_calc.is_infinite()).then(99.0).otherwise(base_calc).fill_nan(99.0)
        
        df = df.with_columns([calc_cobertura.alias("cobertura_virtual_meses")])
        
        # 1. VALIDA√á√ÉO DE GIRO (O Juiz)
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                (pl.col("saldo_oc") == 0) &
                (pl.col("media_venda_dia") == 0)
            )
            .then(
                pl.when(pl.col("dias_vida") <= dias_novo)
                .then(pl.lit("SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)"))
                .otherwise(pl.lit("SEM MOVIMENTO (Item velho parado)"))
            )
            .when(pl.col("cobertura_virtual_meses") > 6).then(pl.lit("ALERTA: Excesso > 6m"))
            .when((pl.col("media_venda_dia") < 0.05) & (pl.col("sugestao_final") > 0)).then(pl.lit("ALERTA: Sem Venda Recente"))
            .otherwise(pl.lit("COERENTE")).alias("validacao_giro")
        ])
        
        # MELHORIA: Salva sugest√£o original antes do bloqueio
        df = df.with_columns([
            pl.col("sugestao_final").alias("sugestao_calculada")
        ])
        
        # 2. APLICA BLOQUEIOS E DEFINE MOTIVO
        df = df.with_columns([
            # Define motivo do bloqueio
            pl.when(pl.col("ativo") == "NO").then(pl.lit("Produto inativo no cadastro"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.col("validacao_giro"))
            .otherwise(pl.lit("")).alias("motivo_bloqueio"),
            
            # Flag: Foi calculado mas bloqueado?
            pl.when(
                (pl.col("sugestao_final") > 0) &
                ((pl.col("ativo") == "NO") | pl.col("validacao_giro").str.contains("ALERTA"))
            ).then(pl.lit("SIM")).otherwise(pl.lit("N√ÉO")).alias("calculado_mas_bloqueado"),
            
            # Aplica bloqueio na sugest√£o
            pl.when(pl.col("ativo") == "NO").then(0)
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)")
            .then(pl.col("lote_economico"))  # Item novo = 1 lote
            .otherwise(pl.col("sugestao_final")).alias("sugestao_final")
        ])
        
        # MELHORIA 3: RECALCULA SCORE AP√ìS BLOQUEIOS
        df = df.with_columns([
            pl.when(pl.col("sugestao_final") == 0).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)").then(pl.lit(9999))
            .otherwise(pl.col("score")).alias("score")
        ])
        
        # 4. STATUS DIAGN√ìSTICO FINAL
        df = df.with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal"),
            
            pl.when(pl.col("ativo") == "NO").then(pl.lit("INATIVO"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.lit("BLOQUEADO"))
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (Implanta√ß√£o)").then(pl.lit("IMPLANTA√á√ÉO"))
            .when(pl.col("saldo_estoque") == 0).then(pl.lit("RUPTURA"))
            .when(pl.col("sugestao_final") > 0).then(pl.lit("COMPRAR"))
            .when(pl.col("cobertura_virtual_meses") > 12).then(pl.lit("EXCESSO"))
            .otherwise(pl.lit("OK")).alias("status_diagnostico")
        ])
        
        return df
'''

print("‚úÖ Arquivo estoque_math.py melhorado criado!")
print("\nüìã MELHORIAS IMPLEMENTADAS:")
print("1. ‚úÖ media_venda_base preservada (n√£o sobrescrita pela sazonalidade)")
print("2. ‚úÖ Valida√ß√£o dias_vida ANTES do boost anti-ruptura")
print("3. ‚úÖ Coluna 'motivo_bloqueio' adicionada")
print("4. ‚úÖ Coluna 'calculado_mas_bloqueado' adicionada")
print("5. ‚úÖ Score recalculado ap√≥s bloqueios")
print("6. ‚úÖ Coluna 'sugestao_calculada' salva antes dos bloqueios")

--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/estoque_math.py


START FILE: config/parametros.yaml
--------------------------------------------------------------------------------
abc:
  A: 0.8
  B: 0.95
compras:
  meses_cobertura: 1.5
giro:
  limite_meses_cobertura: 6
historico:
  meses_analise: 36
  meses_tendencia: 6
lead_time:
  desvio_padrao: 2.0
  padrao_dias: 10
lote:
  limite_virada: 0.5
  minima_absoluta: 1
outlier:
  fator_multiplicador: 2.0
produto:
  dias_lancamento: 180
  dias_sem_entrada_obsoleto: 365
  dias_sem_venda_obsoleto: 180
risco:
  clientes_dependencia_alerta_A: 5
  clientes_dependencia_alerta_B: 2
  clientes_dependencia_total_A: 2
  valor_alto_item_C: 1000.0
ruptura:
  boost_demanda_curva_AB: 1.2
sazonalidade:
  ativada: true
  fator_maximo: 2.5
  fator_minimo: 0.5
tolerancia_abc:
  A: 0.3
  B: 0.2
  C: 0.1
xyz:
  X:
    threshold: 0.5
    z_score: 1.65
  Y:
    threshold: 1.0
    z_score: 1.28
  Z:
    threshold: 999.0
    z_score: 0.84

--------------------------------------------------------------------------------
END FILE: config/parametros.yaml


