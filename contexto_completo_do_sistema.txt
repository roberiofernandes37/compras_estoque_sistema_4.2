================================================================================
PROJETO: COMPRAS-ESTOQUE-SISTEMA
DATA GERACAO: compras-estoque-sistema
================================================================================

ESTRUTURA DE DIRETÃ“RIOS:
----------------------------------------
â”œâ”€â”€ .pytest_cache
â”‚   â”œâ”€â”€ v
â”‚   â”‚   â””â”€â”€ cache
â”‚   â”‚       â”œâ”€â”€ lastfailed
â”‚   â”‚       â””â”€â”€ nodeids
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ CACHEDIR.TAG
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ _backup_pre_refaturacao
â”œâ”€â”€ backups
â”‚   â””â”€â”€ antes_melhorias
â”‚       â”œâ”€â”€ estoque_math.py
â”‚       â”œâ”€â”€ excel_exporter.py
â”‚       â””â”€â”€ gerar_relatorio_final.py
â”œâ”€â”€ config
â”‚   â””â”€â”€ parametros.yaml
â”œâ”€â”€ docs
â”œâ”€â”€ scripts
â”‚   â”œâ”€â”€ auditor_item.py
â”‚   â”œâ”€â”€ auditor_real.py
â”‚   â”œâ”€â”€ auditoria_automatica.py
â”‚   â”œâ”€â”€ calcular_sazonalidade.py
â”‚   â”œâ”€â”€ debug_item.py
â”‚   â”œâ”€â”€ export_project_context.py
â”‚   â”œâ”€â”€ fix_toml.py
â”‚   â”œâ”€â”€ gerar_relatorio_final.py
â”‚   â”œâ”€â”€ inspect_db.py
â”‚   â”œâ”€â”€ setup_database.py
â”‚   â”œâ”€â”€ testar_analytics.py
â”‚   â””â”€â”€ verificar_ambiente.py
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ compras_sistema
â”‚   â”‚   â”œâ”€â”€ cache
â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”‚   â”œâ”€â”€ reporter.py
â”‚   â”‚   â”‚   â””â”€â”€ system_guard.py
â”‚   â”‚   â”œâ”€â”€ data_engine
â”‚   â”‚   â”‚   â”œâ”€â”€ queries
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ abc_financeiro.sql
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ estatisticas_vendas.sql
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics_service.py
â”‚   â”‚   â”‚   â”œâ”€â”€ duckdb_manager.py
â”‚   â”‚   â”‚   â””â”€â”€ history_recorder.py
â”‚   â”‚   â”œâ”€â”€ export
â”‚   â”‚   â”‚   â”œâ”€â”€ templates
â”‚   â”‚   â”‚   â””â”€â”€ excel_exporter.py
â”‚   â”‚   â”œâ”€â”€ pipeline
â”‚   â”‚   â”œâ”€â”€ rule_engine
â”‚   â”‚   â”‚   â”œâ”€â”€ analysis
â”‚   â”‚   â”‚   â”œâ”€â”€ classification
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ abc_classifier.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ trend_classifier.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ xyz_classifier.py
â”‚   â”‚   â”‚   â”œâ”€â”€ purchase
â”‚   â”‚   â”‚   â”œâ”€â”€ risk
â”‚   â”‚   â”‚   â”œâ”€â”€ scoring
â”‚   â”‚   â”‚   â”œâ”€â”€ stock
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ estoque_math.py
â”‚   â”‚   â”‚   â”œâ”€â”€ validators
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ input_schema.py
â”‚   â”‚   â”‚   â””â”€â”€ base_rule.py
â”‚   â”‚   â”œâ”€â”€ ui
â”‚   â”‚   â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”‚   â”œâ”€â”€ screens
â”‚   â”‚   â”‚   â””â”€â”€ themes
â”‚   â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”‚   â”œâ”€â”€ logging
â”‚   â”‚   â”‚   â”œâ”€â”€ performance
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ sanitizer.py
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â””â”€â”€ ui
â”‚       â””â”€â”€ components
â”‚           â”œâ”€â”€ dashboard.py
â”‚           â””â”€â”€ sidebar.py
â”œâ”€â”€ tests
â”‚   â”œâ”€â”€ fixtures
â”‚   â”œâ”€â”€ integration
â”‚   â”‚   â””â”€â”€ test_classifiers.py
â”‚   â”œâ”€â”€ unit
â”‚   â”‚   â”œâ”€â”€ test_correcoes_estoque.py
â”‚   â”‚   â”œâ”€â”€ test_estoque_math.py
â”‚   â”‚   â””â”€â”€ test_validator.py
â”‚   â””â”€â”€ conftest.py
â”œâ”€â”€ tests_refactor
â”‚   â”œâ”€â”€ test_01_blindagem_entrada.py
â”‚   â”œâ”€â”€ test_02_estoque_math.py
â”‚   â”œâ”€â”€ test_03_diagnostico.py
â”‚   â””â”€â”€ test_04_abc.py
â”œâ”€â”€ auditor_item_completo.py
â”œâ”€â”€ conftest.py
â”œâ”€â”€ contexto_completo_do_sistema_sem_dashboard_16122025_ok.txt
â”œâ”€â”€ export_full_project.py
â”œâ”€â”€ launcher_gui.py
â”œâ”€â”€ launcher_guiantesdaatualizacaodashboard16122025.py
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ pytest.ini
â”œâ”€â”€ rodar.sh
â”œâ”€â”€ rodar.sh.save
â””â”€â”€ verificar_ambiente.py

================================================================================

START FILE: launcher_guiantesdaatualizacaodashboard16122025.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURAÃ‡ÃƒO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # ConfiguraÃ§Ã£o da Janela
        self.title("NewCompras v6.5 - Central de InteligÃªncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINIÃ‡ÃƒO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARIÃVEIS DE CONTROLE ---
        # ParÃ¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em memÃ³ria

        # KPIs - SugestÃ£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRUÃ‡ÃƒO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | ConteÃºdo DinÃ¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZAÃ‡ÃƒO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para nÃ£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURAÃ‡Ã•ES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / TÃ­tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de ReposiÃ§Ã£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PARÃ‚METROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time PadrÃ£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINIÃ‡ÃƒO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # EspaÃ§ador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # BotÃµes de ManutenÃ§Ã£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="ğŸ”„ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="ğŸ’¾ Salvar ConfiguraÃ§Ã£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. ÃREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("ğŸ“Š PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("ğŸ“ LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """ConstrÃ³i a interface visual de decisÃ£o"""
        
        # --- BLOCO 1: SELEÃ‡ÃƒO DE MARCA (Cacheado e RÃ¡pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="ğŸ” Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de BotÃµes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: AÃ‡Ã•ES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="ğŸ“¥ GERAR RELATÃ“RIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # ComeÃ§a desativado por seguranÃ§a
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRATÃ‰GICO DA ANÃLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PEÃ‡AS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. LÃ“GICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser rÃ¡pido. Se falhar, lÃª do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("ğŸ“‚ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"âœ… {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"âš ï¸ Cache corrompido, recriando... ({e})")
        
        # Se nÃ£o tem cache ou deu erro, forÃ§a leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """LÃª do DuckDB (Lento) e salva no JSON"""
        self.log_msg("â³ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("âŒ Banco de dados nÃ£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas Ãºnicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"âœ… IndexaÃ§Ã£o concluÃ­da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"âŒ Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de botÃµes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # LÃ³gica visual de seleÃ§Ã£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem estÃ¡ selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECUÃ‡ÃƒO DO MOTOR DE CÃLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for cÃ¡lculo real (gerar Excel), foca na aba de Log para o usuÃ¡rio ver o progresso
        if not simulacao:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
        
        # Trava botÃµes
        self.btn_simular.configure(state="disabled", text="â³ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
            try:
                marca = self.var_marca.get()
                
                # --- CORREÃ‡ÃƒO DE AMBIENTE VIRTUAL ---
                # Define qual Python usar. Tenta achar o do .venv automaticamente.
                python_exec = sys.executable # PadrÃ£o (caso jÃ¡ esteja ativado)
                
                # Caminhos comuns de ambiente virtual no Linux
                possivel_venv = self.root_dir / ".venv" / "bin" / "python"
                possivel_venv_simples = self.root_dir / "venv" / "bin" / "python"
                
                # Se acharmos o Python do ambiente virtual, usamos ele forÃ§adamente
                if possivel_venv.exists():
                    python_exec = str(possivel_venv)
                elif possivel_venv_simples.exists():
                    python_exec = str(possivel_venv_simples)
                # ------------------------------------

                cmd = [python_exec, str(self.script_path), "--marca", marca]
                if simulacao:
                    cmd.append("--simulacao")

                self.log_msg(f"ğŸš€ Iniciando motor de cÃ¡lculo para: {marca}")
                self.log_msg(f"ğŸ Usando Python em: {python_exec}") # Debug para garantir
                
                # Executa o script Python como subprocesso
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    encoding='utf-8', 
                    errors='replace'
                )

                # LÃª a saÃ­da em tempo real
                for line in process.stdout:
                    line_clean = line.strip()
                    
                    # Intercepta o JSON de estatÃ­sticas para atualizar o Dashboard
                    if "STATS_DATA=" in line_clean:
                        try:
                            json_str = line_clean.replace("STATS_DATA=", "")
                            data = json.loads(json_str)
                            self.after(0, lambda d=data: self.atualizar_kpis(d))
                        except Exception as e:
                            self.log_msg(f"âš ï¸ Erro ao ler KPIs: {e}")
                    elif "--- LOG START ---" not in line_clean:
                        self.after(0, self.log_msg, line_clean)

                process.wait()
                
                # Verifica erros
                stderr = process.stderr.read()
                if stderr:
                    self.after(0, self.log_msg, f"ğŸ”´ ERRO INTERNO:\n{stderr}")

                self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

            except Exception as e:
                self.after(0, self.log_msg, f"âŒ ERRO CRÃTICO: {e}")
                self.after(0, lambda: self.finalizar_processo(simulacao, 1))
            
    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura botÃµes
        self.btn_simular.configure(state="normal", text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exportaÃ§Ã£o
                self.log_msg("âœ… SimulaÃ§Ã£o concluÃ­da com sucesso.")
                # Volta para o dashboard para ver os nÃºmeros
                self.tabs.set("ğŸ“Š PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "CÃ¡lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("âœ… RelatÃ³rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURAÃ‡ÃƒO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("ConfiguraÃ§Ã£o", "ParÃ¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_guiantesdaatualizacaodashboard16122025.py


START FILE: contexto_completo_do_sistema_sem_dashboard_16122025_ok.txt
--------------------------------------------------------------------------------
================================================================================
PROJETO: COMPRAS-ESTOQUE-SISTEMA
DATA GERACAO: compras-estoque-sistema
================================================================================

ESTRUTURA DE DIRETÃ“RIOS:
----------------------------------------
â”œâ”€â”€ .pytest_cache
â”‚   â”œâ”€â”€ v
â”‚   â”‚   â””â”€â”€ cache
â”‚   â”‚       â”œâ”€â”€ lastfailed
â”‚   â”‚       â””â”€â”€ nodeids
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ CACHEDIR.TAG
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ backups
â”‚   â””â”€â”€ antes_melhorias
â”‚       â”œâ”€â”€ estoque_math.py
â”‚       â”œâ”€â”€ excel_exporter.py
â”‚       â””â”€â”€ gerar_relatorio_final.py
â”œâ”€â”€ config
â”‚   â””â”€â”€ parametros.yaml
â”œâ”€â”€ docs
â”œâ”€â”€ scripts
â”‚   â”œâ”€â”€ auditor_item.py
â”‚   â”œâ”€â”€ calcular_sazonalidade.py
â”‚   â”œâ”€â”€ debug_item.py
â”‚   â”œâ”€â”€ export_project_context.py
â”‚   â”œâ”€â”€ fix_toml.py
â”‚   â”œâ”€â”€ gerar_relatorio_final.py
â”‚   â”œâ”€â”€ inspect_db.py
â”‚   â”œâ”€â”€ setup_database.py
â”‚   â”œâ”€â”€ test_abc.py
â”‚   â”œâ”€â”€ test_calculo_estoque.py
â”‚   â”œâ”€â”€ test_xyz.py
â”‚   â”œâ”€â”€ testar_analytics.py
â”‚   â”œâ”€â”€ teste_giro.py
â”‚   â”œâ”€â”€ teste_matematica.py
â”‚   â”œâ”€â”€ teste_score.py
â”‚   â””â”€â”€ verificar_ambiente.py
â”œâ”€â”€ src
â”‚   â””â”€â”€ compras_sistema
â”‚       â”œâ”€â”€ cache
â”‚       â”œâ”€â”€ core
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ config.py
â”‚       â”‚   â””â”€â”€ system_guard.py
â”‚       â”œâ”€â”€ data_engine
â”‚       â”‚   â”œâ”€â”€ queries
â”‚       â”‚   â”‚   â”œâ”€â”€ abc_financeiro.sql
â”‚       â”‚   â”‚   â””â”€â”€ estatisticas_vendas.sql
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ analytics_service.py
â”‚       â”‚   â”œâ”€â”€ analytics_service.py.backup2
â”‚       â”‚   â”œâ”€â”€ duckdb_manager.py
â”‚       â”‚   â””â”€â”€ history_recorder.py
â”‚       â”œâ”€â”€ export
â”‚       â”‚   â”œâ”€â”€ templates
â”‚       â”‚   â””â”€â”€ excel_exporter.py
â”‚       â”œâ”€â”€ pipeline
â”‚       â”œâ”€â”€ rule_engine
â”‚       â”‚   â”œâ”€â”€ analysis
â”‚       â”‚   â”œâ”€â”€ classification
â”‚       â”‚   â”‚   â”œâ”€â”€ abc_classifier.py
â”‚       â”‚   â”‚   â”œâ”€â”€ trend_classifier.py
â”‚       â”‚   â”‚   â””â”€â”€ xyz_classifier.py
â”‚       â”‚   â”œâ”€â”€ purchase
â”‚       â”‚   â”œâ”€â”€ risk
â”‚       â”‚   â”œâ”€â”€ scoring
â”‚       â”‚   â”œâ”€â”€ stock
â”‚       â”‚   â”‚   â””â”€â”€ estoque_math.py
â”‚       â”‚   â”œâ”€â”€ validators
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â””â”€â”€ input_schema.py
â”‚       â”‚   â””â”€â”€ base_rule.py
â”‚       â”œâ”€â”€ ui
â”‚       â”‚   â”œâ”€â”€ components
â”‚       â”‚   â”œâ”€â”€ screens
â”‚       â”‚   â””â”€â”€ themes
â”‚       â”œâ”€â”€ utils
â”‚       â”‚   â”œâ”€â”€ logging
â”‚       â”‚   â””â”€â”€ performance
â”‚       â””â”€â”€ __init__.py
â”œâ”€â”€ tests
â”‚   â”œâ”€â”€ fixtures
â”‚   â”œâ”€â”€ integration
â”‚   â”‚   â””â”€â”€ test_classifiers.py
â”‚   â”œâ”€â”€ unit
â”‚   â”‚   â”œâ”€â”€ test_estoque_math.py
â”‚   â”‚   â””â”€â”€ test_validator.py
â”‚   â””â”€â”€ conftest.py
â”œâ”€â”€ excel_exporter.py.backup
â”œâ”€â”€ export_full_project.py
â”œâ”€â”€ gerar_relatorio_final.py.backup
â”œâ”€â”€ launcher_gui.py
â”œâ”€â”€ launcher_gui_gemini.py
â”œâ”€â”€ launcher_guiantesdaatualizacaodashboard16122025.py
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ rodar.sh
â”œâ”€â”€ rodar.sh.save
â””â”€â”€ verificar_ambiente.py

================================================================================

START FILE: launcher_guiantesdaatualizacaodashboard16122025.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURAÃ‡ÃƒO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # ConfiguraÃ§Ã£o da Janela
        self.title("NewCompras v6.5 - Central de InteligÃªncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINIÃ‡ÃƒO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARIÃVEIS DE CONTROLE ---
        # ParÃ¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em memÃ³ria

        # KPIs - SugestÃ£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRUÃ‡ÃƒO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | ConteÃºdo DinÃ¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZAÃ‡ÃƒO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para nÃ£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURAÃ‡Ã•ES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / TÃ­tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de ReposiÃ§Ã£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PARÃ‚METROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time PadrÃ£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINIÃ‡ÃƒO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # EspaÃ§ador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # BotÃµes de ManutenÃ§Ã£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="ğŸ”„ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="ğŸ’¾ Salvar ConfiguraÃ§Ã£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. ÃREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("ğŸ“Š PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("ğŸ“ LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """ConstrÃ³i a interface visual de decisÃ£o"""
        
        # --- BLOCO 1: SELEÃ‡ÃƒO DE MARCA (Cacheado e RÃ¡pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="ğŸ” Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de BotÃµes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: AÃ‡Ã•ES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="ğŸ“¥ GERAR RELATÃ“RIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # ComeÃ§a desativado por seguranÃ§a
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRATÃ‰GICO DA ANÃLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PEÃ‡AS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. LÃ“GICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser rÃ¡pido. Se falhar, lÃª do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("ğŸ“‚ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"âœ… {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"âš ï¸ Cache corrompido, recriando... ({e})")
        
        # Se nÃ£o tem cache ou deu erro, forÃ§a leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """LÃª do DuckDB (Lento) e salva no JSON"""
        self.log_msg("â³ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("âŒ Banco de dados nÃ£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas Ãºnicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"âœ… IndexaÃ§Ã£o concluÃ­da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"âŒ Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de botÃµes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # LÃ³gica visual de seleÃ§Ã£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem estÃ¡ selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECUÃ‡ÃƒO DO MOTOR DE CÃLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for cÃ¡lculo real (gerar Excel), foca na aba de Log para o usuÃ¡rio ver o progresso
        if not simulacao:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
        
        # Trava botÃµes
        self.btn_simular.configure(state="disabled", text="â³ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
            try:
                marca = self.var_marca.get()
                
                # --- CORREÃ‡ÃƒO DE AMBIENTE VIRTUAL ---
                # Define qual Python usar. Tenta achar o do .venv automaticamente.
                python_exec = sys.executable # PadrÃ£o (caso jÃ¡ esteja ativado)
                
                # Caminhos comuns de ambiente virtual no Linux
                possivel_venv = self.root_dir / ".venv" / "bin" / "python"
                possivel_venv_simples = self.root_dir / "venv" / "bin" / "python"
                
                # Se acharmos o Python do ambiente virtual, usamos ele forÃ§adamente
                if possivel_venv.exists():
                    python_exec = str(possivel_venv)
                elif possivel_venv_simples.exists():
                    python_exec = str(possivel_venv_simples)
                # ------------------------------------

                cmd = [python_exec, str(self.script_path), "--marca", marca]
                if simulacao:
                    cmd.append("--simulacao")

                self.log_msg(f"ğŸš€ Iniciando motor de cÃ¡lculo para: {marca}")
                self.log_msg(f"ğŸ Usando Python em: {python_exec}") # Debug para garantir
                
                # Executa o script Python como subprocesso
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    encoding='utf-8', 
                    errors='replace'
                )

                # LÃª a saÃ­da em tempo real
                for line in process.stdout:
                    line_clean = line.strip()
                    
                    # Intercepta o JSON de estatÃ­sticas para atualizar o Dashboard
                    if "STATS_DATA=" in line_clean:
                        try:
                            json_str = line_clean.replace("STATS_DATA=", "")
                            data = json.loads(json_str)
                            self.after(0, lambda d=data: self.atualizar_kpis(d))
                        except Exception as e:
                            self.log_msg(f"âš ï¸ Erro ao ler KPIs: {e}")
                    elif "--- LOG START ---" not in line_clean:
                        self.after(0, self.log_msg, line_clean)

                process.wait()
                
                # Verifica erros
                stderr = process.stderr.read()
                if stderr:
                    self.after(0, self.log_msg, f"ğŸ”´ ERRO INTERNO:\n{stderr}")

                self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

            except Exception as e:
                self.after(0, self.log_msg, f"âŒ ERRO CRÃTICO: {e}")
                self.after(0, lambda: self.finalizar_processo(simulacao, 1))
            
    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura botÃµes
        self.btn_simular.configure(state="normal", text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exportaÃ§Ã£o
                self.log_msg("âœ… SimulaÃ§Ã£o concluÃ­da com sucesso.")
                # Volta para o dashboard para ver os nÃºmeros
                self.tabs.set("ğŸ“Š PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "CÃ¡lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("âœ… RelatÃ³rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURAÃ‡ÃƒO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("ConfiguraÃ§Ã£o", "ParÃ¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_guiantesdaatualizacaodashboard16122025.py


START FILE: launcher_gui.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURAÃ‡ÃƒO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # ConfiguraÃ§Ã£o da Janela
        self.title("NewCompras v6.5 - Central de InteligÃªncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINIÃ‡ÃƒO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARIÃVEIS DE CONTROLE ---
        # ParÃ¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em memÃ³ria

        # KPIs - SugestÃ£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRUÃ‡ÃƒO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | ConteÃºdo DinÃ¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZAÃ‡ÃƒO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para nÃ£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURAÃ‡Ã•ES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / TÃ­tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de ReposiÃ§Ã£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PARÃ‚METROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time PadrÃ£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINIÃ‡ÃƒO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # EspaÃ§ador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # BotÃµes de ManutenÃ§Ã£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="ğŸ”„ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="ğŸ’¾ Salvar ConfiguraÃ§Ã£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. ÃREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("ğŸ“Š PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("ğŸ“ LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """ConstrÃ³i a interface visual de decisÃ£o"""
        
        # --- BLOCO 1: SELEÃ‡ÃƒO DE MARCA (Cacheado e RÃ¡pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="ğŸ” Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de BotÃµes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: AÃ‡Ã•ES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="ğŸ“¥ GERAR RELATÃ“RIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # ComeÃ§a desativado por seguranÃ§a
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRATÃ‰GICO DA ANÃLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PEÃ‡AS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. LÃ“GICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser rÃ¡pido. Se falhar, lÃª do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("ğŸ“‚ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"âœ… {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"âš ï¸ Cache corrompido, recriando... ({e})")
        
        # Se nÃ£o tem cache ou deu erro, forÃ§a leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """LÃª do DuckDB (Lento) e salva no JSON"""
        self.log_msg("â³ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("âŒ Banco de dados nÃ£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas Ãºnicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"âœ… IndexaÃ§Ã£o concluÃ­da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"âŒ Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de botÃµes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # LÃ³gica visual de seleÃ§Ã£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem estÃ¡ selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECUÃ‡ÃƒO DO MOTOR DE CÃLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for cÃ¡lculo real (gerar Excel), foca na aba de Log para o usuÃ¡rio ver o progresso
        if not simulacao:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
        
        # Trava botÃµes
        self.btn_simular.configure(state="disabled", text="â³ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
            try:
                marca = self.var_marca.get()
                
                # --- CORREÃ‡ÃƒO DE AMBIENTE VIRTUAL ---
                # Define qual Python usar. Tenta achar o do .venv automaticamente.
                python_exec = sys.executable # PadrÃ£o (caso jÃ¡ esteja ativado)
                
                # Caminhos comuns de ambiente virtual no Linux
                possivel_venv = self.root_dir / ".venv" / "bin" / "python"
                possivel_venv_simples = self.root_dir / "venv" / "bin" / "python"
                
                # Se acharmos o Python do ambiente virtual, usamos ele forÃ§adamente
                if possivel_venv.exists():
                    python_exec = str(possivel_venv)
                elif possivel_venv_simples.exists():
                    python_exec = str(possivel_venv_simples)
                # ------------------------------------

                cmd = [python_exec, str(self.script_path), "--marca", marca]
                if simulacao:
                    cmd.append("--simulacao")

                self.log_msg(f"ğŸš€ Iniciando motor de cÃ¡lculo para: {marca}")
                self.log_msg(f"ğŸ Usando Python em: {python_exec}") # Debug para garantir
                
                # Executa o script Python como subprocesso
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    encoding='utf-8', 
                    errors='replace'
                )

                # LÃª a saÃ­da em tempo real
                for line in process.stdout:
                    line_clean = line.strip()
                    
                    # Intercepta o JSON de estatÃ­sticas para atualizar o Dashboard
                    if "STATS_DATA=" in line_clean:
                        try:
                            json_str = line_clean.replace("STATS_DATA=", "")
                            data = json.loads(json_str)
                            self.after(0, lambda d=data: self.atualizar_kpis(d))
                        except Exception as e:
                            self.log_msg(f"âš ï¸ Erro ao ler KPIs: {e}")
                    elif "--- LOG START ---" not in line_clean:
                        self.after(0, self.log_msg, line_clean)

                process.wait()
                
                # Verifica erros
                stderr = process.stderr.read()
                if stderr:
                    self.after(0, self.log_msg, f"ğŸ”´ ERRO INTERNO:\n{stderr}")

                self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

            except Exception as e:
                self.after(0, self.log_msg, f"âŒ ERRO CRÃTICO: {e}")
                self.after(0, lambda: self.finalizar_processo(simulacao, 1))
            
    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura botÃµes
        self.btn_simular.configure(state="normal", text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exportaÃ§Ã£o
                self.log_msg("âœ… SimulaÃ§Ã£o concluÃ­da com sucesso.")
                # Volta para o dashboard para ver os nÃºmeros
                self.tabs.set("ğŸ“Š PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "CÃ¡lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("âœ… RelatÃ³rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURAÃ‡ÃƒO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("ConfiguraÃ§Ã£o", "ParÃ¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_gui.py


START FILE: launcher_gui_gemini.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os
import time

# --- CONFIGURAÃ‡ÃƒO DE TEMA E CORES ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# Paleta de Cores Profissional (Enterprise Blue)
COLOR_SIDEBAR = "#1e293b"       # Azul Escuro (Slate 800)
COLOR_BG_MAIN = "#f1f5f9"       # Cinza Claro (Slate 100)
COLOR_WHITE = "#ffffff"
COLOR_PRIMARY = "#2563eb"       # Azul Royal (Blue 600)
COLOR_SUCCESS = "#16a34a"       # Verde Sucesso (Green 600)
COLOR_TEXT_DARK = "#0f172a"     # Preto Suave (Slate 900)
COLOR_TEXT_GRAY = "#64748b"     # Cinza Texto (Slate 500)

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # ConfiguraÃ§Ã£o da Janela
        self.title("NewCompras v6.5 - Central de InteligÃªncia de Estoque")
        self.geometry("1280x850")
        self.minsize(1100, 750)
        
        # --- DEFINIÃ‡ÃƒO DE CAMINHOS ---
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json" # <--- NOVO: Cache

        # --- VARIÃVEIS DE CONTROLE ---
        # ParÃ¢metros
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Filtros
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        self.todas_marcas = ["TODAS"] # Lista em memÃ³ria

        # KPIs - SugestÃ£o de Compra
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        
        # KPIs - Estoque Atual (Contexto)
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")

        # --- CONSTRUÃ‡ÃƒO DO LAYOUT ---
        # Grid Principal: 2 Colunas (Sidebar Fixa | ConteÃºdo DinÃ¢mico)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self.criar_sidebar()
        self.criar_area_principal()
        
        # --- INICIALIZAÃ‡ÃƒO DE DADOS ---
        self.carregar_parametros()
        
        # Carrega marcas em segundo plano para nÃ£o travar a abertura
        threading.Thread(target=self.gerenciar_cache_marcas).start()

    # =========================================================================
    # 1. BARRA LATERAL (CONFIGURAÃ‡Ã•ES)
    # =========================================================================
    def criar_sidebar(self):
        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=COLOR_SIDEBAR)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        
        # Logo / TÃ­tulo
        ctk.CTkLabel(self.sidebar, text="ANALITICX COMPRAS", font=("Montserrat", 26, "bold"), text_color="white").pack(pady=(40, 5))
        ctk.CTkLabel(self.sidebar, text="Sistema de ReposiÃ§Ã£o Inteligente", font=("Arial", 12), text_color="#94a3b8").pack(pady=(0, 40))

        # Inputs Agrupados
        self.criar_grupo_input("PARÃ‚METROS DE COMPRA", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time PadrÃ£o (Dias):", self.var_lead_time),
        ])
        
        self.criar_grupo_input("DEFINIÃ‡ÃƒO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # EspaÃ§ador
        ctk.CTkLabel(self.sidebar, text="").pack(expand=True)
        
        # BotÃµes de ManutenÃ§Ã£o
        btn_cache = ctk.CTkButton(
            self.sidebar, text="ğŸ”„ Atualizar Lista de Marcas", 
            fg_color="#334155", hover_color="#475569", 
            font=("Arial", 12),
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas).start()
        )
        btn_cache.pack(pady=10, padx=20, fill="x")
        
        btn_save = ctk.CTkButton(
            self.sidebar, text="ğŸ’¾ Salvar ConfiguraÃ§Ã£o", 
            fg_color="transparent", border_width=1, border_color="#cbd5e1",
            font=("Arial", 12, "bold"),
            command=self.salvar_parametros
        )
        btn_save.pack(pady=20, padx=20, fill="x")

    def criar_grupo_input(self, titulo, campos):
        """Cria um bloco visual de inputs na sidebar"""
        frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(frame, text=titulo, text_color="#64748b", font=("Arial", 11, "bold"), anchor="w").pack(fill="x", pady=(0, 5))
        
        for label_text, variable in campos:
            lbl = ctk.CTkLabel(frame, text=label_text, text_color="#e2e8f0", font=("Arial", 12), anchor="w")
            lbl.pack(fill="x")
            
            entry = ctk.CTkEntry(frame, textvariable=variable, height=35, fg_color="#0f172a", border_color="#334155", text_color="white")
            entry.pack(fill="x", pady=(2, 10))

    # =========================================================================
    # 2. ÃREA PRINCIPAL (ABAS DASHBOARD & LOG)
    # =========================================================================
    def criar_area_principal(self):
        self.main_frame = ctk.CTkFrame(self, fg_color=COLOR_BG_MAIN, corner_radius=0)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        
        # Sistema de Abas (Resolve o problema visual do Log)
        self.tabs = ctk.CTkTabview(self.main_frame, fg_color="transparent", text_color=COLOR_TEXT_DARK)
        self.tabs.pack(fill="both", expand=True, padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("ğŸ“Š PAINEL DE CONTROLE")
        self.tab_log = self.tabs.add("ğŸ“ LOG DO SISTEMA")

        self.montar_aba_dashboard()
        self.montar_aba_log()

    def montar_aba_dashboard(self):
        """ConstrÃ³i a interface visual de decisÃ£o"""
        
        # --- BLOCO 1: SELEÃ‡ÃƒO DE MARCA (Cacheado e RÃ¡pido) ---
        frame_marca = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_WHITE, corner_radius=8)
        frame_marca.pack(fill="x", pady=(10, 20))
        
        # Header do Filtro
        head = ctk.CTkFrame(frame_marca, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="FILTRO DE MARCA:", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_GRAY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 20, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(head, placeholder_text="ğŸ” Digite para buscar...", width=300, height=40, font=("Arial", 14), textvariable=self.var_busca)
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", self.filtrar_marcas) # Busca em tempo real

        # Grade de BotÃµes (Scroll Real)
        self.scroll_marcas = ctk.CTkScrollableFrame(frame_marca, height=140, fg_color="#f8fafc", orientation="vertical")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Inicializando banco de dados...", text_color="gray", font=("Arial", 14))
        self.lbl_loading.pack(pady=40)

        # --- BLOCO 2: AÃ‡Ã•ES PRINCIPAIS ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=10)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_PRIMARY, hover_color="#1d4ed8",
            command=lambda: self.iniciar_processamento(simulacao=True)
        )
        self.btn_simular.pack(side="left", padx=(0, 20))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="ğŸ“¥ GERAR RELATÃ“RIO EXCEL", 
            font=("Arial", 15, "bold"), height=55, width=280, 
            fg_color=COLOR_SUCCESS, hover_color="#15803d",
            state="disabled", # ComeÃ§a desativado por seguranÃ§a
            command=lambda: self.iniciar_processamento(simulacao=False)
        )
        self.btn_excel.pack(side="left")

        # --- BLOCO 3: INDICADORES (KPIs) ---
        lbl_kpi = ctk.CTkLabel(self.tab_dash, text="RESUMO ESTRATÃ‰GICO DA ANÃLISE", font=("Arial", 14, "bold"), text_color=COLOR_TEXT_DARK)
        lbl_kpi.pack(anchor="w", pady=(30, 10))

        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        # Configura 5 colunas iguais
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        # Cards de Compra (Azul)
        self.criar_card_kpi(grid_kpi, 0, "COMPRA TOTAL (R$)", self.kpi_valor, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 1, "ITENS (SKU)", self.kpi_skus, "#eff6ff", "#1e40af")
        self.criar_card_kpi(grid_kpi, 2, "PEÃ‡AS (QTD)", self.kpi_pecas, "#eff6ff", "#1e40af")
        
        # Cards de Estoque (Roxo - Contexto)
        self.criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, "#f3e8ff", "#6b21a8")
        self.criar_card_kpi(grid_kpi, 4, "COBERTURA HOJE", self.kpi_cobertura, "#f3e8ff", "#6b21a8")

    def montar_aba_log(self):
        """Aba dedicada ao Log (Estilo Terminal)"""
        frame_log = ctk.CTkFrame(self.tab_log, fg_color="#0f172a", corner_radius=0)
        frame_log.pack(fill="both", expand=True)
        
        self.txt_log = ctk.CTkTextbox(
            frame_log, 
            font=("Consolas", 14), 
            fg_color="#0f172a", 
            text_color="#22c55e", # Verde Hacker
            corner_radius=0,
            activate_scrollbars=True
        )
        self.txt_log.pack(fill="both", expand=True, padx=10, pady=10)
        self.txt_log.configure(state="disabled")

    def criar_card_kpi(self, parent, col, titulo, variavel, bg_color, text_color):
        """Cria um card bonito com sombra fake (borda)"""
        card = ctk.CTkFrame(parent, fg_color=bg_color, corner_radius=12, border_width=1, border_color=bg_color)
        card.grid(row=0, column=col, padx=8, sticky="ew")
        
        ctk.CTkLabel(card, text=titulo, font=("Arial", 11, "bold"), text_color=text_color).pack(pady=(20, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 22, "bold"), text_color="#1e293b").pack(pady=(5, 20))

    # =========================================================================
    # 3. LÃ“GICA DE MARCAS (CACHE INTELIGENTE)
    # =========================================================================
    def gerenciar_cache_marcas(self):
        """Tenta carregar do JSON para ser rÃ¡pido. Se falhar, lÃª do banco."""
        if self.cache_path.exists():
            try:
                self.log_msg("ğŸ“‚ Carregando marcas do cache local...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    dados = json.load(f)
                    self.todas_marcas = dados
                    self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
                    self.log_msg(f"âœ… {len(dados)} marcas carregadas em milissegundos.")
                    return
            except Exception as e:
                self.log_msg(f"âš ï¸ Cache corrompido, recriando... ({e})")
        
        # Se nÃ£o tem cache ou deu erro, forÃ§a leitura do banco
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        """LÃª do DuckDB (Lento) e salva no JSON"""
        self.log_msg("â³ Conectando ao Banco de Dados para indexar marcas...")
        try:
            if not self.db_path.exists():
                self.log_msg("âŒ Banco de dados nÃ£o encontrado!")
                return

            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            
            # Query para pegar marcas Ãºnicas
            res = con.execute("""
                SELECT DISTINCT marca 
                FROM sqlite_db.produtos_gerais 
                WHERE marca IS NOT NULL AND marca != '' 
                ORDER BY 1
            """).fetchall()
            
            marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            # Salva no Cache
            with open(self.cache_path, 'w', encoding='utf-8') as f:
                json.dump(marcas, f)
            
            self.todas_marcas = marcas
            self.after(0, lambda: self.renderizar_marcas(self.todas_marcas))
            self.log_msg(f"âœ… IndexaÃ§Ã£o concluÃ­da! {len(marcas)} marcas salvas no cache.")
            
            con.close()
        except Exception as e:
            self.log_msg(f"âŒ Erro fatal ao ler marcas: {e}")

    def renderizar_marcas(self, lista):
        """Desenha a grade de botÃµes de forma eficiente"""
        # Limpa widgets anteriores
        for widget in self.scroll_marcas.winfo_children():
            widget.destroy()

        # Configura Grid Responsivo (4 Colunas)
        self.scroll_marcas.grid_columnconfigure((0,1,2,3), weight=1)
        
        for i, marca in enumerate(lista):
            # LÃ³gica visual de seleÃ§Ã£o
            is_selected = (marca == self.var_marca.get())
            fg_color = COLOR_PRIMARY if is_selected else "transparent"
            text_color = "white" if is_selected else "black"
            hover_color = "#1d4ed8" if is_selected else "#bfdbfe"
            
            btn = ctk.CTkButton(
                self.scroll_marcas, 
                text=marca, 
                height=32,
                fg_color=fg_color, 
                text_color=text_color,
                hover_color=hover_color,
                border_width=1, 
                border_color="#cbd5e1",
                font=("Arial", 12),
                command=lambda m=marca: self.selecionar_marca(m)
            )
            # Posiciona no Grid
            btn.grid(row=i//4, column=i%4, padx=4, pady=4, sticky="ew")

    def selecionar_marca(self, marca):
        self.var_marca.set(marca)
        # Refiltra para atualizar as cores (quem estÃ¡ selecionado fica azul)
        self.filtrar_marcas()

    def filtrar_marcas(self, event=None):
        termo = self.var_busca.get().upper()
        if not termo:
            lista_filtrada = self.todas_marcas
        else:
            lista_filtrada = [m for m in self.todas_marcas if termo in m.upper()]
        
        self.renderizar_marcas(lista_filtrada)

    # =========================================================================
    # 4. EXECUÃ‡ÃƒO DO MOTOR DE CÃLCULO
    # =========================================================================
    def log_msg(self, msg):
        """Escreve no terminal da aba Log"""
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        
        # Se for cÃ¡lculo real (gerar Excel), foca na aba de Log para o usuÃ¡rio ver o progresso
        if not simulacao:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
        
        # Trava botÃµes
        self.btn_simular.configure(state="disabled", text="â³ PROCESSANDO...", fg_color="#64748b")
        self.btn_excel.configure(state="disabled", fg_color="#64748b")
        
        # Limpa o log
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        threading.Thread(target=lambda: self.rodar_script(simulacao)).start()

    def rodar_script(self, simulacao):
        try:
            marca = self.var_marca.get()
            cmd = [sys.executable, str(self.script_path), "--marca", marca]
            if simulacao:
                cmd.append("--simulacao")

            self.log_msg(f"ğŸš€ Iniciando motor de cÃ¡lculo para: {marca}")
            
            # Executa o script Python como subprocesso
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
                encoding='utf-8', 
                errors='replace'
            )

            # LÃª a saÃ­da em tempo real
            for line in process.stdout:
                line_clean = line.strip()
                
                # Intercepta o JSON de estatÃ­sticas para atualizar o Dashboard
                if "STATS_DATA=" in line_clean:
                    try:
                        json_str = line_clean.replace("STATS_DATA=", "")
                        data = json.loads(json_str)
                        # Atualiza GUI na thread principal
                        self.after(0, lambda d=data: self.atualizar_kpis(d))
                    except Exception as e:
                        self.log_msg(f"âš ï¸ Erro ao ler KPIs: {e}")
                elif "--- LOG START ---" not in line_clean:
                    # Todo o resto vai pro Log visual
                    self.after(0, self.log_msg, line_clean)

            process.wait()
            
            # Verifica erros
            stderr = process.stderr.read()
            if stderr:
                self.after(0, self.log_msg, f"ğŸ”´ ERRO INTERNO:\n{stderr}")

            self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

        except Exception as e:
            self.after(0, self.log_msg, f"âŒ ERRO CRÃTICO: {e}")
            self.after(0, lambda: self.finalizar_processo(simulacao, 1))

    def atualizar_kpis(self, data):
        # Formata moeda brasileira
        def fmt(v, prefix="R$ "): 
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        
        def fmt_int(v):
            return f"{int(v):,}".replace(",", ".")

        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0)):.1f} meses")

    def finalizar_processo(self, simulacao, codigo_retorno):
        # Restaura botÃµes
        self.btn_simular.configure(state="normal", text="ğŸ” PROCESSAR SIMULAÃ‡ÃƒO", fg_color=COLOR_PRIMARY)
        
        if codigo_retorno == 0:
            if simulacao:
                self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS) # Habilita exportaÃ§Ã£o
                self.log_msg("âœ… SimulaÃ§Ã£o concluÃ­da com sucesso.")
                # Volta para o dashboard para ver os nÃºmeros
                self.tabs.set("ğŸ“Š PAINEL DE CONTROLE")
                messagebox.showinfo("Sucesso", "CÃ¡lculos finalizados!\nConfira os resultados no painel.")
            else:
                self.btn_excel.configure(state="normal")
                self.log_msg("âœ… RelatÃ³rio Excel gerado.")
                messagebox.showinfo("Sucesso", "Arquivo Excel Gerado com Sucesso!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.tabs.set("ğŸ“ LOG DO SISTEMA")
            messagebox.showerror("Erro", "Ocorreu um erro no processamento.\nVerifique a aba de Log.")

    # =========================================================================
    # 5. GERENCIAMENTO DE CONFIGURAÃ‡ÃƒO (YAML)
    # =========================================================================
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, allow_unicode=True)
            
            messagebox.showinfo("ConfiguraÃ§Ã£o", "ParÃ¢metros salvos com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao salvar: {e}")

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
--------------------------------------------------------------------------------
END FILE: launcher_gui_gemini.py


START FILE: export_full_project.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

# --- CONFIGURAÃ‡Ã•ES ---
PROJECT_ROOT = Path(__file__).parent
OUTPUT_FILE = "contexto_completo_do_sistema.txt"

# Pastas para ignorar (nÃ£o entra nem lÃª nada dentro)
IGNORE_DIRS = {
    ".git", 
    ".venv", 
    "venv", 
    "env", 
    "__pycache__", 
    ".idea", 
    ".vscode", 
    "data",       # Ignora bancos de dados binÃ¡rios
    "logs",       # Ignora logs de execuÃ§Ã£o
    "exports",    # Ignora os Excels gerados
    "build",
    "dist"
}

# ExtensÃµes permitidas (sÃ³ salva arquivos deste tipo)
INCLUDE_EXTS = {
    ".py", 
    ".yaml", 
    ".yml", 
    ".sql", 
    ".json", 
    ".md", 
    ".txt", 
    ".toml", 
    ".ini"
}

# Arquivos especÃ­ficos para ignorar (caso necessÃ¡rio)
IGNORE_FILES = {
    OUTPUT_FILE, # NÃ£o ler o prÃ³prio arquivo de saÃ­da
    "package-lock.json",
    ".DS_Store"
}

def generate_tree(path, prefix=""):
    """Gera uma string visual da estrutura de pastas."""
    tree_str = ""
    try:
        # Pega itens e ordena (pastas primeiro, depois arquivos)
        items = list(path.iterdir())
        items.sort(key=lambda x: (not x.is_dir(), x.name.lower()))
        
        # Filtra itens ignorados
        items = [i for i in items if i.name not in IGNORE_DIRS and i.name not in IGNORE_FILES]
        
        count = len(items)
        for i, item in enumerate(items):
            is_last = (i == count - 1)
            connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            
            tree_str += f"{prefix}{connector}{item.name}\n"
            
            if item.is_dir():
                extension = "    " if is_last else "â”‚   "
                tree_str += generate_tree(item, prefix + extension)
                
    except PermissionError:
        tree_str += f"{prefix}â””â”€â”€ [Acesso Negado]\n"
        
    return tree_str

def main():
    print(f"ğŸš€ Iniciando exportaÃ§Ã£o do projeto em: {PROJECT_ROOT}")
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # 1. CabeÃ§alho Principal
        out.write("="*80 + "\n")
        out.write(f"PROJETO: COMPRAS-ESTOQUE-SISTEMA\n")
        out.write(f"DATA GERACAO: {os.path.basename(str(PROJECT_ROOT))}\n")
        out.write("="*80 + "\n\n")

        # 2. Estrutura de DiretÃ³rios (Ãrvore)
        out.write("ESTRUTURA DE DIRETÃ“RIOS:\n")
        out.write("-" * 40 + "\n")
        out.write(generate_tree(PROJECT_ROOT))
        out.write("\n" + "="*80 + "\n\n")
        
        # 3. ConteÃºdo dos Arquivos
        file_count = 0
        
        for root, dirs, files in os.walk(PROJECT_ROOT):
            # Modifica dirs in-place para pular pastas ignoradas no walk
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            
            for file in files:
                if file in IGNORE_FILES:
                    continue
                
                file_path = Path(root) / file
                
                # Verifica extensÃ£o
                if file_path.suffix.lower() not in INCLUDE_EXTS:
                    continue

                # Caminho relativo para exibiÃ§Ã£o
                rel_path = file_path.relative_to(PROJECT_ROOT)
                
                try:
                    content = file_path.read_text(encoding="utf-8", errors="ignore")
                    
                    # Escreve separador e conteÃºdo
                    out.write(f"START FILE: {rel_path}\n")
                    out.write("-" * 80 + "\n")
                    out.write(content)
                    out.write("\n")
                    out.write("-" * 80 + "\n")
                    out.write(f"END FILE: {rel_path}\n")
                    out.write("\n\n")
                    
                    file_count += 1
                    print(f"âœ… IncluÃ­do: {rel_path}")
                    
                except Exception as e:
                    print(f"âŒ Erro ao ler {rel_path}: {e}")

    print(f"\nâœ¨ ConcluÃ­do! {file_count} arquivos salvos em '{OUTPUT_FILE}'.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: export_full_project.py


START FILE: verificar_ambiente.py
--------------------------------------------------------------------------------
import sys
import os
import subprocess
from pathlib import Path

def diagnostico():
    print("--- ğŸ” DIAGNÃ“STICO DE AMBIENTE ---")
    print(f"Caminho do ExecutÃ¡vel Python: {sys.executable}")
    print(f"VersÃ£o do Python: {sys.version}")
    print(f"Pasta Atual (CWD): {os.getcwd()}")
    
    # 1. Tenta importar pandera
    print("\n--- ğŸ“¦ TESTE DE BIBLIOTECAS ---")
    try:
        import pandera
        print(f"âœ… Pandera: Instalado (VersÃ£o: {pandera.__version__})")
        print(f"   Local: {pandera.__file__}")
    except ImportError:
        print("âŒ Pandera: NÃƒO ENCONTRADO neste ambiente.")

    try:
        import matplotlib
        print(f"âœ… Matplotlib: Instalado")
    except ImportError:
        print("âŒ Matplotlib: NÃƒO ENCONTRADO.")

    # 2. Verifica estrutura do venv
    print("\n--- ğŸ“ ESTRUTURA DE PASTAS ---")
    venv_path = Path("./venv/bin/python")
    print(f"O arquivo ./venv/bin/python existe? {'âœ… Sim' if venv_path.exists() else 'âŒ NÃ£o'}")

    # 3. Testa como o subprocesso seria chamado
    print("\n--- ğŸš€ TESTE DE CHAMADA (SUBPROCESSO) ---")
    try:
        # Tenta rodar o python do venv pedindo a versÃ£o
        res = subprocess.run([str(venv_path), "--version"], capture_output=True, text=True)
        print(f"Chamada './venv/bin/python --version' retornou: {res.stdout.strip()}")
    except Exception as e:
        print(f"âŒ Erro ao tentar chamar o python do venv: {e}")

if __name__ == "__main__":
    diagnostico()
--------------------------------------------------------------------------------
END FILE: verificar_ambiente.py


START FILE: pyproject.toml
--------------------------------------------------------------------------------
[project]
name = "compras-estoque-sistema"
version = "1.0.0"
description = "Sistema modular de compras e gestÃ£o de estoque"
requires-python = ">=3.11"
dependencies = [
    "duckdb>=1.1.0",
    "polars-lts-cpu>=1.12.0",
    "pyarrow>=14.0.0",
    "pydantic>=2.9.0",
    "pyyaml>=6.0.2",
    "pandera[polars]>=0.20.4",
    "structlog>=24.4.0",
    "openpyxl>=3.1.5",
    "reportlab>=4.2.5",
    "pyinstaller>=6.11.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.3",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "hypothesis>=6.115.6",
    "ruff>=0.7.4",
    "mypy>=1.13.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
dev-dependencies = ["ruff", "mypy", "pytest"]

[tool.hatch.build.targets.wheel]
packages = ["src/compras_sistema"]

--------------------------------------------------------------------------------
END FILE: pyproject.toml


START FILE: tests/conftest.py
--------------------------------------------------------------------------------
# tests/conftest.py
import pytest
import polars as pl
from datetime import datetime, timedelta
import sys
from pathlib import Path

# Adiciona o src ao path para importar os mÃ³dulos do sistema
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

@pytest.fixture
def config_mock():
    """Simula o objeto de configuraÃ§Ã£o carregado do YAML."""
    class MockConfig:
        def __init__(self):
            # Simula a estrutura hÃ­brida (Objeto/Dict) que o seu sistema usa
            self.compras = {'meses_cobertura': 1.5}
            self.produto = {'dias_lancamento': 60}
            self.lead_time = {'padrao_dias': 10}
            
            # Permite acesso via dicionÃ¡rio tambÃ©m (para compatibilidade com _ler_config)
            self._data = {
                'compras': self.compras,
                'produto': self.produto,
                'lead_time': self.lead_time
            }
        
        def __getitem__(self, item):
            return self._data[item]

    return MockConfig()

@pytest.fixture
def df_produto_base():
    """Retorna um DataFrame Polars bÃ¡sico para testes de cÃ¡lculo."""
    return pl.DataFrame({
        "cod_produto": ["PROD-001"],
        "data_cadastro": [datetime.now() - timedelta(days=365)], # Item velho
        "saldo_estoque": [100],
        "saldo_oc": [0],
        "media_venda_dia": [2.0],
        "std_venda_dia": [0.5],
        "lead_time_dias": [10],
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "lote_economico": [10],
        "custo_unitario": [50.0],
        "dias_sem_venda": [0],
        "ativo": ["SIM"]
    })
--------------------------------------------------------------------------------
END FILE: tests/conftest.py


START FILE: tests/integration/test_classifiers.py
--------------------------------------------------------------------------------
# tests/integration/test_classifiers.py
import pytest
import duckdb
import polars as pl
from datetime import datetime, timedelta
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier

@pytest.fixture
def db_manager_mock():
    """Cria um DuckDB em memÃ³ria com dados falsos de venda."""
    conn = duckdb.connect(":memory:")
    
    # Cria estrutura simulando o attach do SQLite
    conn.execute("CREATE SCHEMA sqlite_db")
    
    # Cria tabela de vendas fake
    conn.execute("""
        CREATE TABLE sqlite_db.vendas (
            cod_produto VARCHAR,
            data_movimento DATE,
            quantidade INTEGER,
            valor_total DECIMAL(10,2),
            cod_clifor INTEGER
        )
    """)
    
    # Classe Mock para substituir o DuckDBManager real
    class MockDB:
        def get_connection(self):
            # Retorna um context manager falso que devolve a conexÃ£o aberta
            class ConnContext:
                def __enter__(ctx): return conn
                def __exit__(ctx, exc_type, exc_val, exc_tb): pass
            return ConnContext()
            
    return MockDB()

def test_abc_classifier(db_manager_mock):
    """Testa se a classificaÃ§Ã£o ABC (Pareto 80/15/5) funciona."""
    conn = db_manager_mock.get_connection().__enter__()
    
    # Insere dados:
    # Prod A: R$ 8000 (80%)
    # Prod B: R$ 1500 (15%)
    # Prod C: R$ 500  (5%)
    hoje = datetime.now().strftime("%Y-%m-%d")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-A', '{hoje}', 10, 8000, 1)")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-B', '{hoje}', 10, 1500, 1)")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-C', '{hoje}', 10, 500, 1)")
    
    classifier = ABCClassifier(db_manager_mock)
    
    # Como o ABCClassifier lÃª um arquivo SQL externo, precisamos garantir que
    # o arquivo exista. Se o teste falhar por FileNotFoundError, 
    # o caminho no ABCClassifier.__init__ precisa ser ajustado ou mockado.
    # Assumindo que o arquivo existe no disco:
    
    try:
        df = classifier.run()
        
        # ValidaÃ§Ãµes
        row_a = df.filter(pl.col("cod_produto") == "PROD-A").row(0, named=True)
        assert row_a["curva_abc"] == "A"
        
        row_b = df.filter(pl.col("cod_produto") == "PROD-B").row(0, named=True)
        assert row_b["curva_abc"] == "B"
        
    except FileNotFoundError:
        pytest.skip("Arquivo SQL abc_financeiro.sql nÃ£o encontrado no ambiente de teste")

def test_xyz_classifier_z_score(db_manager_mock, config_mock):
    """Testa a variabilidade (Coeficiente de VariaÃ§Ã£o)."""
    conn = db_manager_mock.get_connection().__enter__()
    
    # Prod X: Venda muito estÃ¡vel (10 todo dia)
    # Prod Z: Venda errÃ¡tica (0, 100, 0, 0)
    
    base_date = datetime.now()
    for i in range(10):
        dt = (base_date - timedelta(days=i)).strftime("%Y-%m-%d")
        conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-X', '{dt}', 10, 100, 1)")
        
        qtd_z = 100 if i == 0 else 0
        conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-Z', '{dt}', {qtd_z}, 100, 1)")

    classifier = XYZClassifier(db_manager_mock, config_mock)
    df = classifier.run()
    
    xyz_x = df.filter(pl.col("cod_produto") == "PROD-X")["curva_xyz"].item()
    xyz_z = df.filter(pl.col("cod_produto") == "PROD-Z")["curva_xyz"].item()
    
    assert xyz_x == "X"  # CV baixo
    assert xyz_z == "Z"  # CV alto
--------------------------------------------------------------------------------
END FILE: tests/integration/test_classifiers.py


START FILE: tests/unit/test_estoque_math.py
--------------------------------------------------------------------------------
# tests/unit/test_estoque_math.py
import polars as pl
from datetime import datetime, timedelta
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

def test_calculo_estoque_seguranca(df_produto_base, config_mock):
    """Verifica se o cÃ¡lculo do Z-Score para XYZ estÃ¡ correto."""
    df = EstoqueMath.calcular_seguranca(df_produto_base, config_mock)
    resultado = df["estoque_seguranca"].item()
    
    # 1.65 * 0.5 * sqrt(10) approx 2.61
    assert resultado > 2.0
    assert resultado < 3.0

def test_ponto_suprimento_e_meta(df_produto_base, config_mock):
    """Testa a lÃ³gica principal de reposiÃ§Ã£o."""
    
    # Precisamos calcular a seguranÃ§a antes, pois calcular_necessidades depende dela
    df = EstoqueMath.calcular_seguranca(df_produto_base, config_mock)
    df = EstoqueMath.calcular_necessidades(df, config_mock)
    
    row = df.row(0, named=True)
    
    # Ponto Suprimento = (2 * 10) + ES(~2.6) â‰ˆ 22.6 -> Arredonda 23
    # Estoque Meta = (2 * 45) + ES(~2.6) â‰ˆ 92.6 -> Arredonda 93
    assert row["ponto_suprimento"] >= 22
    assert row["estoque_meta"] >= 92

def test_boost_anti_ruptura(df_produto_base, config_mock):
    """Valida a regra de aumentar a mÃ©dia se o item A/B estiver zerado."""
    # CenÃ¡rio: Estoque 0, Curva A, Item Antigo
    df_ruptura = df_produto_base.with_columns([
        pl.lit(0).alias("saldo_estoque"),
        pl.lit("A").alias("curva_abc"),
        pl.lit(31).alias("dias_sem_venda"), # > 30 dias parado
        pl.lit(0.0).alias("estoque_seguranca") # <--- CORREÃ‡ÃƒO: Coluna necessÃ¡ria para o cÃ¡lculo
    ])
    
    df = EstoqueMath.calcular_necessidades(df_ruptura, config_mock)
    
    media_original = 2.0
    media_calculada = df["media_calculo"].item()
    
    # Regra: Se > 30 dias sem venda, boost de 20%
    assert media_calculada == media_original * 1.20

def test_item_novo_sem_movimento(df_produto_base, config_mock):
    """Valida a lÃ³gica de diagnÃ³stico para item recÃ©m cadastrado."""
    # Item com 10 dias de vida (menor que config 60)
    df_novo = df_produto_base.with_columns([
        pl.lit(datetime.now() - timedelta(days=10)).alias("data_cadastro"),
        pl.lit(0).alias("media_venda_dia"),
        pl.lit(0).alias("saldo_estoque"),
        pl.lit(0).alias("saldo_oc"),
        pl.lit(100).alias("score") # <--- CORREÃ‡ÃƒO: Coluna necessÃ¡ria para recalculo de score
    ])
    
    # Gera sugestÃ£o forÃ§ada para testar bloqueio/liberaÃ§Ã£o
    df_novo = df_novo.with_columns(pl.lit(100).alias("sugestao_final"))
    
    df = EstoqueMath.gerar_diagnostico(df_novo, config_mock)
    diag = df["validacao_giro"].item()
    
    # Deve identificar como item novo
    assert "ITEM NOVO" in diag 
    # Item novo deve sugerir compra mÃ­nima (1 lote)
    assert df["sugestao_final"].item() == df["lote_economico"].item()
    # Score deve ser boostado para 9999
    assert df["score"].item() == 9999

def test_lote_economico(df_produto_base, config_mock):
    """Testa arredondamento para lotes."""
    # SugestÃ£o Bruta: 15
    # Lote: 10
    # Deve virar 20 (2 lotes)
    
    df = df_produto_base.with_columns([
        pl.lit(15).alias("sugestao_bruta"),
        pl.lit(10).alias("lote_economico")
    ])
    
    df = EstoqueMath.aplicar_lote_economico(df, config_mock)
    assert df["sugestao_final"].item() == 20
--------------------------------------------------------------------------------
END FILE: tests/unit/test_estoque_math.py


START FILE: tests/unit/test_validator.py
--------------------------------------------------------------------------------
import polars as pl
import pytest
from datetime import date
from compras_sistema.rule_engine.validators.input_schema import InputCalcSchema
from pandera.errors import SchemaError

def test_validador_sucesso():
    # Dados corretos
    df = pl.DataFrame({
        "cod_produto": ["A"],
        "saldo_estoque": [10],
        "saldo_oc": [0],
        "media_venda_dia": [1.5],
        "std_venda_dia": [0.1],
        "lead_time_dias": [10.0],
        "lote_economico": [12],
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "data_cadastro": [date(2023, 1, 1)]
    })
    # NÃ£o deve levantar erro
    InputCalcSchema.validate(df)

def test_validador_falha_lote_zero():
    # Lote = 0 (Erro)
    df = pl.DataFrame({
        "cod_produto": ["A"],
        "saldo_estoque": [10],
        "saldo_oc": [0],
        "media_venda_dia": [1.5],
        "std_venda_dia": [0.1],
        "lead_time_dias": [10.0],
        "lote_economico": [0], # <--- ERRO AQUI (gt=0)
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "data_cadastro": [date(2023, 1, 1)]
    })
    
    with pytest.raises(SchemaError):
        InputCalcSchema.validate(df)
--------------------------------------------------------------------------------
END FILE: tests/unit/test_validator.py


START FILE: src/compras_sistema/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/__init__.py


START FILE: src/compras_sistema/core/system_guard.py
--------------------------------------------------------------------------------
import psutil
import logging
import sys
from pathlib import Path
from datetime import datetime

class SystemGuard:
    def __init__(self, log_dir: Path):
        self.log_dir = log_dir
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.setup_logger()

    def setup_logger(self):
        filename = f"mrp_log_{datetime.now().strftime('%Y-%m-%d')}.txt"
        log_path = self.log_dir / filename
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s | %(levelname)s | %(message)s',
            handlers=[
                logging.FileHandler(log_path),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger("MRP_Guard")

    def log(self, message):
        self.logger.info(message)

    def check_memory(self, min_mb=500):
        """
        Verifica se hÃ¡ memÃ³ria RAM disponÃ­vel suficiente.
        Se houver menos que 'min_mb', avisa ou aborta.
        """
        mem = psutil.virtual_memory()
        available_mb = mem.available / (1024 * 1024)
        
        self.logger.info(f"RAM DisponÃ­vel: {available_mb:.0f} MB")

        if available_mb < min_mb:
            self.logger.warning(f"âš ï¸ PERIGO: MemÃ³ria crÃ­tica! Apenas {available_mb:.0f}MB livres.")
            self.logger.warning("âš ï¸ Feche o navegador (Chrome/Firefox) imediatamente.")
            # Opcional: input("Pressione Enter quando liberar memÃ³ria...") 
            # No seu caso, vamos apenas logar o perigo.

    def log_performance(self, task_name, start_time):
        elapsed = (datetime.now() - start_time).total_seconds()
        self.logger.info(f"â±ï¸ Tarefa '{task_name}' concluÃ­da em {elapsed:.2f} segundos.")
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/system_guard.py


START FILE: src/compras_sistema/core/config.py
--------------------------------------------------------------------------------
from pathlib import Path
from typing import Any, Dict
import yaml
from pydantic import BaseModel, Field

class XYZConfig(BaseModel):
    threshold: float
    z_score: float

class LoteConfig(BaseModel):
    minima_absoluta: int
    limite_virada: float

# --- CLASSES NOVAS NECESSÃRIAS PARA O CÃLCULO FUNCIONAR ---
class LeadTimeConfig(BaseModel):
    padrao_dias: float
    desvio_padrao: float

class ComprasConfig(BaseModel):
    meses_cobertura: float
# ----------------------------------------------------------

class ParametrosConfig(BaseModel):
    # Aqui definimos que lead_time nÃ£o Ã© mais dict, e sim LeadTimeConfig
    lead_time: LeadTimeConfig 
    compras: ComprasConfig
    
    historico: Dict[str, int]
    produto: Dict[str, int]
    xyz: Dict[str, XYZConfig]
    abc: Dict[str, float]
    tolerancia_abc: Dict[str, float]
    lote: LoteConfig
    outlier: Dict[str, float]
    giro: Dict[str, int]
    risco: Dict[str, Any]
    sazonalidade: Dict[str, Any]
    ruptura: Dict[str, float]
    
    @classmethod
    def from_yaml(cls, path: Path) -> "ParametrosConfig":
        if not path.exists():
            raise FileNotFoundError(f"Arquivo de configuraÃ§Ã£o nÃ£o encontrado: {path}")
        with open(path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        return cls(**data)

class ConfigManager:
    """Singleton para gerenciamento de configuraÃ§Ãµes."""
    
    _instance = None
    _parametros: ParametrosConfig | None = None
    _pesos_score: dict | None = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def load_configs(self, config_dir: Path):
        """Carrega todos os arquivos de configuraÃ§Ã£o."""
        self._parametros = ParametrosConfig.from_yaml(
            config_dir / "parametros.yaml"
        )
        
        score_path = config_dir / "pesos_score.yaml"
        if score_path.exists():
            with open(score_path, 'r', encoding='utf-8') as f:
                self._pesos_score = yaml.safe_load(f)
        else:
            self._pesos_score = {}

    @property
    def parametros(self) -> ParametrosConfig:
        if self._parametros is None:
            raise RuntimeError("ConfiguraÃ§Ãµes nÃ£o carregadas. Chame load_configs() primeiro.")
        return self._parametros
    
    @property
    def pesos_score(self) -> dict:
        if self._pesos_score is None:
            raise RuntimeError("Pesos de score nÃ£o carregados.")
        return self._pesos_score
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/config.py


START FILE: src/compras_sistema/core/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/__init__.py


START FILE: src/compras_sistema/export/excel_exporter.py
--------------------------------------------------------------------------------
import polars as pl
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)


class ExcelExporter:
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def exportar_sugestao(self, df: pl.DataFrame, filename: str = None):
        if filename is None:
            data_hoje = datetime.now().strftime("%Y%m%d_%H%M")
            filename = f"sugestao_compras_{data_hoje}.xlsx"
        
        filepath = self.output_dir / filename
        logger.info("iniciando_export_excel", path=str(filepath))
        
        # ======== ORDEM DAS COLUNAS (REORGANIZADA) ========
        cols_export = [
            "status_diagnostico",
            "cod_produto",
            "descricao",
            "ref_fornecedor",
            "marca",
            "curva_abc",
            "curva_xyz",
            "sugestao_final",           # SugestÃ£o Final (Resultado)
            
            # --- BLOCO DE ANÃLISE DO CÃLCULO ---
            "sugestao_calculada",       # 1. MatemÃ¡tica Pura
            "alerta_dados",             # 2. Auditoria (PosiÃ§Ã£o Solicitada)
            "calculado_mas_bloqueado",  # 3. Flag de Bloqueio
            "motivo_bloqueio",          # 4. RazÃ£o
            # -----------------------------------
            
            "meta_pos_compra",
            "fator_sazonal",
            "lote_economico",
            "subtotal",
            "saldo_estoque",
            "saldo_oc",
            "cobertura_virtual_meses",
            "media_venda_base",
            "media_venda_dia",
            "tendencia_vendas",
            "tendencia_clientes",
            "perfil_cliente",
            "validacao_giro",
            "custo_unitario",
            "score"
        ]
        
        cols_presentes = [c for c in cols_export if c in df.columns]
        records = df.select(cols_presentes).to_dicts()
        
        # ======== CRIAÃ‡ÃƒO DO EXCEL ========
        wb = Workbook()
        ws = wb.active
        ws.title = "Analise Compras"
        
        # Estilos Gerais
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        center_align = Alignment(horizontal="center")
        left_align = Alignment(horizontal="left")
        thin_border = Border(
            left=Side(style="thin"), right=Side(style="thin"),
            top=Side(style="thin"), bottom=Side(style="thin")
        )
        
        # Cores
        fill_green = PatternFill(start_color="CCFFCC", fill_type="solid")
        fill_yellow = PatternFill(start_color="FFFFE0", fill_type="solid")
        fill_orange = PatternFill(start_color="FFD700", fill_type="solid")
        fill_blue_light = PatternFill(start_color="E6F3FF", fill_type="solid")
        fill_implanta = PatternFill(start_color="E0FFFF", fill_type="solid")
        fill_red = PatternFill(start_color="FFB6C1", fill_type="solid")
        fill_alert = PatternFill(start_color="FFFF00", fill_type="solid") # Amarelo forte
        
        # Mapeamento de nomes
        mapa_nomes = {
            "ALERTA_DADOS": "âš ï¸ ALERTA DADOS",
            "META_POS_COMPRA": "POSIÃ‡ÃƒO FINAL",
            "FATOR_SAZONAL": "IDX SAZONAL",
            "MEDIA_VENDA_DIA": "GIRO DIA (AJUST)",
            "MEDIA_VENDA_BASE": "GIRO DIA (BASE)",
            "COBERTURA_VIRTUAL_MESES": "COBERTURA MESES",
            "REF_FORNECEDOR": "REF. FABRICA",
            "SUGESTAO_CALCULADA": "CALC. ORIGINAL",
            "CALCULADO_MAS_BLOQUEADO": "BLOQUEADO?",
            "MOTIVO_BLOQUEIO": "MOTIVO BLOQUEIO"
        }
        
        headers = [c.replace("_", " ").upper() for c in cols_presentes]
        headers = [mapa_nomes.get(h, h) for h in headers]
        
        ws.append(headers)
        
        # Formata cabeÃ§alho
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_align
        
        # Preenche dados
        for row_idx, row_data in enumerate(records, 2):
            for col_idx, col_name in enumerate(cols_presentes, 1):
                val = row_data[col_name]
                cell = ws.cell(row=row_idx, column=col_idx, value=val)
                cell.border = thin_border
                
                # Alinhamento
                if col_name == "descricao":
                    cell.alignment = left_align
                else:
                    cell.alignment = center_align
                
                # FormataÃ§Ã£o numÃ©rica
                if col_name in ["custo_unitario", "subtotal"]:
                    cell.number_format = 'R$ #,##0.00'
                elif col_name in ["media_venda_dia", "media_venda_base", "fator_sazonal"]:
                    cell.number_format = '0.00'
                elif col_name in ["cobertura_virtual_meses"]:
                    cell.number_format = '0.0'
                elif col_name == "score":
                    cell.number_format = '#,##0'
                
                # ======== FORMATAÃ‡ÃƒO CONDICIONAL ========
                
                # 1. ALERTA DE DADOS
                if col_name == "alerta_dados" and val:
                    cell.font = Font(bold=True, color="FF0000")
                    cell.fill = fill_alert
                
                # 2. SugestÃµes de compra
                if col_name in ["sugestao_final", "subtotal"] and row_data.get("sugestao_final", 0) > 0:
                    cell.font = Font(bold=True, color="006400")
                    cell.fill = fill_green
                
                # 3. Produtos bloqueados
                if col_name == "calculado_mas_bloqueado" and val == "SIM":
                    cell.fill = fill_red
                    cell.font = Font(bold=True, color="8B0000")
                
                # 4. Motivo do bloqueio
                if col_name == "motivo_bloqueio" and val:
                    cell.font = Font(color="DC143C", italic=True)
                
                # 5. Fator sazonal
                if col_name == "fator_sazonal":
                    if isinstance(val, (int, float)):
                        if val < 0.90:
                            cell.font = Font(color="0000FF")
                            cell.fill = fill_blue_light
                        elif val > 1.10:
                            cell.font = Font(color="B22222", bold=True)
                
                # 6. Status diagnÃ³stico
                if col_name == "status_diagnostico":
                    val_str = str(val).upper()
                    if "IMPLANTAÃ‡ÃƒO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "RUPTURA" in val_str:
                        cell.fill = PatternFill(start_color="FF0000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "BLOQUEADO" in val_str:
                        cell.fill = PatternFill(start_color="808080", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "INATIVO" in val_str:
                        cell.fill = PatternFill(start_color="000000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "ALERTA" in val_str:
                        cell.fill = PatternFill(start_color="FF8C00", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "EXCESSO" in val_str:
                        cell.fill = fill_yellow
                    elif "COMPRAR" in val_str:
                        cell.fill = fill_green
                
                # 7. TendÃªncia
                if col_name == "tendencia_vendas":
                    val_str = str(val).upper()
                    if "ALTA" in val_str:
                        cell.font = Font(color="006400", bold=True)
                    elif "QUEDA" in val_str:
                        cell.font = Font(color="FF0000", bold=True)
                
                # 8. ValidaÃ§Ã£o Giro
                if col_name == "validacao_giro":
                    val_str = str(val)
                    if "ITEM NOVO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "SEM MOVIMENTO" in val_str:
                        cell.font = Font(color="808080", italic=True)
                    elif "Excesso" in val_str:
                        cell.font = Font(bold=True, color="B22222")
                        cell.fill = fill_orange
        
        # Ajuste de largura
        for col_idx, column_cells in enumerate(ws.columns, 1):
            max_length = 0
            column = get_column_letter(col_idx)
            limit = 60 if cols_presentes[col_idx-1] == "descricao" else 40
            
            for cell in column_cells:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            ws.column_dimensions[column].width = min(max_length + 3, limit)
        
        wb.save(filepath)
        logger.info("export_excel_concluido")
        return filepath
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/export/excel_exporter.py


START FILE: src/compras_sistema/data_engine/analytics_service.py
--------------------------------------------------------------------------------
import polars as pl
import duckdb
from datetime import datetime

class AnalyticsService:
    def __init__(self, db_manager):
        """
        ServiÃ§o de InteligÃªncia de Dados.
        ResponsÃ¡vel por transformar dados brutos do DuckDB em KPIs e TendÃªncias.
        """
        self.db_manager = db_manager

    def _obter_conexao_segura(self):
        """Garante que a conexÃ£o seja extraÃ­da corretamente do db_manager."""
        try:
            return self.db_manager.get_connection()
        except Exception as e:
            if "inicializado" in str(e).lower():
                raise RuntimeError("DuckDB nÃ£o inicializado. Chame initialize() no Launcher.")
            raise e

    def get_kpis_atuais(self, marca="TODAS"):
        """
        Calcula os KPIs financeiros e operacionais do Ãºltimo snapshot.
        Permite filtragem dinÃ¢mica por marca.
        """
        try:
            # SQL dinÃ¢mico para filtragem por marca
            condicao_marca = "" if marca == "TODAS" else f"AND marca = '{marca}'"
            
            query = f"""
                WITH ultimo_snapshot AS (
                    SELECT MAX(data_snapshot) as data_viga FROM historico_snapshots
                )
                SELECT 
                    CAST(MAX(data_snapshot) AS TIMESTAMP) as data_referencia,
                    SUM(saldo_estoque * custo_unitario) as valor_estoque,
                    SUM(sugestao_final * custo_unitario) as investimento_pendente,
                    AVG(cobertura_meses) as cobertura_media
                FROM historico_snapshots
                WHERE data_snapshot = (SELECT data_viga FROM ultimo_snapshot)
                {condicao_marca}
            """
            
            print(f"ğŸ” [Analytics] Buscando KPIs atuais para marca: {marca}")
            
            with self._obter_conexao_segura() as conn:
                res = conn.execute(query).df()
            
            if res.empty or res["valor_estoque"][0] is None:
                print(f"âš ï¸ [Analytics] Nenhum dado encontrado para a marca: {marca}")
                return {
                    "status": "vazio",
                    "data_referencia": datetime.now(),
                    "valor_estoque": 0.0,
                    "investimento_pendente": 0.0,
                    "cobertura_media": 0.0
                }

            return {
                "status": "ok",
                "data_referencia": res["data_referencia"][0],
                "valor_estoque": float(res["valor_estoque"][0]),
                "investimento_pendente": float(res["investimento_pendente"][0]),
                "cobertura_media": float(res["cobertura_media"][0])
            }

        except Exception as e:
            print(f"âŒ [Analytics] Erro crÃ­tico ao buscar KPIs: {str(e)}")
            return {"status": "erro", "erro_msg": str(e)}

    def get_tendencia_cobertura(self, marca="TODAS", dias_historico=90):
        """Busca a evoluÃ§Ã£o da cobertura por Curva ABC para o grÃ¡fico."""
        try:
            condicao_marca = "" if marca == "TODAS" else f"WHERE marca = '{marca}'"
            
            query = f"""
                SELECT 
                    CAST(data_snapshot AS DATE) as data,
                    curva_abc,
                    AVG(cobertura_meses) as cobertura_meses
                FROM historico_snapshots
                {condicao_marca}
                GROUP BY 1, 2
                HAVING data >= CURRENT_DATE - INTERVAL {dias_historico} DAY
                ORDER BY 1 ASC, 2 ASC
            """
            
            print(f"ğŸ“ˆ [Analytics] Gerando tendÃªncia de cobertura (Marca: {marca})")
            
            with self._obter_conexao_segura() as conn:
                return conn.execute(query).pl()

        except Exception as e:
            print(f"âŒ [Analytics] Erro ao processar tendÃªncia: {str(e)}")
            return pl.DataFrame()
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/analytics_service.py


START FILE: src/compras_sistema/data_engine/duckdb_manager.py
--------------------------------------------------------------------------------
"""
Gerenciador de conexÃµes DuckDB com pool thread-safe.
Implementa federaÃ§Ã£o com SQLite.
"""
import duckdb
from pathlib import Path
from contextlib import contextmanager
from threading import Lock
import structlog

logger = structlog.get_logger(__name__)

class DuckDBManager:
    """
    Gerenciador singleton de conexÃµes DuckDB.
    Implementa connection pooling para queries paralelas.
    """
    
    def __init__(self, memory_limit: str = "2GB", threads: int = 4):
        self.memory_limit = memory_limit
        self.threads = threads
        self._conn = None
        self._lock = Lock()
        
    def initialize(self, sqlite_path: Path):
        """
        Inicializa conexÃ£o DuckDB e configura federaÃ§Ã£o com SQLite.
        
        Args:
            sqlite_path: Caminho para o banco SQLite (vendas e estoque)
        """
        if not sqlite_path.exists():
            logger.warning("sqlite_not_found", path=str(sqlite_path))

        with self._lock:
            if self._conn is None:
                self._conn = duckdb.connect(":memory:")
                
                # ConfiguraÃ§Ãµes de performance
                self._conn.execute(f"SET memory_limit='{self.memory_limit}'")
                self._conn.execute(f"SET threads TO {self.threads}")
                self._conn.execute("SET enable_progress_bar=true")
                
                # Attach SQLite
                # Agora assumimos que a tabela 'saldo_custo_entrada' estÃ¡ dentro deste banco
                try:
                    self._conn.execute(f"""
                        ATTACH '{str(sqlite_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)
                    """)
                    logger.info("sqlite_attached", path=str(sqlite_path))
                except Exception as e:
                    logger.error("sqlite_attach_error", error=str(e))
                    raise

                logger.info("duckdb_initialized")

    @contextmanager
    def get_connection(self):
        """Context manager para obter conexÃ£o thread-safe."""
        with self._lock:
            if self._conn is None:
                raise RuntimeError("DuckDB nÃ£o inicializado. Chame initialize() primeiro.")
            yield self._conn

    def execute_query_file(self, query_file: Path) -> duckdb.DuckDBPyRelation:
        """Executa query SQL de arquivo."""
        if not query_file.exists():
            raise FileNotFoundError(f"Arquivo de query nÃ£o encontrado: {query_file}")

        with open(query_file, 'r', encoding='utf-8') as f:
            query = f.read()
        
        with self.get_connection() as conn:
            return conn.execute(query)

    def close(self):
        """Fecha conexÃ£o DuckDB."""
        if self._conn:
            self._conn.close()
            self._conn = None
            logger.info("duckdb_closed")
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/duckdb_manager.py


START FILE: src/compras_sistema/data_engine/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/__init__.py


START FILE: src/compras_sistema/data_engine/history_recorder.py
--------------------------------------------------------------------------------
import polars as pl
import duckdb
from datetime import datetime
from pathlib import Path
import structlog

logger = structlog.get_logger(__name__)

class HistoryRecorder:
    def __init__(self, db_manager):
        self.history_db_path = Path("data/analytics.duckdb")
        self.db_manager = db_manager

    def inicializar_tabela(self):
        """Cria a tabela no arquivo analytics.duckdb se nÃ£o existir."""
        try:
            with duckdb.connect(str(self.history_db_path)) as conn:
                # A ORDEM AQUI Ã‰ CRÃTICA:
                # 1. data_snapshot
                # 2. cod_produto
                # ...
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS historico_snapshots (
                        data_snapshot TIMESTAMP,
                        cod_produto VARCHAR,
                        curva_abc VARCHAR,
                        saldo_estoque INTEGER,
                        media_venda_dia DOUBLE,
                        custo_unitario DOUBLE,
                        sugestao_final INTEGER
                    )
                """)
                logger.info("tabela_historico_verificada", path=str(self.history_db_path))
        except Exception as e:
            logger.error("erro_inicializar_historico", error=str(e))

    def gravar_snapshot(self, df_final: pl.DataFrame):
        """Grava o resumo do dia no arquivo persistente."""
        try:
            logger.info("gravando_snapshot_historico")
            
            # Adiciona data de hoje
            df_history = df_final.with_columns(
                pl.lit(datetime.now()).alias("data_snapshot")
            )
            
            # CORREÃ‡ÃƒO CRÃTICA: 
            # Reordenamos as colunas do DataFrame para bater EXATAMENTE com a tabela SQL.
            # Se a ordem estiver diferente, o DuckDB tenta inserir produto na coluna de data.
            cols_ordenadas = [
                "data_snapshot",      # 1
                "cod_produto",        # 2
                "curva_abc",          # 3
                "saldo_estoque",      # 4
                "media_venda_dia",    # 5
                "custo_unitario",     # 6
                "sugestao_final"      # 7
            ]
            
            # Seleciona apenas o que existe e na ordem certa
            df_history = df_history.select([
                c for c in cols_ordenadas if c in df_history.columns
            ])
            
            # 2. Conecta no arquivo FÃSICO e insere
            with duckdb.connect(str(self.history_db_path)) as conn:
                conn.execute("INSERT INTO historico_snapshots SELECT * FROM df_history")
                
            logger.info("snapshot_gravado_sucesso", linhas=len(df_history))
            
        except Exception as e:
            logger.error("erro_gravar_snapshot", error=str(e))
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/history_recorder.py


START FILE: src/compras_sistema/data_engine/queries/abc_financeiro.sql
--------------------------------------------------------------------------------
/*
  CÃ¡lculo da Curva ABC Financeira (Pareto)
  Regra: 
    A = AtÃ© 80% do faturamento acumulado
    B = De 80% atÃ© 95%
    C = Restante
*/

WITH vendas_por_produto AS (
    SELECT 
        cod_produto,
        SUM(valor_total) as total_vendido
    FROM sqlite_db.vendas
    WHERE 
        -- Converte texto para data e pega os Ãºltimos 12 meses
        TRY_CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '12 months')
    GROUP BY cod_produto
    HAVING total_vendido > 0
),

calculo_acumulado AS (
    SELECT 
        cod_produto,
        total_vendido,
        -- Soma acumulada ordenada do maior para o menor
        SUM(total_vendido) OVER (ORDER BY total_vendido DESC) as valor_acumulado,
        -- Valor total geral de todas as vendas
        SUM(total_vendido) OVER () as valor_total_geral
    FROM vendas_por_produto
)

SELECT 
    cod_produto,
    total_vendido,
    valor_acumulado,
    (valor_acumulado / valor_total_geral) as percentual_acumulado,
    CASE 
        WHEN (valor_acumulado / valor_total_geral) <= 0.80 THEN 'A'
        WHEN (valor_acumulado / valor_total_geral) <= 0.95 THEN 'B'
        ELSE 'C'
    END as curva_abc
FROM calculo_acumulado
ORDER BY total_vendido DESC;
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/queries/abc_financeiro.sql


START FILE: src/compras_sistema/data_engine/queries/estatisticas_vendas.sql
--------------------------------------------------------------------------------
/*
  CÃ¡lculo de EstatÃ­sticas AvanÃ§adas: TendÃªncias e ValidaÃ§Ã£o de Giro (12m)
  CorreÃ§Ã£o: ReintroduÃ§Ã£o da coluna dias_com_venda necessÃ¡ria para o XYZ.
*/

WITH vendas_tratadas AS (
    SELECT 
        cod_produto,
        TRY_CAST(data_movimento AS DATE) as data_venda,
        quantidade,
        cod_clifor,
        MAX(ref_fornecedor) OVER (PARTITION BY cod_produto) as ref_fornecedor,
        MAX(marca) OVER (PARTITION BY cod_produto) as marca
    FROM sqlite_db.vendas
    WHERE 
        -- Pega histÃ³rico longo para cÃ¡lculo de Dias de Vida
        TRY_CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '48 months')
),

periodos AS (
    SELECT
        cod_produto,
        MAX(marca) as marca,
        MAX(ref_fornecedor) as ref_fornecedor,
        
        -- PerÃ­odos Curtos para TendÃªncia (90 dias)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '90 days') THEN quantidade ELSE 0 END) as qtd_trimestre_atual,
        COUNT(DISTINCT CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '90 days') THEN cod_clifor END) as clientes_trimestre_atual,
        SUM(CASE WHEN data_venda < (CURRENT_DATE - INTERVAL '90 days') AND data_venda >= (CURRENT_DATE - INTERVAL '180 days') THEN quantidade ELSE 0 END) as qtd_trimestre_anterior,
        COUNT(DISTINCT CASE WHEN data_venda < (CURRENT_DATE - INTERVAL '90 days') AND data_venda >= (CURRENT_DATE - INTERVAL '180 days') THEN cod_clifor END) as clientes_trimestre_anterior,

        -- Venda 12 Meses (CrÃ­tico para ValidaÃ§Ã£o de Giro)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '12 months') THEN quantidade ELSE 0 END) as venda_total_12m,

        -- Dados Gerais (Baseados no parametro meses_analise)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '{meses_analise} months') THEN quantidade ELSE 0 END) as total_vendido,
        
        -- A COLUNA QUE FALTAVA FOI REINSERIDA ABAIXO:
        COUNT(DISTINCT CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '{meses_analise} months') THEN data_venda END) as dias_com_venda,
        
        MAX(data_venda) as ultima_venda,
        MIN(data_venda) as primeira_venda,
        COUNT(DISTINCT cod_clifor) as total_clientes_unicos,
        STDDEV_POP(quantidade) as std_venda_dia_amostra
    FROM vendas_tratadas
    GROUP BY cod_produto
)

SELECT 
    *,
    DATE_DIFF('day', primeira_venda, ultima_venda) + 1 as dias_intervalo,
    CASE 
        WHEN (DATE_DIFF('day', primeira_venda, ultima_venda) + 1) <= 1 THEN total_vendido 
        ELSE CAST(total_vendido AS DOUBLE) / (DATE_DIFF('day', primeira_venda, ultima_venda) + 1)
    END as media_venda_dia,
    COALESCE(std_venda_dia_amostra, 0.0) as std_venda_dia
FROM periodos;

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/queries/estatisticas_vendas.sql


START FILE: src/compras_sistema/rule_engine/base_rule.py
--------------------------------------------------------------------------------
from abc import ABC, abstractmethod
import polars as pl
from typing import Dict, Any

class BaseRule(ABC):
    """
    Classe abstrata para todas as regras de negÃ³cio.
    Garante que toda regra tenha um mÃ©todo 'apply'.
    """
    
    @abstractmethod
    def apply(self, df: pl.LazyFrame, config: Any) -> pl.LazyFrame:
        """
        Aplica a regra de negÃ³cio ao DataFrame.
        """
        pass
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/base_rule.py


START FILE: src/compras_sistema/rule_engine/stock/estoque_math.py
--------------------------------------------------------------------------------
import polars as pl
import numpy as np
from datetime import datetime

class EstoqueMath:
    """Classe com mÃ©todos estÃ¡ticos para cÃ¡lculos de estoque"""
    
    @staticmethod
    def _ler_config(objeto_config, atributo_ou_chave):
        """
        Tenta ler uma configuraÃ§Ã£o seja ela um Atributo (Objeto) ou Chave (Dict).
        """
        try:
            return getattr(objeto_config, atributo_ou_chave)
        except AttributeError:
            return objeto_config[atributo_ou_chave]

    @staticmethod
    def aplicar_sazonalidade_projetada(df: pl.DataFrame, indices_dict: dict) -> pl.DataFrame:
        """
        Calcula o fator sazonal baseando-se na DATA DE CHEGADA da mercadoria.
        """
        if not indices_dict or len(indices_dict) != 12:
            return df.with_columns(pl.lit(1.0).alias("fator_sazonal_projetado"))
        
        lista_indices = [indices_dict.get(m, 1.0) for m in range(1, 13)]
        mes_atual = datetime.now().month
        
        def calcular_fator_futuro(leadtime):
            if leadtime is None:
                leadtime = 7
            
            meses_espera = leadtime / 30.0
            duracao_estoque = 1.5
            soma_indices = 0.0
            pontos_verificados = 0
            cursor = meses_espera
            fim_janela = meses_espera + duracao_estoque
            
            while cursor < fim_janela:
                mes_futuro_absoluto = mes_atual + int(cursor)
                index_lista = (mes_futuro_absoluto - 1) % 12
                soma_indices += lista_indices[index_lista]
                pontos_verificados += 1
                cursor += 0.5
            
            if pontos_verificados == 0:
                return 1.0
            
            fator = soma_indices / pontos_verificados
            return max(0.5, min(fator, 2.5))
        
        return df.with_columns([
            pl.col("lead_time_dias").map_elements(
                calcular_fator_futuro, return_dtype=pl.Float64
            ).alias("fator_sazonal_projetado")
        ])

    @staticmethod
    def calcular_tendencias(df: pl.DataFrame) -> pl.DataFrame:
        """
        Calcula as classificaÃ§Ãµes de TendÃªncia e Perfil de Cliente.
        """
        if "var_vendas" not in df.columns:
            df = df.with_columns([
                pl.lit(0.0).alias("var_vendas"),
                pl.lit(0).alias("saldo_clientes"),
                pl.lit(0).alias("qtd_clientes_ativos")
            ])
        
        return df.with_columns([
            # 1. TENDÃŠNCIA VENDAS
            pl.when(pl.col("var_vendas").fill_null(0.0) > 0.20).then(pl.lit("EM ALTA"))
            .when(pl.col("var_vendas").fill_null(0.0) < -0.20).then(pl.lit("EM QUEDA"))
            .otherwise(pl.lit("ESTÃVEL")).alias("tendencia_vendas"),
            
            # 2. TENDÃŠNCIA CLIENTES
            pl.when(pl.col("saldo_clientes").fill_null(0) > 0)
            .then(pl.format("GANHO +{}", pl.col("saldo_clientes")))
            .when(pl.col("saldo_clientes").fill_null(0) < 0)
            .then(pl.format("PERDA {}", pl.col("saldo_clientes")))
            .otherwise(pl.lit("MANTEVE")).alias("tendencia_clientes"),
            
            # 3. PERFIL CLIENTE
            pl.when(pl.col("qtd_clientes_ativos").fill_null(0) == 0).then(pl.lit("Sem Venda"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 2).then(pl.lit("Dedicado (1-2)"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 9).then(pl.lit("Concentrado (3-9)"))
            .otherwise(pl.lit("Pulverizado (10+)")).alias("perfil_cliente")
        ])

    @staticmethod
    def calcular_seguranca(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Estoque de SeguranÃ§a."""
        def get_z_factor(xyz):
            if xyz == "X":
                return 1.65
            if xyz == "Y":
                return 1.28
            return 0.84
        
        return df.with_columns([
            pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64).alias("fator_z"),
            (
                pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64) *
                pl.col("std_venda_dia") *
                pl.col("lead_time_dias").fill_null(7).sqrt()
            ).fill_null(0).alias("estoque_seguranca")
        ])

    @staticmethod
    def calcular_necessidades(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Calcula Ponto de Suprimento e Estoque Meta.
        CORRIGIDO: CÃ¡lculo de datas (dias_vida)
        """
        # 1. Acessa as seÃ§Ãµes de forma segura
        cfg_compras = EstoqueMath._ler_config(config, 'compras')
        cfg_produto = EstoqueMath._ler_config(config, 'produto')

        # 2. Acessa os valores
        meses_cobertura = EstoqueMath._ler_config(cfg_compras, 'meses_cobertura')
        dias_novo = EstoqueMath._ler_config(cfg_produto, 'dias_lancamento')
        
        # MELHORIA 1: Calcula dias_vida com sintaxe CORRIGIDA
        # (Agora - Data).total_days()
        df = df.with_columns([
            (pl.lit(datetime.now()) - pl.col("data_cadastro").cast(pl.Datetime)).dt.total_days().alias("dias_vida")
        ])
        
        # MELHORIA 2: Boost anti-ruptura apenas para itens VELHOS
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                pl.col("curva_abc").is_in(["A", "B"]) &
                (pl.col("dias_vida") > dias_novo) 
            )
            .then(
                pl.when(pl.col("dias_sem_venda") > 30).then(pl.col("media_venda_dia") * 1.20)
                .when(pl.col("dias_sem_venda") > 90).then(pl.col("media_venda_dia") * 1.50)
                .otherwise(pl.col("media_venda_dia") * 2.00)
            )
            .otherwise(pl.col("media_venda_dia"))
            .alias("media_calculo")
        ])
        
        return df.with_columns([
            (pl.col("media_calculo") * pl.col("lead_time_dias") + pl.col("estoque_seguranca")).round(0).alias("ponto_suprimento"),
            (pl.col("media_calculo") * 30 * meses_cobertura + pl.col("estoque_seguranca")).round(0).alias("estoque_meta")
        ]).with_columns([
            (pl.col("estoque_meta") - pl.col("saldo_estoque") - pl.col("saldo_oc")).alias("sugestao_bruta")
        ])

    @staticmethod
    def aplicar_lote_economico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Arredonda para lotes econÃ´micos"""
        return df.with_columns([
            pl.when(pl.col("sugestao_bruta") <= 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("necessidade_liquida")
        ]).with_columns([
            (pl.col("necessidade_liquida") / pl.col("lote_economico")).ceil().alias("lotes_cheios")
        ]).with_columns([
            (pl.col("lotes_cheios") * pl.col("lote_economico")).cast(pl.Int32).alias("sugestao_final")
        ]).with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal")
        ])

    @staticmethod
    def calcular_score(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula pontuaÃ§Ã£o inicial de prioridade"""
        return df.with_columns([
            (
                pl.when(pl.col("saldo_estoque") == 0).then(5000).otherwise(0) +
                pl.when(pl.col("saldo_estoque") < pl.col("media_venda_dia") * pl.col("lead_time_dias")).then(2500).otherwise(0) +
                pl.when(pl.col("curva_abc") == "A").then(1000).when(pl.col("curva_abc") == "B").then(500).otherwise(100) +
                pl.when(pl.col("tendencia_vendas") == "EM ALTA").then(500).otherwise(0) +
                (pl.col("media_venda_dia") * pl.col("custo_unitario")).fill_null(0)
            ).round(0).cast(pl.Int32).alias("score")
        ])

    @staticmethod
    def gerar_diagnostico(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Gera diagnÃ³sticos e aplica a lÃ³gica de ITEM NOVO.
        CORRIGIDO: CÃ¡lculo de datas (dias_vida)
        """
        estoque_total = pl.col("saldo_estoque") + pl.col("saldo_oc")
        venda_mensal = pl.col("media_venda_dia") * 30
        
        # 1. Acesso seguro
        cfg_produto = EstoqueMath._ler_config(config, 'produto')
        dias_novo = EstoqueMath._ler_config(cfg_produto, 'dias_lancamento')
        
        # Calcula dias_vida se ainda nÃ£o existir (CORRIGIDO)
        if "dias_vida" not in df.columns:
            df = df.with_columns([
                (pl.lit(datetime.now()) - pl.col("data_cadastro").cast(pl.Datetime)).dt.total_days().alias("dias_vida")
            ])
        
        # CÃ¡lculo de Cobertura
        base_calc = pl.when(estoque_total == 0).then(0.0).otherwise(estoque_total / venda_mensal)
        calc_cobertura = pl.when(base_calc.is_infinite()).then(99.0).otherwise(base_calc).fill_nan(99.0)
        
        df = df.with_columns([calc_cobertura.alias("cobertura_virtual_meses")])
        
        # 1. VALIDAÃ‡ÃƒO DE GIRO (O Juiz)
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                (pl.col("saldo_oc") == 0) &
                (pl.col("media_venda_dia") == 0)
            )
            .then(
                pl.when(pl.col("dias_vida") <= dias_novo)
                .then(pl.lit("SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)"))
                .otherwise(pl.lit("SEM MOVIMENTO (Item velho parado)"))
            )
            .when(pl.col("cobertura_virtual_meses") > 6).then(pl.lit("ALERTA: Excesso > 6m"))
            .when((pl.col("media_venda_dia") < 0.05) & (pl.col("sugestao_final") > 0)).then(pl.lit("ALERTA: Sem Venda Recente"))
            .otherwise(pl.lit("COERENTE")).alias("validacao_giro")
        ])
        
        # MELHORIA: Salva sugestÃ£o original antes do bloqueio
        df = df.with_columns([
            pl.col("sugestao_final").alias("sugestao_calculada")
        ])
        
        # 2. APLICA BLOQUEIOS E DEFINE MOTIVO
        df = df.with_columns([
            # Define motivo do bloqueio
            pl.when(pl.col("ativo") == "NO").then(pl.lit("Produto inativo no cadastro"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.col("validacao_giro"))
            .otherwise(pl.lit("")).alias("motivo_bloqueio"),
            
            # Flag: Foi calculado mas bloqueado?
            pl.when(
                (pl.col("sugestao_final") > 0) &
                ((pl.col("ativo") == "NO") | pl.col("validacao_giro").str.contains("ALERTA"))
            ).then(pl.lit("SIM")).otherwise(pl.lit("NÃƒO")).alias("calculado_mas_bloqueado"),
            
            # Aplica bloqueio na sugestÃ£o
            pl.when(pl.col("ativo") == "NO").then(0)
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)")
            .then(pl.col("lote_economico"))  # Item novo = 1 lote
            .otherwise(pl.col("sugestao_final")).alias("sugestao_final")
        ])
        
        # MELHORIA 3: RECALCULA SCORE APÃ“S BLOQUEIOS
        df = df.with_columns([
            pl.when(pl.col("sugestao_final") == 0).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit(9999))
            .otherwise(pl.col("score")).alias("score")
        ])
        
        # 4. STATUS DIAGNÃ“STICO FINAL
        df = df.with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal"),
            
            pl.when(pl.col("ativo") == "NO").then(pl.lit("INATIVO"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.lit("BLOQUEADO"))
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit("IMPLANTAÃ‡ÃƒO"))
            .when(pl.col("saldo_estoque") == 0).then(pl.lit("RUPTURA"))
            .when(pl.col("sugestao_final") > 0).then(pl.lit("COMPRAR"))
            .when(pl.col("cobertura_virtual_meses") > 12).then(pl.lit("EXCESSO"))
            .otherwise(pl.lit("OK")).alias("status_diagnostico")
        ])
        
        return df
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/stock/estoque_math.py


START FILE: src/compras_sistema/rule_engine/validators/input_schema.py
--------------------------------------------------------------------------------
import pandera.polars as pa
import polars as pl

class InputCalcSchema(pa.DataFrameModel):
    """
    Contrato de dados obrigatÃ³rio antes de entrar no Motor MatemÃ¡tico.
    Garante que nÃ£o existem nulos onde nÃ£o deve e que os tipos estÃ£o certos.
    """
    
    # IdentificaÃ§Ã£o
    cod_produto: str
    
    # Dados de Estoque (NÃ£o podem ser nulos)
    # coerce=True tenta converter string "10" para int 10 automaticamente
    saldo_estoque: int = pa.Field(coerce=True) 
    saldo_oc: int = pa.Field(coerce=True)
    
    # Dados de Venda (Essenciais para o cÃ¡lculo)
    media_venda_dia: float = pa.Field(ge=0.0, coerce=True)
    std_venda_dia: float = pa.Field(ge=0.0, coerce=True)
    
    # ParÃ¢metros LogÃ­sticos
    lead_time_dias: float = pa.Field(ge=0, coerce=True)
    
    # CRÃTICO: Lote 0 causa divisÃ£o por zero no script
    lote_economico: int = pa.Field(gt=0, coerce=True) 
    
    # ClassificaÃ§Ãµes
    curva_abc: str = pa.Field(isin=["A", "B", "C"])
    curva_xyz: str = pa.Field(isin=["X", "Y", "Z"])
    
    # Datas (Essencial para a lÃ³gica de Item Novo)
    data_cadastro: pl.Date

    class Config:
        # strict=False permite que o DataFrame tenha colunas extras (descricao, marca, etc)
        # sem dar erro. Validamos apenas as colunas essenciais listadas acima.
        strict = False
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/validators/input_schema.py


START FILE: src/compras_sistema/rule_engine/validators/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/validators/__init__.py


START FILE: src/compras_sistema/rule_engine/classification/xyz_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

class XYZClassifier:
    def __init__(self, db_manager: DuckDBManager, config):
        self.db = db_manager
        self.config = config

    def run(self) -> pl.DataFrame:
        # A Query continua a mesma (Corrigida para olhar apenas os Ãºltimos 365 dias)
        query = """
        WITH vendas_recentes AS (
            -- 1. Pega apenas vendas dos Ãºltimos 365 dias
            SELECT 
                cod_produto,
                CAST(data_movimento AS DATE) as data,
                SUM(quantidade) as qtd_dia
            FROM sqlite_db.vendas
            WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            GROUP BY 1, 2
        ),
        estatisticas AS (
            SELECT 
                cod_produto,
                -- Desvio padrÃ£o das vendas nos dias que houve venda
                STDDEV(qtd_dia) as std_venda_dia,
                
                -- MÃ‰DIA CORRETA: Total vendido no ano / 365 dias
                -- (Isso garante que dias sem venda puxem a mÃ©dia para baixo)
                SUM(qtd_dia) / 365.0 as media_venda_dia,
                
                -- Coeficiente de VariaÃ§Ã£o (CV)
                (STDDEV(qtd_dia) / NULLIF(AVG(qtd_dia), 0)) as cv
            FROM vendas_recentes
            GROUP BY 1
        )
        SELECT 
            CAST(cod_produto AS VARCHAR) as cod_produto,
            COALESCE(media_venda_dia, 0.0) as media_venda_dia,
            COALESCE(std_venda_dia, 0.0) as std_venda_dia,
            CASE 
                WHEN media_venda_dia <= 0 THEN 'Z' -- Se mÃ©dia Ã© 0, Ã© Z (Morto)
                WHEN cv <= 0.5 THEN 'X'  -- Muito estÃ¡vel
                WHEN cv <= 1.0 THEN 'Y'  -- VariÃ¡vel
                ELSE 'Z'                 -- ImprevisÃ­vel
            END as curva_xyz
        FROM estatisticas
        """
        
        # --- CORREÃ‡ÃƒO AQUI ---
        # Usamos o gerenciador de contexto para abrir a conexÃ£o de forma segura
        with self.db.get_connection() as conn:
            # Executa a query e converte direto para Polars
            df = conn.execute(query).pl()
        
        return df
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/xyz_classifier.py


START FILE: src/compras_sistema/rule_engine/classification/abc_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from pathlib import Path
from ...data_engine.duckdb_manager import DuckDBManager
import structlog

logger = structlog.get_logger(__name__)

class ABCClassifier:
    """Calcula a Curva ABC Financeira usando DuckDB."""
    
    def __init__(self, db_manager: DuckDBManager):
        self.db = db_manager
        # Caminho automÃ¡tico para o arquivo SQL
        self.query_path = Path(__file__).parent.parent.parent / "data_engine" / "queries" / "abc_financeiro.sql"

    def run(self) -> pl.DataFrame:
        """Executa a classificaÃ§Ã£o ABC e retorna DataFrame Polars."""
        logger.info("iniciando_curva_abc")
        
        if not self.query_path.exists():
            raise FileNotFoundError(f"Query nÃ£o encontrada: {self.query_path}")

        # LÃª o arquivo SQL
        with open(self.query_path, 'r', encoding='utf-8') as f:
            query = f.read()

        # Executa no banco e converte para Polars
        with self.db.get_connection() as conn:
            df = conn.execute(query).pl()
            
        logger.info("curva_abc_concluida", total_produtos=len(df))
        return df

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/abc_classifier.py


START FILE: src/compras_sistema/rule_engine/classification/trend_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

class TrendClassifier:
    def __init__(self, db_manager: DuckDBManager):
        self.db = db_manager

    def run(self) -> pl.DataFrame:
        """
        Calcula tendÃªncias de Vendas, Clientes e DIAS SEM VENDA (Ruptura Temporal).
        """
        query = """
        WITH periodos AS (
            SELECT 
                cod_produto,
                MAX(data_movimento) as ultima_venda,
                -- Vendas Recentes (90 dias) vs Ano (365 dias)
                SUM(CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '90 days') THEN quantidade ELSE 0 END) as qtd_90d,
                SUM(CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days') THEN quantidade ELSE 0 END) as qtd_365d,
                
                -- Contagem de Clientes Ãšnicos
                COUNT(DISTINCT CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '90 days') THEN cod_clifor END) as clientes_atuais,
                COUNT(DISTINCT CASE WHEN CAST(data_movimento AS DATE) < (CURRENT_DATE - INTERVAL '90 days') 
                                     AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '180 days') THEN cod_clifor END) as clientes_anteriores
            FROM sqlite_db.vendas
            WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            GROUP BY 1
        )
        SELECT 
            CAST(cod_produto AS VARCHAR) as cod_produto,
            
            -- CÃ¡lculo de dias sem venda (usado para boost de ruptura)
            date_diff('day', CAST(ultima_venda AS DATE), CURRENT_DATE) as dias_sem_venda,

            -- VariaÃ§Ã£o de Vendas (%)
            CASE 
                WHEN qtd_365d = 0 THEN 0
                ELSE ((qtd_90d * 4.0) / qtd_365d) - 1.0 
            END as var_vendas,
            
            -- Saldo de Clientes
            (clientes_atuais - clientes_anteriores) as saldo_clientes,
            clientes_atuais as qtd_clientes_ativos
        FROM periodos
        """
        
        with self.db.get_connection() as conn:
            return conn.execute(query).pl()
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/trend_classifier.py


START FILE: scripts/teste_matematica.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

# ConfiguraÃ§Ã£o de Caminho para importar o cÃ³digo fonte
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.core.config import ConfigManager # <--- Importante!

def main():
    print("\nğŸ§® --- CALCULADORA DE COMPRAS (PROVA REAL) ---")
    print("Digite os dados para simular um produto:\n")

    try:
        # 1. Coleta de Dados
        media_venda = float(input("MÃ©dia Venda DiÃ¡ria (ex: 1.5): "))
        std_venda = float(input("Desvio PadrÃ£o Venda (ex: 0.5): "))
        lead_time = int(input("Lead Time em dias (ex: 10): "))
        class_xyz = input("Classe XYZ (X/Y/Z): ").upper()
        estoque_atual = int(input("Saldo FÃ­sico Atual: "))
        oc_atual = int(input("Saldo em OC (Carteira): "))
        lote = int(input("Lote MÃºltiplo (ex: 12): "))
        
        # 2. Carregar ConfiguraÃ§Ã£o REAL do projeto
        config_mgr = ConfigManager()
        config_mgr.load_configs(PROJECT_ROOT / "config")
        config = config_mgr.parametros
        
        # Sobrescrevemos o Lead Time padrÃ£o com o que vocÃª digitou no teste
        config.lead_time.padrao_dias = lead_time
        
        # 3. CriaÃ§Ã£o do DataFrame Fake
        df = pl.DataFrame({
            "cod_produto": ["TESTE-01"],
            "media_venda_dia": [media_venda],
            "std_venda_dia": [std_venda],
            "lead_time_dias": [lead_time],
            "curva_xyz": [class_xyz],
            "saldo_estoque": [estoque_atual],
            "saldo_oc": [oc_atual],
            "lote_economico": [lote],
            "custo_unitario": [10.0] # FictÃ­cio
        })

        # 4. ExecuÃ§Ã£o das FÃ³rmulas Reais
        print("\nâš™ï¸  Rodando cÃ¡lculos do sistema...")
        df = EstoqueMath.calcular_seguranca(df, config)
        df = EstoqueMath.calcular_necessidades(df, config)
        df = EstoqueMath.aplicar_lote_economico(df, config)

        # 5. Resultados
        res = df.row(0, named=True)
        
        print(f"\nğŸ“Š RESULTADOS PARA O PRODUTO:")
        print(f"-----------------------------------")
        print(f"Estoque de SeguranÃ§a: {res['estoque_seguranca']} peÃ§as")
        print(f"Ponto de Suprimento:  {res['ponto_suprimento']} peÃ§as")
        print(f"Estoque Meta:         {res['estoque_meta']} peÃ§as")
        print(f"SugestÃ£o Bruta:       {res['sugestao_bruta']} peÃ§as")
        print(f"-----------------------------------")
        print(f"SUGESTÃƒO FINAL:       {res['sugestao_final']} peÃ§as (Arredondado)")
        print(f"Lotes Cheios:         {res['lotes_cheios']}")
        print(f"Subtotal Estimado:    R$ {res['subtotal']:.2f}")

    except Exception as e:
        print(f"\nâŒ Erro nos dados: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/teste_matematica.py


START FILE: scripts/gerar_relatorio_final.py
--------------------------------------------------------------------------------
import sys
import argparse
import json
from pathlib import Path
from datetime import datetime
import polars as pl
import traceback
from pandera.errors import SchemaError

# ConfiguraÃ§Ã£o de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

# Imports do Sistema
from compras_sistema.core.config import ConfigManager
from compras_sistema.core.system_guard import SystemGuard
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.history_recorder import HistoryRecorder
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.classification.trend_classifier import TrendClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.export.excel_exporter import ExcelExporter

# Import do Validador
try:
    from compras_sistema.rule_engine.validators.input_schema import InputCalcSchema
except ImportError:
    InputCalcSchema = None

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--marca", type=str, default="TODAS", help="Filtrar por marca")
    parser.add_argument("--simulacao", action="store_true", help="NÃ£o gera Excel, apenas calcula")
    args = parser.parse_args()
    
    guard = SystemGuard(PROJECT_ROOT / "logs")
    print(f"--- LOG START ---")
    guard.log(f"Processamento Iniciado - Marca: {args.marca}")
    
    # InicializaÃ§Ã£o
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")
    
    recorder = HistoryRecorder(db) if not args.simulacao else None
    if recorder:
        recorder.inicializar_tabela()
    
    try:
        # --- 1. CLASSIFICAÃ‡Ã•ES ESTATÃSTICAS ---
        guard.log("Calculando ClassificaÃ§Ãµes ABC, XYZ, TendÃªncias...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        trend_engine = TrendClassifier(db)
        
        df_abc = abc_engine.run()
        df_xyz = xyz_engine.run()
        df_trend = trend_engine.run()
        
        # --- 2. LEITURA DE DADOS (SNAPSHOT) ---
        guard.log("Lendo Estoques e Cadastro Completo...")
        with db.get_connection() as conn:
            # LÃª saldos
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto,
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
            """).pl()
            
            # Leitura dinÃ¢mica do cadastro
            try:
                cols_db = [c[1] for c in conn.execute("PRAGMA table_info(sqlite_db.produtos_gerais)").fetchall()]
                
                col_desc = "descricao_produto" if "descricao_produto" in cols_db else ("descricao" if "descricao" in cols_db else "''")
                col_data = "CAST(data_cadastro AS DATE)" if "data_cadastro" in cols_db else "CAST('2000-01-01' AS DATE)"
                col_ref = "ref_fornecedor" if "ref_fornecedor" in cols_db else "''"
                
                df_cadastro = conn.execute(f"""
                    SELECT 
                        CAST(cod_produto AS VARCHAR) as cod_produto,
                        CAST(qtd_economica AS INTEGER) as lote_economico,
                        marca,
                        {col_desc} as descricao,
                        {col_ref} as ref_fornecedor,
                        ativo,
                        {col_data} as data_cadastro
                    FROM sqlite_db.produtos_gerais
                """).pl()
            except Exception as e:
                guard.log(f"Erro ao ler cadastro: {e}. Usando estrutura vazia de seguranÃ§a.")
                df_cadastro = pl.DataFrame(schema={
                    "cod_produto": pl.Utf8, "lote_economico": pl.Int64, "marca": pl.Utf8,
                    "descricao": pl.Utf8, "ref_fornecedor": pl.Utf8, "ativo": pl.Utf8,
                    "data_cadastro": pl.Date
                })
        
        # Carrega Sazonalidade
        indices_dict = {}
        try:
            analytics_path = PROJECT_ROOT / "data" / "analytics.duckdb"
            if analytics_path.exists():
                with db.get_connection() as conn:
                    conn.execute(f"ATTACH '{analytics_path}' AS analytics")
                    rows = conn.execute("SELECT mes, indice_sazonal FROM analytics.indices_sazonais").fetchall()
                    conn.execute("DETACH analytics")
                    for r in rows:
                        indices_dict[r[0]] = r[1]
        except Exception as e:
            guard.log(f"Aviso: Sazonalidade nÃ£o carregada ({e}). Usando padrÃ£o 1.0.")
            pass
        
        # --- 3. UNIFICAÃ‡ÃƒO (JOIN) ---
        guard.log("Cruzando dados...")
        
        df_universe = pl.concat([
            df_xyz.select("cod_produto"),
            df_saldo.select("cod_produto"),
            df_cadastro.select("cod_produto")
        ]).unique(subset="cod_produto")
        
        df_final = (df_universe
            .join(df_xyz, on="cod_produto", how="left")
            .join(df_abc, on="cod_produto", how="left")
            .join(df_trend, on="cod_produto", how="left")
            .join(df_saldo, on="cod_produto", how="left")
            .join(df_cadastro, on="cod_produto", how="left"))
        
        if "descricao" not in df_final.columns:
            if "descricao_right" in df_final.columns:
                df_final = df_final.rename({"descricao_right": "descricao"})
            else:
                df_final = df_final.with_columns(pl.lit("SEM DESCRIÃ‡ÃƒO").alias("descricao"))
        
        # --- 4. TRATAMENTO, DETECÃ‡ÃƒO E VALIDAÃ‡ÃƒO ---
        
        lead_time_padrao = config_mgr.parametros.lead_time.padrao_dias
        if isinstance(lead_time_padrao, dict):
            lead_time_padrao = lead_time_padrao.get('padrao_dias', 10)
            
        # A. Preenchimento BÃ¡sico (Nulos viram Zero, Negativos sÃ£o mantidos)
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").fill_null(0.0),
            pl.col("std_venda_dia").fill_null(0.0),
            pl.col("curva_xyz").fill_null("Z"),
            pl.col("dias_sem_venda").fill_null(0).alias("dias_sem_venda"),
            
            # Aqui permitimos negativos para o relatÃ³rio
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            
            pl.col("custo_unitario").fill_null(0.0),
            pl.col("curva_abc").fill_null("C"),
            pl.col("marca").fill_null("N/D"),
            pl.col("descricao").fill_null("DESCRIÃ‡ÃƒO NÃƒO ENCONTRADA"),
            pl.col("ref_fornecedor").fill_null(""),
            pl.col("lote_economico").fill_null(1).map_elements(lambda x: max(1, x), return_dtype=pl.Int64),
            pl.col("ativo").fill_null("SIM"),
            pl.col("data_cadastro").fill_null(pl.lit(datetime(2000,1,1)).cast(pl.Date)),
            pl.lit(lead_time_padrao).alias("lead_time_dias"),
        ])

        # B. DetecÃ§Ã£o de Anomalias (CriaÃ§Ã£o de Alertas)
        df_final = df_final.with_columns([
            pl.when(pl.col("saldo_estoque") < 0)
            .then(pl.lit("ESTOQUE NEGATIVO"))
            .when(pl.col("saldo_oc") < 0)
            .then(pl.lit("OC NEGATIVA (ERRO ERP)"))
            .otherwise(None)
            .alias("alerta_dados")
        ])

        # C. Log de Problemas (Console)
        df_problemas = df_final.filter(pl.col("alerta_dados").is_not_null())
        if not df_problemas.is_empty():
            guard.log(f"âš ï¸ ATENÃ‡ÃƒO: Encontrados {len(df_problemas)} produtos com anomalias de dados!")
            for row in df_problemas.head(3).iter_rows(named=True):
                guard.log(f"   -> Produto {row['cod_produto']}: {row['alerta_dados']} (Est: {row['saldo_estoque']} | OC: {row['saldo_oc']})")

        # D. ValidaÃ§Ã£o Pandera (Agora permite negativos, mas garante integridade estrutural)
        if InputCalcSchema:
            guard.log("Validando integridade dos dados (Pandera)...")
            try:
                df_final = InputCalcSchema.validate(df_final)
                guard.log("âœ… Dados estruturais validados!")
            except SchemaError as e:
                guard.log(f"âŒ ERRO DE VALIDAÃ‡ÃƒO DE DADOS:")
                guard.log(f"Falha na coluna: {e.schema.name if e.schema else 'Schema Global'}")
                guard.log(f"Motivo: {e.check}")
                if e.failure_cases is not None:
                     print("\nğŸ“‹ REGISTROS QUE FALHARAM NA VALIDAÃ‡ÃƒO (Top 5):")
                     print(e.failure_cases.head(5))
                sys.exit(1)
        else:
            guard.log("âš ï¸ Aviso: InputCalcSchema nÃ£o encontrado. Pulando validaÃ§Ã£o.")

        # --- 5. MOTOR DE CÃLCULO ---
        guard.log("Executando Motor MatemÃ¡tico...")
        
        # Salva mÃ©dia base
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").alias("media_venda_base")
        ])
        
        # Sazonalidade
        df_final = EstoqueMath.aplicar_sazonalidade_projetada(df_final, indices_dict)
        
        df_final = df_final.with_columns([
            pl.col("fator_sazonal_projetado").alias("fator_sazonal"),
            (pl.col("media_venda_base") * pl.col("fator_sazonal_projetado")).alias("media_venda_dia")
        ])
        
        # PREPARAÃ‡ÃƒO PARA MATEMÃTICA (SanitizaÃ§Ã£o TemporÃ¡ria)
        # O motor matemÃ¡tico nÃ£o deve receber OC negativa, pois distorce o cÃ¡lculo.
        # Mas o estoque negativo Ã© OK (aumenta a necessidade).
        df_math = df_final.with_columns([
            pl.col("saldo_oc").clip(lower_bound=0) # Sanitiza apenas para o cÃ¡lculo
        ])
        
        # Executa CÃ¡lculos no DF Sanitizado
        df_math = EstoqueMath.calcular_tendencias(df_math)
        df_math = EstoqueMath.calcular_seguranca(df_math, config_mgr.parametros)
        df_math = EstoqueMath.calcular_necessidades(df_math, config_mgr.parametros)
        df_math = EstoqueMath.aplicar_lote_economico(df_math, config_mgr.parametros)
        df_math = EstoqueMath.calcular_score(df_math)
        df_math = EstoqueMath.gerar_diagnostico(df_math, config_mgr.parametros)
        
        # Recupera as colunas calculadas de volta para o df_final (que tem os dados originais/negativos)
        # Assim o Excel mostra a OC negativa (alerta) mas a sugestÃ£o de compra estÃ¡ correta (ignorando o erro)
        cols_calculadas = [
            "tendencia_vendas", "tendencia_clientes", "perfil_cliente", # Tendencias
            "estoque_seguranca", "fator_z",                             # Seguranca
            "ponto_suprimento", "estoque_meta", "sugestao_bruta",       # Necessidades
            "media_calculo", "dias_vida",                               # Necessidades Aux
            "lotes_cheios", "sugestao_final", "subtotal",               # Lote
            "score",                                                    # Score
            "validacao_giro", "motivo_bloqueio",                        # Diagnostico
            "calculado_mas_bloqueado", "status_diagnostico", 
            "cobertura_virtual_meses", "sugestao_calculada"
        ]
        
        # Junta os resultados calculados de volta no dataframe principal
        df_final = df_final.with_columns(df_math.select(cols_calculadas))
        
        # KPI Final de PosiÃ§Ã£o
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") + pl.col("saldo_oc") + pl.col("sugestao_final")).alias("meta_pos_compra")
        ])
        
        # --- 6. FILTROS E EXPORTAÃ‡ÃƒO ---
        
        if args.marca and args.marca != "TODAS":
            guard.log(f"Filtrando relatÃ³rio para marca: {args.marca}")
            df_final = df_final.filter(pl.col("marca") == args.marca)
        
        # CÃ¡lculo de EstatÃ­sticas
        try:
            val_estoque_atual = df_final.select((pl.col("saldo_estoque") * pl.col("custo_unitario")).sum()).item()
            val_venda_mensal = df_final.select((pl.col("media_venda_dia") * 30 * pl.col("custo_unitario")).sum()).item()
            
            if val_venda_mensal > 0:
                cobertura = val_estoque_atual / val_venda_mensal
            else:
                cobertura = 0.0
        except:
            val_estoque_atual = 0.0
            cobertura = 0.0
        
        df_compra = df_final.filter(pl.col("sugestao_final") > 0)
        
        stats = {
            "total_valor": df_compra["subtotal"].sum(),
            "total_skus": len(df_compra),
            "total_pecas": df_compra["sugestao_final"].sum(),
            "estoque_atual": val_estoque_atual,
            "cobertura_meses": cobertura
        }
        
        print(f"STATS_DATA={json.dumps(stats)}")
        
        # ExportaÃ§Ã£o Excel
        if not args.simulacao:
            guard.log("Gerando relatÃ³rio Excel...")
            exporter = ExcelExporter(PROJECT_ROOT / "data" / "exports")
            # Ordena com prioridade para Alertas de Dados
            df_final = df_final.sort(["alerta_dados", "score"], descending=[True, True])
            arquivo = exporter.exportar_sugestao(df_final)
            guard.log(f"RelatÃ³rio gerado: {arquivo}")
            
            if recorder:
                recorder.gravar_snapshot(df_final)
        
        guard.log("Processamento concluÃ­do com sucesso!")
        
    except Exception as e:
        guard.log(f"ERRO CRÃTICO: {e}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/gerar_relatorio_final.py


START FILE: scripts/export_project_context.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

# ConfiguraÃ§Ã£o
PROJECT_ROOT = Path(__file__).parent.parent
OUTPUT_FILE = PROJECT_ROOT / "contexto_completo_para_ia.txt"

# Pastas e arquivos que queremos incluir
INCLUDED_DIRS = [
    PROJECT_ROOT / "src",
    PROJECT_ROOT / "scripts",
    PROJECT_ROOT / "config",
]

# Arquivos especÃ­ficos para ignorar (opcional)
IGNORE_FILES = ["__pycache__", ".DS_Store", "vendas.db", "analytics.duckdb", ".git", ".vscode"]

def generate_tree(root_dir):
    """Gera uma representaÃ§Ã£o visual da Ã¡rvore de arquivos."""
    tree_str = "PROJECT STRUCTURE:\n"
    for path in sorted(root_dir.rglob('*')):
        if any(part.startswith('.') or part == "__pycache__" for part in path.parts):
            continue
        if path.is_file() and path.suffix in ['.py', '.yaml', '.json', '.sql']:
            depth = len(path.relative_to(root_dir).parts)
            indent = '    ' * (depth - 1)
            tree_str += f"{indent}â”œâ”€â”€ {path.name}\n"
    return tree_str + "\n" + "="*50 + "\n\n"

def main():
    print(f"ğŸ“¦ Empacotando projeto em: {OUTPUT_FILE}")
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # 1. Escreve o CabeÃ§alho e Estrutura
        out.write("CONTEXTO DO PROJETO DE COMPRAS E ESTOQUE\n")
        out.write("Linguagem: Python 3.11\n")
        out.write("Libs principais: Polars, DuckDB, OpenPyXL\n\n")
        out.write(generate_tree(PROJECT_ROOT))
        
        # 2. Varre os arquivos e escreve o conteÃºdo
        for folder in INCLUDED_DIRS:
            if not folder.exists(): continue
            
            for root, dirs, files in os.walk(folder):
                # Filtra pastas ignoradas
                dirs[:] = [d for d in dirs if d not in IGNORE_FILES]
                
                for file in files:
                    if file in IGNORE_FILES or not file.endswith(('.py', '.yaml')):
                        continue
                        
                    file_path = Path(root) / file
                    rel_path = file_path.relative_to(PROJECT_ROOT)
                    
                    # Escreve o separador e o nome do arquivo
                    out.write(f"FILE: {rel_path}\n")
                    out.write("-" * 50 + "\n")
                    
                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            content = f.read()
                            out.write(content)
                    except Exception as e:
                        out.write(f"# Erro ao ler arquivo: {e}")
                    
                    out.write("\n\n" + "="*50 + "\n\n")
    
    print("âœ… Arquivo gerado com sucesso!")
    print("Agora vocÃª pode anexar 'contexto_completo_para_ia.txt' no chat da IA.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/export_project_context.py


START FILE: scripts/auditor_item.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb
from datetime import datetime
import math

# ConfiguraÃ§Ã£o de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    print("ğŸ•µï¸  AUDITOR DE CÃLCULO DE COMPRAS (RAIO-X - DB INTEGRADO)")
    print("==========================================")
    cod_alvo = input("Digite o CÃ“DIGO DO PRODUTO para auditar: ").strip()

    # 1. CONEXÃƒO COM DADOS
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    
    if not db_path.exists():
        print("âŒ Banco de dados vendas.db nÃ£o encontrado!")
        return

    conn = duckdb.connect()
    conn.execute("INSTALL sqlite; LOAD sqlite;")
    conn.execute(f"ATTACH '{db_path}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
    
    print(f"\nğŸ” 1. DADOS BRUTOS (Banco de Dados)")
    print("-" * 50)

    # --- BUSCA DADOS CADASTRAIS ---
    try:
        cadastro = conn.execute(f"""
            SELECT ativo, qtd_economica, marca 
            FROM sqlite_db.produtos_gerais 
            WHERE cod_produto = '{cod_alvo}'
        """).fetchone()
        
        ativo = cadastro[0] if cadastro else "SIM (NÃ£o encontrado)"
        lote = cadastro[1] if cadastro and cadastro[1] else 1
        marca = cadastro[2] if cadastro else "N/D"
    except:
        ativo = "ERRO LEITURA"
        lote = 1
        marca = "?"
    
    print(f"â€¢ Cadastro: Ativo={ativo} | Lote={lote} | Marca={marca}")

    # --- BUSCA ESTOQUE (NOVA TABELA) ---
    try:
        estoque_data = conn.execute(f"""
            SELECT saldo_estoque, saldo_oc, custo_unitario, ultima_entrada
            FROM sqlite_db.saldo_custo_entrada
            WHERE CAST(cod_produto AS VARCHAR) = '{cod_alvo}'
        """).fetchone()
    except Exception as e:
        print(f"âŒ Erro ao ler tabela 'saldo_custo_entrada': {e}")
        estoque_data = None
    
    if not estoque_data:
        print("âŒ ERRO: Item nÃ£o encontrado na tabela de saldo!")
        return

    saldo = estoque_data[0] if estoque_data[0] else 0
    saldo_oc = estoque_data[1] if estoque_data[1] else 0
    custo = estoque_data[2] if estoque_data[2] else 0.0
    ult_entrada = estoque_data[3]
    
    print(f"â€¢ Estoque: FÃ­sico={saldo} | OC={saldo_oc} | Custo=R${custo:.2f}")
    print(f"â€¢ Ãšltima Entrada: {ult_entrada}")

    # --- BUSCA VENDAS (MÃ‰DIA REAL 365 DIAS) ---
    vendas_365 = conn.execute(f"""
        SELECT SUM(quantidade) 
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
        AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
    """).fetchone()
    
    total_vendas_ano = vendas_365[0] if vendas_365[0] else 0
    media_diaria_real = total_vendas_ano / 365.0
    
    print(f"â€¢ Vendas 365 dias: {total_vendas_ano} peÃ§as")
    print(f"â€¢ MÃ©dia DiÃ¡ria (Total/365): {media_diaria_real:.4f}")

    # ... (O restante do cÃ³digo de cÃ¡lculo permanece igual, pois usa as variÃ¡veis carregadas acima) ...
    # Para economizar espaÃ§o, mantive apenas a parte de extraÃ§Ã£o de dados que mudou.
    
    # ... [CÃ“DIGO DE CÃLCULO MANTIDO IGUAL AO ORIGINAL] ...

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/auditor_item.py


START FILE: scripts/teste_score.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

def main():
    print("\nğŸ† --- CALCULADORA DE SCORE (GAMIFICATION) ---")
    
    try:
        curva_abc = input("Curva ABC (A/B/C): ").upper()
        sugestao = int(input("SugestÃ£o de Compra (>0?): "))
        estoque = int(input("Saldo de Estoque (pode ser 0 ou negativo): "))
        
        print("\n--- Dados Auxiliares ---")
        media_dia = float(input("MÃ©dia Venda Dia: "))
        custo = float(input("Custo UnitÃ¡rio (R$): "))
        lead_time = int(input("Lead Time (dias): "))
        crescimento = float(input("Crescimento Vendas % (ex: 0.25 para 25%): "))

        # DataFrame Fake
        df = pl.DataFrame({
            "cod_produto": ["TESTE-SCORE"],
            "curva_abc": [curva_abc],
            "sugestao_final": [sugestao],
            "saldo_estoque": [estoque],
            "media_venda_dia": [media_dia],
            "custo_unitario": [custo],
            "lead_time_dias": [lead_time],
            "var_vendas": [crescimento],
            # Campos necessÃ¡rios para rodar sem erro
            "curva_xyz": ["X"], 
            "std_venda_dia": [0]
        })

        print("\nâš™ï¸  Calculando pontos...")
        df = EstoqueMath.calcular_score(df)
        
        score = df['score'][0]
        
        print(f"\nğŸ–ï¸  PONTUAÃ‡ÃƒO FINAL: {score} PONTOS")
        print(f"-----------------------------------")
        print("CritÃ©rios Atendidos:")
        if sugestao > 0:
            if estoque <= 0: print("âœ… Ruptura Total (+5000)")
            elif (estoque / media_dia) < lead_time: print("âœ… Risco Iminente (+2500)")
            
            if curva_abc == "A": print("âœ… Curva A (+1000)")
            elif curva_abc == "B": print("âœ… Curva B (+500)")
            
            if crescimento > 0.20: print("âœ… TendÃªncia Alta (+500)")
            
            giro_diario = media_dia * custo
            print(f"âœ… Giro Financeiro (+{int(giro_diario)})")
        else:
            print("ğŸš« Sem SugestÃ£o de Compra (Score zerado)")

    except Exception as e:
        print(f"\nâŒ Erro: {e}")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/teste_score.py


START FILE: scripts/fix_toml.py
--------------------------------------------------------------------------------
from pathlib import Path

# ConteÃºdo correto do pyproject.toml
content = """[project]
name = "compras-estoque-sistema"
version = "1.0.0"
description = "Sistema modular de compras e gestÃ£o de estoque"
requires-python = ">=3.11"
dependencies = [
    "duckdb>=1.1.0",
    "polars>=1.12.0",
    "pydantic>=2.9.0",
    "pyyaml>=6.0.2",
    "pandera[polars]>=0.20.4",
    "structlog>=24.4.0",
    "openpyxl>=3.1.5",
    "reportlab>=4.2.5",
    "pyinstaller>=6.11.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.3",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "hypothesis>=6.115.6",
    "ruff>=0.7.4",
    "mypy>=1.13.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
dev-dependencies = ["ruff", "mypy", "pytest"]

# Esta seÃ§Ã£o ensina o hatchling onde encontrar o cÃ³digo
[tool.hatch.build.targets.wheel]
packages = ["src/compras_sistema"]
"""

# Reescreve o arquivo na raiz do projeto
root_dir = Path(__file__).parent.parent
toml_path = root_dir / "pyproject.toml"

print(f"ğŸ”§ Corrigindo: {toml_path}")
with open(toml_path, "w", encoding="utf-8") as f:
    f.write(content)

print("âœ… pyproject.toml corrigido com sucesso!")
--------------------------------------------------------------------------------
END FILE: scripts/fix_toml.py


START FILE: scripts/test_calculo_estoque.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

structlog.configure(processors=[structlog.processors.JSONRenderer()])

def main():
    print("ğŸš€ Iniciando CÃ¡lculo Completo de Estoque (DB Integrado)...")
    
    # 1. Config e Banco
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    # ATUALIZADO: Inicializa apenas com o SQLite
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")

    try:
        # 2. Rodar Classificadores (ABC + XYZ)
        print("âš¡ Calculando ABC e XYZ...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        
        df_abc = abc_engine.run() 
        df_xyz = xyz_engine.run() 

        # 3. Buscar Dados de Estoque (Agora da tabela SQL)
        print("ğŸ“¦ Buscando Saldos no Banco de Dados...")
        with db.get_connection() as conn:
            # ATUALIZADO: Query na tabela sqlite_db.saldo_custo_entrada
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto, 
                    saldo_estoque, 
                    saldo_oc, 
                    custo_unitario
                FROM sqlite_db.saldo_custo_entrada
            """).pl()

        # 4. O Grande Join (Unindo tudo)
        print("ğŸ”— Unificando dados...")
        df_final = (
            df_xyz
            .join(df_abc, on="cod_produto", how="left")
            .join(df_saldo, on="cod_produto", how="left")
        )
        
        # Preenche nulos
        df_final = df_final.with_columns([
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            pl.col("curva_abc").fill_null("C")
        ])

        # 5. Aplicar MatemÃ¡tica de Estoque
        print("ğŸ§® Calculando ES, PS e EM...")
        df_final = EstoqueMath.calcular_seguranca(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_necessidades(df_final, config_mgr.parametros)

        # 6. Calcular SugestÃ£o
        df_final = df_final.with_columns([
            (pl.col("estoque_meta") - (pl.col("saldo_estoque") + pl.col("saldo_oc"))).alias("sugestao_bruta")
        ]).with_columns([
            pl.when(pl.col("sugestao_bruta") < 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("sugestao_final")
        ])

        # 7. Mostrar Resultados
        print("\nâœ… CÃ¡lculo Finalizado!")
        print("-" * 50)
        
        compras = df_final.filter(pl.col("sugestao_final") > 0).sort("sugestao_final", descending=True)
        
        print(f"ğŸ“¦ Total de Produtos Analisados: {len(df_final)}")
        print(f"ğŸ’° Produtos com SugestÃ£o de Compra: {len(compras)}")
        
        print("\nğŸ† Top 5 SugestÃµes de Compra (Volume):")
        cols_show = ["cod_produto", "curva_abc", "curva_xyz", "saldo_estoque", "estoque_seguranca", "estoque_meta", "sugestao_final"]
        print(compras.select(cols_show).head(5))

    except Exception as e:
        print(f"\nâŒ Erro CrÃ­tico: {e}")
        import traceback
        traceback.print_exc()
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/test_calculo_estoque.py


START FILE: scripts/test_xyz.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Setup
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier

structlog.configure(processors=[structlog.processors.JSONRenderer()])

def main():
    print("ğŸš€ Testando ClassificaÃ§Ã£o XYZ (Previsibilidade)...")
    
    # 1. Carregar ConfiguraÃ§Ãµes (Importante para pegar os thresholds X e Y)
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    # 2. Inicializar Banco
    db = DuckDBManager()
    db.initialize(
        PROJECT_ROOT / "data" / "vendas.db",
        PROJECT_ROOT / "data" / "Saldo Estoque OC Custo Ultima Entrada Spaal.csv"
    )
    
    try:
        # 3. Executar XYZ
        classifier = XYZClassifier(db, config_mgr.parametros)
        df_xyz = classifier.run()
        
        print(f"\nâœ… Sucesso! ClassificaÃ§Ã£o gerada.")
        
        print("\nğŸ“Š Resumo da DistribuiÃ§Ã£o XYZ:")
        print(df_xyz.group_by("curva_xyz").len().sort("curva_xyz"))
        
        print("\nğŸ” Exemplo de Produto X (Reloginho):")
        print(df_xyz.filter(df_xyz["curva_xyz"] == "X").head(3).select([
            "cod_produto", "media_venda_dia", "coeficiente_variacao", "curva_xyz"
        ]))

        print("\nğŸ” Exemplo de Produto Z (ImprevisÃ­vel):")
        print(df_xyz.filter(df_xyz["curva_xyz"] == "Z").head(3).select([
            "cod_produto", "media_venda_dia", "coeficiente_variacao", "curva_xyz"
        ]))

    except Exception as e:
        print(f"\nâŒ Erro: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/test_xyz.py


START FILE: scripts/setup_database.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path
import sys

# Setup de caminhos
ROOT_DIR = Path(__file__).parent.parent
DATA_DIR = ROOT_DIR / "data"
DB_PATH = DATA_DIR / "vendas.db"

def setup_database():
    print("ğŸš€ Iniciando criaÃ§Ã£o do Banco de Dados de Vendas...")
    
    # 1. Encontrar o arquivo de vendas (CSV)
    # Procura arquivos que contenham "Movimento" ou "Vendas" no nome
    sales_files = list(DATA_DIR.glob("*ovimento*.csv")) + list(DATA_DIR.glob("*endas*.csv"))
    
    if not sales_files:
        print("âŒ Nenhum arquivo de vendas encontrado na pasta 'data/'!")
        print("   Por favor, coloque o arquivo CSV de vendas (ex: 'Movimento.csv') lÃ¡.")
        return
    
    csv_path = sales_files[0]
    print(f"ğŸ“‚ Arquivo de origem detectado: {csv_path.name}")

    # 2. Conectar ao DuckDB (em memÃ³ria para processamento rÃ¡pido)
    con = duckdb.connect()
    
    try:
        # 3. Ler o CSV e tratar colunas
        # Baseado no PDF, mapeamos os nomes originais para o padrÃ£o do sistema
        print("â³ Lendo CSV e convertendo dados...")
        
        # Cria uma view temporÃ¡ria lendo o CSV
        con.execute(f"""
            CREATE VIEW raw_vendas AS 
            SELECT * FROM read_csv_auto('{str(csv_path)}', normalize_names=True)
        """)
        
        # Verifica quais colunas existem para garantir o mapeamento
        columns = [c[0] for c in con.execute("DESCRIBE raw_vendas").fetchall()]
        print(f"   Colunas detectadas: {columns}")
        
        # Query de transformaÃ§Ã£o (Adapte os nomes 'cod_produto', 'data', etc se necessÃ¡rio)
        # O DuckDB normalize_names remove acentos e espaÃ§os (ex: "CÃ³d. Produto" vira "cod_produto")
        query = """
            SELECT 
                CAST(cod_produto AS VARCHAR) as cod_produto,
                CAST(data AS DATE) as data_movimento,
                CAST(qtde AS INTEGER) as quantidade,
                CAST(total AS DECIMAL(10,2)) as valor_total,
                CAST(cod_clifor AS INTEGER) as cod_cliente,
                uf as uf_cliente
            FROM raw_vendas
            WHERE data IS NOT NULL
        """
        
        # 4. Salvar no SQLite
        print(f"ğŸ’¾ Salvando em {DB_PATH.name}...")
        
        # Remove banco antigo se existir para recriar do zero
        if DB_PATH.exists():
            DB_PATH.unlink()
            
        con.execute(f"ATTACH '{str(DB_PATH)}' AS sqlite_db (TYPE SQLITE)")
        con.execute(f"CREATE TABLE sqlite_db.vendas AS {query}")
        
        # ValidaÃ§Ã£o
        count = con.execute("SELECT COUNT(*) FROM sqlite_db.vendas").fetchone()[0]
        print(f"\nâœ… Sucesso! {count:,} registros de vendas importados.")
        
        # Mostra prÃ©via
        print("\nğŸ“Š Amostra dos dados gravados:")
        print(con.execute("SELECT * FROM sqlite_db.vendas LIMIT 5").df())
        
    except Exception as e:
        print(f"\nâŒ Erro durante a importaÃ§Ã£o: {e}")
        print("Dica: Verifique se os nomes das colunas no CSV batem com a query.")
        
    finally:
        con.close()

if __name__ == "__main__":
    setup_database()
--------------------------------------------------------------------------------
END FILE: scripts/setup_database.py


START FILE: scripts/verificar_ambiente.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Adiciona o src ao path para poder importar os mÃ³dulos
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

# Configurar logger simples para o teste
structlog.configure(
    processors=[structlog.processors.JSONRenderer()],
)

def main():
    print("ğŸš€ Iniciando verificaÃ§Ã£o do ambiente...\n")
    
    # 1. Teste de ConfiguraÃ§Ã£o
    try:
        config_mgr = ConfigManager()
        config_mgr.load_configs(project_root / "config")
        print("âœ… ConfiguraÃ§Ãµes carregadas com sucesso!")
    except Exception as e:
        print(f"âŒ Erro ao carregar configuraÃ§Ãµes: {e}")
        return

    # 2. Teste de Banco de Dados
    sqlite_path = project_root / "data" / "vendas.db" 
    
    if not sqlite_path.exists():
        print(f"âš ï¸  Banco de dados nÃ£o encontrado em: {sqlite_path}")
    
    try:
        db = DuckDBManager()
        db.initialize(sqlite_path)
        
        with db.get_connection() as conn:
            # Verifica se a nova tabela existe
            print("â³ Verificando tabela 'saldo_custo_entrada'...")
            try:
                res = conn.execute("SELECT * FROM sqlite_db.saldo_custo_entrada LIMIT 3").pl()
                print("\nâœ… Tabela de Estoque encontrada no Banco de Dados!")
                print("\nğŸ“Š PrÃ©via dos Dados:")
                print(res)
            except Exception as e:
                print(f"\nâŒ Tabela 'saldo_custo_entrada' NÃƒO encontrada no banco! Erro: {e}")
                
    except Exception as e:
        print(f"âŒ Erro no DuckDB: {e}")

    print("\nğŸ VerificaÃ§Ã£o concluÃ­da.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/verificar_ambiente.py


START FILE: scripts/teste_giro.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl
from datetime import datetime, timedelta

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.core.config import ConfigManager # <--- Importante!

def main():
    print("\nğŸ›‘ --- VALIDADOR DE GIRO (FREIO DE MÃƒO v23.0) ---")
    print("Simule o cenÃ¡rio para ver se o sistema aprova ou bloqueia.\n")

    try:
        # Inputs Focados na Regra
        dias_vida = int(input("Dias de Vida do Item (ex: 400 para antigo, 30 para novo): "))
        venda_12m = int(input("Venda Total dos Ãšltimos 12 Meses: "))
        estoque_total = int(input("Estoque Atual + OC: "))
        sugestao = int(input("Quanto o sistema sugeriu comprar? "))
        
        # Datas simuladas
        hoje = datetime.now().date()
        data_cadastro = hoje - timedelta(days=dias_vida)
        
        # DataFrame Fake
        df = pl.DataFrame({
            "cod_produto": ["TESTE-GIRO"],
            "primeira_venda": [data_cadastro],
            "ultima_venda": [hoje],
            "venda_total_12m": [venda_12m],
            "saldo_estoque": [estoque_total],
            "saldo_oc": [0],
            "sugestao_final": [sugestao],
            "media_venda_dia": [venda_12m/365 if venda_12m > 0 else 0], 
            "estoque_seguranca": [0],
            "total_clientes_unicos": [5]
        })

        print("\nâš™ï¸  O Juiz estÃ¡ analisando...")
        
        # Carregar ConfiguraÃ§Ã£o REAL
        config_mgr = ConfigManager()
        config_mgr.load_configs(PROJECT_ROOT / "config")
        config = config_mgr.parametros
        
        # Executa APENAS o diagnÃ³stico
        df = EstoqueMath.gerar_diagnostico(df, config)
        
        res = df.row(0, named=True)
        
        print(f"\nâš–ï¸  VEREDITO DO SISTEMA:")
        print(f"-----------------------------------")
        print(f"Item Novo?           {'SIM' if dias_vida < 365 else 'NÃƒO'}")
        print(f"MÃ©dia Mensal (12m):  {res.get('media_mensal_real', venda_12m/12):.2f} peÃ§as/mÃªs")
        if 'cobertura_projetada' in res:
            print(f"Cobertura Projetada: {res['cobertura_projetada']:.1f} meses")
        print(f"-----------------------------------")
        print(f"DECISÃƒO FINAL:       {res['validacao_giro']}")
        
        if "Excesso" in res['validacao_giro']:
            print("ğŸ”´ O sistema BLOQUEOU a compra por excesso de cobertura.")
        elif "Sem Venda" in res['validacao_giro']:
            print("ğŸ”´ O sistema BLOQUEOU pois o item parece morto.")
        elif "COERENTE" in res['validacao_giro']:
            print("ğŸŸ¢ Compra APROVADA.")

    except Exception as e:
        print(f"\nâŒ Erro: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/teste_giro.py


START FILE: scripts/testar_analytics.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

# Setup de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.analytics_service import AnalyticsService

def main():
    print("--- ğŸ“Š TESTE DO SERVIÃ‡O DE ANALYTICS (CORRIGIDO) ---")
    
    # 1. ConexÃ£o
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    print(f"ğŸ“‚ Conectando ao banco: {db_path}")
    
    db = DuckDBManager()
    db.initialize(db_path)
    
    # --- DIAGNÃ“STICO DO BANCO DE DADOS ---
    print("\nğŸ” Verificando tabelas existentes no DuckDB:")
    with db.get_connection() as conn:
        tabelas = conn.execute("SHOW TABLES").fetchall()
        lista_tabelas = [t[0] for t in tabelas]
        print(f"   Tabelas encontradas: {lista_tabelas}")
        
        if "historico_snapshots" not in lista_tabelas:
            print("   âš ï¸ AVISO CRÃTICO: Tabela 'historico_snapshots' NÃƒO EXISTE.")
            print("   -> SoluÃ§Ã£o: Rode 'python scripts/gerar_relatorio_final.py' novamente para criar a tabela.")
        else:
            qtd = conn.execute("SELECT COUNT(*) FROM historico_snapshots").fetchone()[0]
            print(f"   âœ… Tabela 'historico_snapshots' existe com {qtd} registros.")

    service = AnalyticsService(db)
    
    # 2. Teste de KPIs Atuais
    print("\n1. Buscando KPIs Atuais...")
    kpis = service.get_kpis_atuais()
    print(f"   Resultado: {kpis}")
    
    # 3. Teste de TendÃªncia (GrÃ¡fico)
    print("\n2. Buscando TendÃªncia de Cobertura (HistÃ³rico)...")
    
    # CORREÃ‡ÃƒO AQUI: O parÃ¢metro correto Ã© 'dias_historico', nÃ£o 'dias'
    df_tendencia = service.get_tendencia_cobertura(dias_historico=30)
    
    if df_tendencia.is_empty():
        print("âš ï¸ DataFrame vazio! O serviÃ§o rodou, mas nÃ£o achou dados no perÃ­odo.")
    else:
        print(f"âœ… Sucesso! Retornou {len(df_tendencia)} linhas.")
        print(df_tendencia)
        
        print("\n--- PrÃ©via dos Dados para o GrÃ¡fico ---")
        for row in df_tendencia.iter_rows(named=True):
            print(f"Data: {row['data']} | Curva: {row['curva_abc']} | Cobertura: {row['cobertura_meses']} meses")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/testar_analytics.py


START FILE: scripts/debug_item.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    cod_alvo = input("Digite o cÃ³digo do produto problemÃ¡tico: ")
    
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    conn = duckdb.connect()
    conn.execute("INSTALL sqlite; LOAD sqlite;")
    conn.execute(f"ATTACH '{db_path}' AS sqlite_db (TYPE SQLITE)")
    
    print(f"\nğŸ” INVESTIGANDO O ITEM: {cod_alvo}")
    print("-" * 50)
    
    # 1. Vendas Totais da HistÃ³ria
    total_hist = conn.execute(f"""
        SELECT SUM(quantidade), MIN(data_movimento), MAX(data_movimento) 
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
    """).fetchone()
    print(f"HistÃ³rico Completo: {total_hist[0]} peÃ§as vendidas de {total_hist[1]} atÃ© {total_hist[2]}")
    
    # 2. Vendas nos Ãšltimos 12 Meses (O que importa para o cÃ¡lculo)
    venda_12m = conn.execute(f"""
        SELECT SUM(quantidade)
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
        AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
    """).fetchone()[0]
    
    venda_12m = venda_12m if venda_12m else 0
    media_calc = venda_12m / 365.0
    
    print(f"Venda Ãšltimos 365 dias: {venda_12m} peÃ§as")
    print(f"MÃ©dia DiÃ¡ria Real (Total/365): {media_calc:.4f}")
    print("-" * 50)
    
    if venda_12m == 0:
        print("âœ… DIAGNÃ“STICO: O item estÃ¡ MORTO (0 vendas em 1 ano).")
        print("A mÃ©dia DEVE ser 0.00.")
    else:
        print("âš ï¸ DIAGNÃ“STICO: Existem vendas ocultas nos Ãºltimos 12 meses.")
        # Mostra as vendas fantasmas
        print("\nğŸ“… Detalhe das vendas encontradas (Ãºltimos 12 meses):")
        detalhe = conn.execute(f"""
            SELECT data_movimento, quantidade 
            FROM sqlite_db.vendas 
            WHERE cod_produto = '{cod_alvo}'
            AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            ORDER BY data_movimento DESC
        """).df()
        print(detalhe)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/debug_item.py


START FILE: scripts/test_abc.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Setup de paths
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier

# ConfiguraÃ§Ã£o de Logs
structlog.configure(processors=[structlog.processors.JSONRenderer()])

def main():
    print("ğŸš€ Testando Curva ABC Financeira...")
    
    # 1. Inicializar Banco
    sqlite_path = PROJECT_ROOT / "data" / "vendas.db"
    csv_path = PROJECT_ROOT / "data" / "Saldo Estoque OC Custo Ultima Entrada Spaal.csv"
    
    db = DuckDBManager()
    db.initialize(sqlite_path, csv_path)
    
    try:
        # 2. Executar Classificador
        classifier = ABCClassifier(db)
        df_abc = classifier.run()
        
        # 3. Mostrar Resultados
        print(f"\nâœ… Sucesso! Classificamos {len(df_abc)} produtos.")
        
        print("\nğŸ“Š Resumo da ClassificaÃ§Ã£o:")
        resumo = df_abc.group_by("curva_abc").len().sort("curva_abc")
        print(resumo)
        
        print("\nğŸ† Top 5 Produtos Curva A:")
        print(df_abc.filter(df_abc["curva_abc"] == "A").head(5))

    except Exception as e:
        print(f"\nâŒ Erro: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/test_abc.py


START FILE: scripts/calcular_sazonalidade.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    print("ğŸŒŠ Calculando Ãndices de Sazonalidade...")
    
    # Caminhos dos arquivos
    sqlite_path = PROJECT_ROOT / "data" / "vendas.db"
    
    # Usaremos um arquivo DuckDB persistente para salvar os Ã­ndices
    # Assim o outro script consegue ler depois
    duck_path = PROJECT_ROOT / "data" / "analytics.duckdb"
    
    # Conecta (ou cria) o banco analÃ­tico
    conn = duckdb.connect(str(duck_path))
    
    try:
        # 1. Instala suporte a SQLite (caso nÃ£o tenha)
        conn.execute("INSTALL sqlite; LOAD sqlite;")
        
        # 2. Anexa o banco de vendas (O PULO DO GATO QUE FALTAVA)
        # Agora o DuckDB enxerga o 'sqlite_db'
        print(f"ğŸ”Œ Conectando ao histÃ³rico: {sqlite_path}")
        conn.execute(f"ATTACH '{sqlite_path}' AS sqlite_db (TYPE SQLITE)")
        
        # 3. Cria tabela de Ã­ndices
        print("ğŸ“Š Processando estatÃ­sticas mensais...")
        conn.execute("""
            CREATE OR REPLACE TABLE indices_sazonais AS
            WITH vendas_mensais AS (
                SELECT 
                    EXTRACT(MONTH FROM CAST(data_movimento AS DATE)) as mes,
                    SUM(quantidade) as qtd_total
                FROM sqlite_db.vendas
                WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '24 months')
                GROUP BY 1
            ),
            media_global AS (
                SELECT AVG(qtd_total) as media_ano FROM vendas_mensais
            )
            SELECT 
                mes,
                qtd_total / media_global.media_ano as indice_sazonal
            FROM vendas_mensais, media_global
            ORDER BY mes;
        """)
        
        print("âœ… Ãndices calculados e salvos em 'analytics.duckdb':")
        print(conn.execute("SELECT * FROM indices_sazonais").df())
        
    except Exception as e:
        print(f"âŒ Erro: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/calcular_sazonalidade.py


START FILE: scripts/inspect_db.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path

# Caminhos
BASE_DIR = Path(__file__).parent.parent
DB_PATH = BASE_DIR / "data" / "vendas.db"

def inspect():
    print(f"ğŸ” Inspecionando banco de dados: {DB_PATH}")
    
    if not DB_PATH.exists():
        print("âŒ ERRO: O arquivo 'vendas.db' nÃ£o foi encontrado na pasta 'data/'")
        return

    try:
        con = duckdb.connect(":memory:")
        con.execute(f"ATTACH '{str(DB_PATH)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
        
        # Verifica tabela
        print("\nğŸ“‹ Estrutura da tabela 'vendas':")
        print(f"{'Nome da Coluna':<25} | {'Tipo de Dado'}")
        print("-" * 45)
        
        # CORREÃ‡ÃƒO: Usamos fetchall() (listas nativas) em vez de .df()
        columns = con.execute("DESCRIBE sqlite_db.vendas").fetchall()
        
        for col in columns:
            name = col[0]
            dtype = col[1]
            print(f"{name:<25} | {dtype}")

        print("\nğŸ“Š Amostra de dados (Via Polars):")
        # Aqui usamos .pl() porque o Polars jÃ¡ estÃ¡ instalado e testado
        print(con.execute("SELECT * FROM sqlite_db.vendas LIMIT 3").pl())

    except Exception as e:
        print(f"âŒ Erro ao ler o banco: {e}")

if __name__ == "__main__":
    inspect()

--------------------------------------------------------------------------------
END FILE: scripts/inspect_db.py


START FILE: .pytest_cache/README.md
--------------------------------------------------------------------------------
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

--------------------------------------------------------------------------------
END FILE: .pytest_cache/README.md


START FILE: backups/antes_melhorias/gerar_relatorio_final.py
--------------------------------------------------------------------------------
codigo_relatorio = '''"""
Script principal de geraÃ§Ã£o de relatÃ³rios - VERSÃƒO MELHORADA
Aplica sazonalidade preservando mÃ©dia base
"""
import sys
import argparse
import json
from pathlib import Path
from datetime import datetime
import polars as pl
import traceback

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.core.config import ConfigManager
from compras_sistema.core.system_guard import SystemGuard
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.history_recorder import HistoryRecorder
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.classification.trend_classifier import TrendClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.export.excel_exporter import ExcelExporter


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--marca", type=str, default="TODAS", help="Filtrar por marca")
    parser.add_argument("--simulacao", action="store_true", help="NÃ£o gera Excel, apenas calcula")
    args = parser.parse_args()
    
    guard = SystemGuard(PROJECT_ROOT / "logs")
    print(f"--- LOG START ---")
    guard.log(f"Processamento Iniciado - Marca: {args.marca}")
    
    # InicializaÃ§Ã£o
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")
    
    recorder = HistoryRecorder(db) if not args.simulacao else None
    if recorder:
        recorder.inicializar_tabela()
    
    try:
        # --- 1. CLASSIFICAÃ‡Ã•ES ESTATÃSTICAS ---
        guard.log("Calculando ClassificaÃ§Ãµes ABC, XYZ, TendÃªncias...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        trend_engine = TrendClassifier(db)
        
        df_abc = abc_engine.run()
        df_xyz = xyz_engine.run()
        df_trend = trend_engine.run()
        
        # --- 2. LEITURA DE DADOS ---
        guard.log("Lendo Estoques e Cadastro Completo...")
        with db.get_connection() as conn:
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto,
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
            """).pl()
            
            # Leitura dinÃ¢mica do cadastro
            try:
                cols_db = [c[1] for c in conn.execute("PRAGMA table_info(sqlite_db.produtos_gerais)").fetchall()]
                
                if "descricao_produto" in cols_db:
                    col_desc = "descricao_produto"
                elif "descricao" in cols_db:
                    col_desc = "descricao"
                else:
                    col_desc = "''" 
                
                col_data = "CAST(data_cadastro AS DATE)" if "data_cadastro" in cols_db else "CAST('2000-01-01' AS DATE)"
                col_ref = "ref_fornecedor" if "ref_fornecedor" in cols_db else "''"
                
                df_cadastro = conn.execute(f"""
                    SELECT 
                        CAST(cod_produto AS VARCHAR) as cod_produto,
                        CAST(qtd_economica AS INTEGER) as lote_economico,
                        marca,
                        {col_desc} as descricao,
                        {col_ref} as ref_fornecedor,
                        ativo,
                        {col_data} as data_cadastro
                    FROM sqlite_db.produtos_gerais
                """).pl()
            except Exception as e:
                guard.log(f"Erro ao ler cadastro: {e}. Usando estrutura vazia de seguranÃ§a.")
                df_cadastro = pl.DataFrame(schema={
                    "cod_produto": pl.Utf8, "lote_economico": pl.Int64, "marca": pl.Utf8,
                    "descricao": pl.Utf8, "ref_fornecedor": pl.Utf8, "ativo": pl.Utf8,
                    "data_cadastro": pl.Date
                })
        
        # Carrega Sazonalidade
        indices_dict = {}
        try:
            analytics_path = PROJECT_ROOT / "data" / "analytics.duckdb"
            if analytics_path.exists():
                conn.execute(f"ATTACH '{analytics_path}' AS analytics")
                rows = conn.execute("SELECT mes, indice_sazonal FROM analytics.indices_sazonais").fetchall()
                for r in rows:
                    indices_dict[r[0]] = r[1]
        except:
            pass
        
        # --- 3. UNIFICAÃ‡ÃƒO (JOIN) ---
        guard.log("Cruzando dados...")
        df_universe = pl.concat([
            df_xyz.select("cod_produto"),
            df_saldo.select("cod_produto"),
            df_cadastro.select("cod_produto")
        ]).unique(subset="cod_produto")
        
        df_final = df_universe \\
            .join(df_xyz, on="cod_produto", how="left") \\
            .join(df_abc, on="cod_produto", how="left") \\
            .join(df_trend, on="cod_produto", how="left") \\
            .join(df_saldo, on="cod_produto", how="left") \\
            .join(df_cadastro, on="cod_produto", how="left")
        
        # Tratamento de descriÃ§Ã£o duplicada
        if "descricao" not in df_final.columns:
            if "descricao_right" in df_final.columns:
                df_final = df_final.rename({"descricao_right": "descricao"})
            else:
                df_final = df_final.with_columns(pl.lit("SEM DESCRIÃ‡ÃƒO").alias("descricao"))
        
        # Preenchimento de Nulos
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").fill_null(0.0),
            pl.col("std_venda_dia").fill_null(0.0),
            pl.col("curva_xyz").fill_null("Z"),
            pl.col("dias_sem_venda").fill_null(0).alias("dias_sem_venda"),
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            pl.col("custo_unitario").fill_null(0.0),
            pl.col("curva_abc").fill_null("C"),
            pl.col("marca").fill_null("N/D"),
            pl.col("descricao").fill_null("DESCRIÃ‡ÃƒO NÃƒO ENCONTRADA"),
            pl.col("ref_fornecedor").fill_null(""),
            pl.col("lote_economico").fill_null(1),
            pl.col("ativo").fill_null("SIM"),
            pl.col("data_cadastro").fill_null(pl.lit(datetime(2000,1,1))),
            pl.lit(config_mgr.parametros.lead_time.padrao_dias).alias("lead_time_dias"),
        ])
        
        # --- 4. MOTOR DE CÃLCULO (COM MELHORIAS) ---
        guard.log("Executando Motor MatemÃ¡tico...")
        
        # MELHORIA 1: Salva mÃ©dia base ANTES da sazonalidade
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").alias("media_venda_base")
        ])
        
        # Aplica sazonalidade
        df_final = EstoqueMath.aplicar_sazonalidade_projetada(df_final, indices_dict)
        
        # MELHORIA 2: Aplica sazonalidade SEM sobrescrever a base
        df_final = df_final.with_columns([
            pl.col("fator_sazonal_projetado").alias("fator_sazonal"),
            (pl.col("media_venda_base") * pl.col("fator_sazonal_projetado")).alias("media_venda_dia")
        ])
        
        # Continua com os cÃ¡lculos
        df_final = EstoqueMath.calcular_tendencias(df_final)
        df_final = EstoqueMath.calcular_seguranca(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_necessidades(df_final, config_mgr.parametros)
        df_final = EstoqueMath.aplicar_lote_economico(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_score(df_final)
        df_final = EstoqueMath.gerar_diagnostico(df_final, config_mgr.parametros)
        
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") + pl.col("saldo_oc") + pl.col("sugestao_final")).alias("meta_pos_compra")
        ])
        
        # --- 5. FILTRO DE MARCA ---
        if args.marca and args.marca != "TODAS":
            guard.log(f"Filtrando relatÃ³rio para marca: {args.marca}")
            df_final = df_final.filter(pl.col("marca") == args.marca)
        
        # --- 6. ESTATÃSTICAS PARA GUI ---
        try:
            val_estoque_atual = df_final.select((pl.col("saldo_estoque") * pl.col("custo_unitario")).sum()).item()
            val_venda_mensal = df_final.select((pl.col("media_venda_dia") * 30 * pl.col("custo_unitario")).sum()).item()
            
            if val_venda_mensal > 0:
                cobertura = val_estoque_atual / val_venda_mensal
            else:
                cobertura = 0.0
        except:
            val_estoque_atual = 0.0
            cobertura = 0.0
        
        df_compra = df_final.filter(pl.col("sugestao_final") > 0)
        
        stats = {
            "total_valor": df_compra["subtotal"].sum(),
            "total_skus": len(df_compra),
            "total_pecas": df_compra["sugestao_final"].sum(),
            "estoque_atual": val_estoque_atual,
            "cobertura_meses": cobertura
        }
        
        print(f"STATS_DATA={json.dumps(stats)}")
        
        # --- 7. EXPORTAÃ‡ÃƒO ---
        if not args.simulacao:
            guard.log("Gerando relatÃ³rio Excel...")
            exporter = ExcelExporter(PROJECT_ROOT / "data" / "exports")
            arquivo = exporter.exportar_sugestao(df_final.sort("score", descending=True))
            guard.log(f"RelatÃ³rio gerado: {arquivo}")
            
            if recorder:
                recorder.gravar_snapshot(df_final)
        
        guard.log("Processamento concluÃ­do com sucesso!")
        
    except Exception as e:
        guard.log(f"ERRO CRÃTICO: {e}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        db.close()


if __name__ == "__main__":
    main()
'''

print("\nâœ… Arquivo gerar_relatorio_final.py melhorado criado!")
print("\nğŸ“‹ MUDANÃ‡AS NO FLUXO:")
print("1. âœ… Salva 'media_venda_base' ANTES da sazonalidade")
print("2. âœ… Aplica sazonalidade criando nova coluna ao invÃ©s de sobrescrever")
print("3. âœ… Fluxo agora tem auditoria completa de valores intermediÃ¡rios")

--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/gerar_relatorio_final.py


START FILE: backups/antes_melhorias/excel_exporter.py
--------------------------------------------------------------------------------
codigo_excel = '''"""
Exportador de Excel com formataÃ§Ã£o profissional - VERSÃƒO MELHORADA
Adiciona novas colunas para auditoria
"""
import polars as pl
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)


class ExcelExporter:
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def exportar_sugestao(self, df: pl.DataFrame, filename: str = None):
        if filename is None:
            data_hoje = datetime.now().strftime("%Y%m%d_%H%M")
            filename = f"sugestao_compras_{data_hoje}.xlsx"
        
        filepath = self.output_dir / filename
        logger.info("iniciando_export_excel", path=str(filepath))
        
        # ======== ORDEM DAS COLUNAS (COM NOVAS) ========
        cols_export = [
            "status_diagnostico",
            "cod_produto",
            "descricao",
            "ref_fornecedor",
            "marca",
            "curva_abc",
            "curva_xyz",
            "sugestao_final",
            "sugestao_calculada",  # NOVA: Antes do bloqueio
            "calculado_mas_bloqueado",  # NOVA: Flag
            "motivo_bloqueio",  # NOVA: RazÃ£o do bloqueio
            "meta_pos_compra",
            "fator_sazonal",
            "lote_economico",
            "subtotal",
            "saldo_estoque",
            "saldo_oc",
            "cobertura_virtual_meses",
            "media_venda_base",  # NOVA: Sem sazonalidade
            "media_venda_dia",  # Ajustada
            "tendencia_vendas",
            "tendencia_clientes",
            "perfil_cliente",
            "validacao_giro",
            "custo_unitario",
            "score"
        ]
        
        cols_presentes = [c for c in cols_export if c in df.columns]
        records = df.select(cols_presentes).to_dicts()
        
        # ======== CRIAÃ‡ÃƒO DO EXCEL ========
        wb = Workbook()
        ws = wb.active
        ws.title = "Analise Compras"
        
        # Estilos
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        center_align = Alignment(horizontal="center")
        left_align = Alignment(horizontal="left")
        thin_border = Border(
            left=Side(style="thin"), right=Side(style="thin"),
            top=Side(style="thin"), bottom=Side(style="thin")
        )
        
        fill_green = PatternFill(start_color="CCFFCC", fill_type="solid")
        fill_yellow = PatternFill(start_color="FFFFE0", fill_type="solid")
        fill_orange = PatternFill(start_color="FFD700", fill_type="solid")
        fill_blue_light = PatternFill(start_color="E6F3FF", fill_type="solid")
        fill_implanta = PatternFill(start_color="E0FFFF", fill_type="solid")
        fill_red = PatternFill(start_color="FFB6C1", fill_type="solid")  # NOVA: Para bloqueados
        
        # Mapeamento de nomes amigÃ¡veis
        mapa_nomes = {
            "META_POS_COMPRA": "POSIÃ‡ÃƒO FINAL",
            "FATOR_SAZONAL": "IDX SAZONAL",
            "MEDIA_VENDA_DIA": "GIRO DIA (AJUST)",
            "MEDIA_VENDA_BASE": "GIRO DIA (BASE)",  # NOVO
            "COBERTURA_VIRTUAL_MESES": "COBERTURA MESES",
            "REF_FORNECEDOR": "REF. FABRICA",
            "SUGESTAO_CALCULADA": "CALC. ORIGINAL",  # NOVO
            "CALCULADO_MAS_BLOQUEADO": "BLOQUEADO?",  # NOVO
            "MOTIVO_BLOQUEIO": "MOTIVO"  # NOVO
        }
        
        headers = [c.replace("_", " ").upper() for c in cols_presentes]
        headers = [mapa_nomes.get(h, h) for h in headers]
        
        ws.append(headers)
        
        # Formata cabeÃ§alho
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_align
        
        # Preenche dados
        for row_idx, row_data in enumerate(records, 2):
            for col_idx, col_name in enumerate(cols_presentes, 1):
                val = row_data[col_name]
                cell = ws.cell(row=row_idx, column=col_idx, value=val)
                cell.border = thin_border
                
                # Alinhamento
                if col_name == "descricao":
                    cell.alignment = left_align
                else:
                    cell.alignment = center_align
                
                # FormataÃ§Ã£o numÃ©rica
                if col_name in ["custo_unitario", "subtotal"]:
                    cell.number_format = 'R$ #,##0.00'
                elif col_name in ["media_venda_dia", "media_venda_base", "fator_sazonal"]:
                    cell.number_format = '0.00'
                elif col_name in ["cobertura_virtual_meses"]:
                    cell.number_format = '0.0'
                elif col_name == "score":
                    cell.number_format = '#,##0'
                
                # ======== FORMATAÃ‡ÃƒO CONDICIONAL ========
                
                # SugestÃµes de compra
                if col_name in ["sugestao_final", "subtotal"] and row_data.get("sugestao_final", 0) > 0:
                    cell.font = Font(bold=True, color="006400")
                    cell.fill = fill_green
                
                # NOVA: Destaque para produtos bloqueados
                if col_name == "calculado_mas_bloqueado" and val == "SIM":
                    cell.fill = fill_red
                    cell.font = Font(bold=True, color="8B0000")
                
                # NOVA: Motivo do bloqueio em vermelho
                if col_name == "motivo_bloqueio" and val:
                    cell.font = Font(color="DC143C", italic=True)
                
                # Fator sazonal
                if col_name == "fator_sazonal":
                    if isinstance(val, (int, float)):
                        if val < 0.90:
                            cell.font = Font(color="0000FF")
                            cell.fill = fill_blue_light
                        elif val > 1.10:
                            cell.font = Font(color="B22222", bold=True)
                
                # Status diagnÃ³stico
                if col_name == "status_diagnostico":
                    val_str = str(val).upper()
                    if "IMPLANTAÃ‡ÃƒO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "RUPTURA" in val_str:
                        cell.fill = PatternFill(start_color="FF0000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "BLOQUEADO" in val_str:
                        cell.fill = PatternFill(start_color="808080", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "INATIVO" in val_str:
                        cell.fill = PatternFill(start_color="000000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "ALERTA" in val_str:
                        cell.fill = PatternFill(start_color="FF8C00", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "EXCESSO" in val_str:
                        cell.fill = fill_yellow
                    elif "COMPRAR" in val_str:
                        cell.fill = fill_green
                
                # TendÃªncia vendas
                if col_name == "tendencia_vendas":
                    val_str = str(val).upper()
                    if "ALTA" in val_str:
                        cell.font = Font(color="006400", bold=True)
                    elif "QUEDA" in val_str:
                        cell.font = Font(color="FF0000", bold=True)
                
                # ValidaÃ§Ã£o de giro
                if col_name == "validacao_giro":
                    val_str = str(val)
                    if "ITEM NOVO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "SEM MOVIMENTO" in val_str:
                        cell.font = Font(color="808080", italic=True)
                    elif "Excesso" in val_str:
                        cell.font = Font(bold=True, color="B22222")
                        cell.fill = fill_orange
        
        # Auto-ajuste de largura
        for col_idx, column_cells in enumerate(ws.columns, 1):
            max_length = 0
            column = get_column_letter(col_idx)
            limit = 60 if cols_presentes[col_idx-1] == "descricao" else 40
            
            for cell in column_cells:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            ws.column_dimensions[column].width = min(max_length + 3, limit)
        
        wb.save(filepath)
        logger.info("export_excel_concluido")
        return filepath
'''

print("\nâœ… Arquivo excel_exporter.py melhorado criado!")
print("\nğŸ“‹ NOVAS COLUNAS NO EXCEL:")
print("1. âœ… MEDIA_VENDA_BASE (GIRO DIA BASE) - Sem ajuste sazonal")
print("2. âœ… SUGESTAO_CALCULADA - Valor antes do bloqueio")
print("3. âœ… CALCULADO_MAS_BLOQUEADO - Flag SIM/NÃƒO")
print("4. âœ… MOTIVO_BLOQUEIO - RazÃ£o especÃ­fica do bloqueio")
print("5. âœ… FormataÃ§Ã£o condicional para produtos bloqueados (vermelho)")
--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/excel_exporter.py


START FILE: backups/antes_melhorias/estoque_math.py
--------------------------------------------------------------------------------
# Vou criar o arquivo estoque_math.py melhorado

codigo_estoque_math = '''"""
MÃ³dulo de cÃ¡lculos matemÃ¡ticos de estoque - VERSÃƒO MELHORADA
Implementa lÃ³gica de reposiÃ§Ã£o com validaÃ§Ãµes aprimoradas
"""
import polars as pl
import numpy as np
from datetime import datetime


class EstoqueMath:
    """Classe com mÃ©todos estÃ¡ticos para cÃ¡lculos de estoque"""
    
    @staticmethod
    def aplicar_sazonalidade_projetada(df: pl.DataFrame, indices_dict: dict) -> pl.DataFrame:
        """
        Calcula o fator sazonal baseando-se na DATA DE CHEGADA da mercadoria.
        MELHORIA: Preserva media_venda_base antes de aplicar sazonalidade
        """
        if not indices_dict or len(indices_dict) != 12:
            return df.with_columns(pl.lit(1.0).alias("fator_sazonal_projetado"))
        
        lista_indices = [indices_dict.get(m, 1.0) for m in range(1, 13)]
        mes_atual = datetime.now().month
        
        def calcular_fator_futuro(leadtime):
            if leadtime is None:
                leadtime = 7
            
            meses_espera = leadtime / 30.0
            duracao_estoque = 1.5
            soma_indices = 0.0
            pontos_verificados = 0
            cursor = meses_espera
            fim_janela = meses_espera + duracao_estoque
            
            while cursor < fim_janela:
                mes_futuro_absoluto = mes_atual + int(cursor)
                index_lista = (mes_futuro_absoluto - 1) % 12
                soma_indices += lista_indices[index_lista]
                pontos_verificados += 1
                cursor += 0.5
            
            if pontos_verificados == 0:
                return 1.0
            
            fator = soma_indices / pontos_verificados
            return max(0.5, min(fator, 2.5))
        
        return df.with_columns([
            pl.col("lead_time_dias").map_elements(
                calcular_fator_futuro, return_dtype=pl.Float64
            ).alias("fator_sazonal_projetado")
        ])

    @staticmethod
    def calcular_tendencias(df: pl.DataFrame) -> pl.DataFrame:
        """
        Calcula as classificaÃ§Ãµes de TendÃªncia e Perfil de Cliente.
        Trata valores nulos como zero para evitar erro de classificaÃ§Ã£o.
        """
        if "var_vendas" not in df.columns:
            df = df.with_columns([
                pl.lit(0.0).alias("var_vendas"),
                pl.lit(0).alias("saldo_clientes"),
                pl.lit(0).alias("qtd_clientes_ativos")
            ])
        
        return df.with_columns([
            # 1. TENDÃŠNCIA VENDAS
            pl.when(pl.col("var_vendas").fill_null(0.0) > 0.20).then(pl.lit("EM ALTA"))
            .when(pl.col("var_vendas").fill_null(0.0) < -0.20).then(pl.lit("EM QUEDA"))
            .otherwise(pl.lit("ESTÃVEL")).alias("tendencia_vendas"),
            
            # 2. TENDÃŠNCIA CLIENTES
            pl.when(pl.col("saldo_clientes").fill_null(0) > 0)
            .then(pl.format("GANHO +{}", pl.col("saldo_clientes")))
            .when(pl.col("saldo_clientes").fill_null(0) < 0)
            .then(pl.format("PERDA {}", pl.col("saldo_clientes")))
            .otherwise(pl.lit("MANTEVE")).alias("tendencia_clientes"),
            
            # 3. PERFIL CLIENTE
            pl.when(pl.col("qtd_clientes_ativos").fill_null(0) == 0).then(pl.lit("Sem Venda"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 2).then(pl.lit("Dedicado (1-2)"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 9).then(pl.lit("Concentrado (3-9)"))
            .otherwise(pl.lit("Pulverizado (10+)")).alias("perfil_cliente")
        ])

    @staticmethod
    def calcular_seguranca(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Estoque de Seguran com proteo contra Lead Time Nulo."""
        def get_z_factor(xyz):
            if xyz == "X":
                return 1.65
            if xyz == "Y":
                return 1.28
            return 0.84
        
        return df.with_columns([
            pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64).alias("fator_z"),
            (
                pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64) *
                pl.col("std_venda_dia") *
                pl.col("lead_time_dias").fill_null(7).sqrt()
            ).fill_null(0).alias("estoque_seguranca")
        ])

    @staticmethod
    def calcular_necessidades(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Calcula Ponto de Suprimento e Estoque Meta
        MELHORIA: Valida dias_vida ANTES de aplicar boost anti-ruptura
        """
        meses_cobertura = config.compras.meses_cobertura
        dias_novo = config.produto.dias_lancamento  # Normalmente 60
        
        # MELHORIA 1: Calcula dias_vida ANTES do boost
        df = df.with_columns([
            (pl.lit(datetime.now()) - pl.col("data_cadastro").dt.total_days()).alias("dias_vida")
        ])
        
        # MELHORIA 2: Boost anti-ruptura apenas para itens VELHOS
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                pl.col("curva_abc").is_in(["A", "B"]) &
                (pl.col("dias_vida") > dias_novo)  # <-- NOVA CONDIÃ‡ÃƒO
            )
            .then(
                pl.when(pl.col("dias_sem_venda") > 30).then(pl.col("media_venda_dia") * 1.20)
                .when(pl.col("dias_sem_venda") > 90).then(pl.col("media_venda_dia") * 1.50)
                .otherwise(pl.col("media_venda_dia") * 2.00)
            )
            .otherwise(pl.col("media_venda_dia"))
            .alias("media_calculo")
        ])
        
        return df.with_columns([
            (pl.col("media_calculo") * pl.col("lead_time_dias") + pl.col("estoque_seguranca")).round(0).alias("ponto_suprimento"),
            (pl.col("media_calculo") * 30 * meses_cobertura + pl.col("estoque_seguranca")).round(0).alias("estoque_meta")
        ]).with_columns([
            (pl.col("estoque_meta") - pl.col("saldo_estoque") - pl.col("saldo_oc")).alias("sugestao_bruta")
        ])

    @staticmethod
    def aplicar_lote_economico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Arredonda para lotes econÃ´micos"""
        return df.with_columns([
            pl.when(pl.col("sugestao_bruta") <= 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("necessidade_liquida")
        ]).with_columns([
            (pl.col("necessidade_liquida") / pl.col("lote_economico")).ceil().alias("lotes_cheios")
        ]).with_columns([
            (pl.col("lotes_cheios") * pl.col("lote_economico")).cast(pl.Int32).alias("sugestao_final")
        ]).with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal")
        ])

    @staticmethod
    def calcular_score(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula pontuaÃ§Ã£o inicial de prioridade"""
        return df.with_columns([
            (
                pl.when(pl.col("saldo_estoque") == 0).then(5000).otherwise(0) +
                pl.when(pl.col("saldo_estoque") < pl.col("media_venda_dia") * pl.col("lead_time_dias")).then(2500).otherwise(0) +
                pl.when(pl.col("curva_abc") == "A").then(1000).when(pl.col("curva_abc") == "B").then(500).otherwise(100) +
                pl.when(pl.col("tendencia_vendas") == "EM ALTA").then(500).otherwise(0) +
                (pl.col("media_venda_dia") * pl.col("custo_unitario")).fill_null(0)
            ).round(0).cast(pl.Int32).alias("score")
        ])

    @staticmethod
    def gerar_diagnostico(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Gera diagnÃ³sticos e aplica a lÃ³gica de ITEM NOVO (ImplantaÃ§Ã£o)
        MELHORIAS:
        - Adiciona motivo_bloqueio
        - Adiciona calculado_mas_bloqueado
        - Recalcula score apÃ³s bloqueios
        """
        estoque_total = pl.col("saldo_estoque") + pl.col("saldo_oc")
        venda_mensal = pl.col("media_venda_dia") * 30
        dias_novo = config.produto.dias_lancamento
        
        # Calcula dias_vida se ainda nÃ£o existir
        if "dias_vida" not in df.columns:
            df = df.with_columns([
                (pl.lit(datetime.now()) - pl.col("data_cadastro").dt.total_days()).alias("dias_vida")
            ])
        
        # CÃ¡lculo de Cobertura
        base_calc = pl.when(estoque_total == 0).then(0.0).otherwise(estoque_total / venda_mensal)
        calc_cobertura = pl.when(base_calc.is_infinite()).then(99.0).otherwise(base_calc).fill_nan(99.0)
        
        df = df.with_columns([calc_cobertura.alias("cobertura_virtual_meses")])
        
        # 1. VALIDAÃ‡ÃƒO DE GIRO (O Juiz)
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                (pl.col("saldo_oc") == 0) &
                (pl.col("media_venda_dia") == 0)
            )
            .then(
                pl.when(pl.col("dias_vida") <= dias_novo)
                .then(pl.lit("SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)"))
                .otherwise(pl.lit("SEM MOVIMENTO (Item velho parado)"))
            )
            .when(pl.col("cobertura_virtual_meses") > 6).then(pl.lit("ALERTA: Excesso > 6m"))
            .when((pl.col("media_venda_dia") < 0.05) & (pl.col("sugestao_final") > 0)).then(pl.lit("ALERTA: Sem Venda Recente"))
            .otherwise(pl.lit("COERENTE")).alias("validacao_giro")
        ])
        
        # MELHORIA: Salva sugestÃ£o original antes do bloqueio
        df = df.with_columns([
            pl.col("sugestao_final").alias("sugestao_calculada")
        ])
        
        # 2. APLICA BLOQUEIOS E DEFINE MOTIVO
        df = df.with_columns([
            # Define motivo do bloqueio
            pl.when(pl.col("ativo") == "NO").then(pl.lit("Produto inativo no cadastro"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.col("validacao_giro"))
            .otherwise(pl.lit("")).alias("motivo_bloqueio"),
            
            # Flag: Foi calculado mas bloqueado?
            pl.when(
                (pl.col("sugestao_final") > 0) &
                ((pl.col("ativo") == "NO") | pl.col("validacao_giro").str.contains("ALERTA"))
            ).then(pl.lit("SIM")).otherwise(pl.lit("NÃƒO")).alias("calculado_mas_bloqueado"),
            
            # Aplica bloqueio na sugestÃ£o
            pl.when(pl.col("ativo") == "NO").then(0)
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)")
            .then(pl.col("lote_economico"))  # Item novo = 1 lote
            .otherwise(pl.col("sugestao_final")).alias("sugestao_final")
        ])
        
        # MELHORIA 3: RECALCULA SCORE APÃ“S BLOQUEIOS
        df = df.with_columns([
            pl.when(pl.col("sugestao_final") == 0).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit(9999))
            .otherwise(pl.col("score")).alias("score")
        ])
        
        # 4. STATUS DIAGNÃ“STICO FINAL
        df = df.with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal"),
            
            pl.when(pl.col("ativo") == "NO").then(pl.lit("INATIVO"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.lit("BLOQUEADO"))
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit("IMPLANTAÃ‡ÃƒO"))
            .when(pl.col("saldo_estoque") == 0).then(pl.lit("RUPTURA"))
            .when(pl.col("sugestao_final") > 0).then(pl.lit("COMPRAR"))
            .when(pl.col("cobertura_virtual_meses") > 12).then(pl.lit("EXCESSO"))
            .otherwise(pl.lit("OK")).alias("status_diagnostico")
        ])
        
        return df
'''

print("âœ… Arquivo estoque_math.py melhorado criado!")
print("\nğŸ“‹ MELHORIAS IMPLEMENTADAS:")
print("1. âœ… media_venda_base preservada (nÃ£o sobrescrita pela sazonalidade)")
print("2. âœ… ValidaÃ§Ã£o dias_vida ANTES do boost anti-ruptura")
print("3. âœ… Coluna 'motivo_bloqueio' adicionada")
print("4. âœ… Coluna 'calculado_mas_bloqueado' adicionada")
print("5. âœ… Score recalculado apÃ³s bloqueios")
print("6. âœ… Coluna 'sugestao_calculada' salva antes dos bloqueios")

--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/estoque_math.py


START FILE: config/parametros.yaml
--------------------------------------------------------------------------------
abc:
  A: 0.8
  B: 0.95
compras:
  meses_cobertura: 1.5
giro:
  limite_meses_cobertura: 6
historico:
  meses_analise: 36
  meses_tendencia: 6
lead_time:
  desvio_padrao: 2.0
  padrao_dias: 10
lote:
  limite_virada: 0.5
  minima_absoluta: 1
outlier:
  fator_multiplicador: 2.0
produto:
  dias_lancamento: 180
  dias_sem_entrada_obsoleto: 365
  dias_sem_venda_obsoleto: 180
risco:
  clientes_dependencia_alerta_A: 5
  clientes_dependencia_alerta_B: 2
  clientes_dependencia_total_A: 2
  valor_alto_item_C: 1000.0
ruptura:
  boost_demanda_curva_AB: 1.2
sazonalidade:
  ativada: true
  fator_maximo: 2.5
  fator_minimo: 0.5
tolerancia_abc:
  A: 0.3
  B: 0.2
  C: 0.1
xyz:
  X:
    threshold: 0.5
    z_score: 1.65
  Y:
    threshold: 1.0
    z_score: 1.28
  Z:
    threshold: 999.0
    z_score: 0.84

--------------------------------------------------------------------------------
END FILE: config/parametros.yaml



--------------------------------------------------------------------------------
END FILE: contexto_completo_do_sistema_sem_dashboard_16122025_ok.txt


START FILE: pytest.ini
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: pytest.ini


START FILE: launcher_gui.py
--------------------------------------------------------------------------------
import customtkinter as ctk
import sys
import threading
import subprocess
import json
import duckdb
from pathlib import Path
import yaml
from tkinter import messagebox
import os

# --- IMPORTAÃ‡ÃƒO DOS COMPONENTES VISUAIS ---
try:
    from src.ui.components.sidebar import Sidebar
    from src.ui.components.dashboard import Dashboard
except ImportError:
    sys.path.append(str(Path(__file__).parent))
    from src.ui.components.sidebar import Sidebar
    from src.ui.components.dashboard import Dashboard

# ConfiguraÃ§Ã£o Global de Tema
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

# COR DE FUNDO PRINCIPAL (Ajuste para estilo "Windows Moderno")
# Light: Cinza muito suave (#f3f4f6) | Dark: Azul Profundo (#0f172a)
COLOR_BG_MAIN = ("#f3f4f6", "#0f172a")

class DashboardApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        # Setup Janela
        self.title("NewCompras v7.4 - Enterprise Edition")
        self.geometry("1280x850")
        self.minsize(900, 600)
        
        # Paths
        self.root_dir = Path(__file__).parent
        self.config_path = self.root_dir / "config" / "parametros.yaml"
        self.script_path = self.root_dir / "scripts" / "gerar_relatorio_final.py"
        self.db_path = self.root_dir / "data" / "vendas.db"
        self.cache_path = self.root_dir / "data" / "marcas_cache.json"

        # VariÃ¡veis de ConfiguraÃ§Ã£o
        self.var_cobertura = ctk.StringVar()
        self.var_lead_time = ctk.StringVar()
        self.var_dias_novo = ctk.StringVar()
        
        # Cache de Marcas
        self.todas_marcas = ["TODAS"]

        # --- LAYOUT PRINCIPAL ---
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self._construir_interface()
        self._inicializar_dados()

    def _construir_interface(self):
        # 1. Sidebar (Menu Lateral)
        self.sidebar = Sidebar(
            master=self,
            titulo="AnalyticX",
            subtitulo="GestÃ£o Inteligente v7.4",
            command_gerar=lambda: self.iniciar_processamento(simulacao=True),
            command_config=self.salvar_parametros
        )
        self.sidebar.grid(row=0, column=0, rowspan=4, sticky="nsew")

        # InjeÃ§Ã£o de Inputs na Sidebar
        self.frame_inputs = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        self.frame_inputs.grid(row=4, column=0, sticky="new", padx=10, pady=(20, 0))
        
        self.criar_grupo_input_custom(self.frame_inputs, "PARÃ‚METROS GLOBAIS", [
            ("Meta Cobertura (Meses):", self.var_cobertura),
            ("Lead Time PadrÃ£o (Dias):", self.var_lead_time),
        ])
        self.criar_grupo_input_custom(self.frame_inputs, "DEFINIÃ‡ÃƒO DE PRODUTO", [
            ("Janela 'Item Novo' (Dias):", self.var_dias_novo),
        ])
        
        # BotÃ£o Recarregar com cor adaptativa
        ctk.CTkButton(
            self.frame_inputs, 
            text="ğŸ”„ Recarregar Marcas", 
            fg_color=("#e2e8f0", "#334155"), # Cinza claro no Light
            text_color=("#1e293b", "#ffffff"), 
            hover_color=("#cbd5e1", "#475569"),
            height=32,
            command=lambda: threading.Thread(target=self.forcar_atualizacao_marcas, daemon=True).start()
        ).pack(pady=(20,0), fill="x")

        # 2. Dashboard (Ãrea Principal)
        # Passamos a cor de fundo explicitamente aqui
        self.dashboard = Dashboard(self, fg_color=COLOR_BG_MAIN)
        self.dashboard.grid(row=0, column=1, sticky="nsew")
        
        # Conecta callbacks
        self.dashboard.configurar_acoes(
            on_simular=lambda: self.iniciar_processamento(simulacao=True),
            on_excel=lambda: self.iniciar_processamento(simulacao=False),
            on_filter_change=self.filtrar_marcas
        )

    def criar_grupo_input_custom(self, parent, titulo, campos):
        """
        Cria inputs com contraste corrigido para garantir legibilidade no tema Light.
        """
        # TÃ­tulo
        ctk.CTkLabel(
            parent, 
            text=titulo, 
            text_color=("#1e40af", "#94a3b8"), # Azul escuro no Light 
            font=("Arial", 11, "bold"), 
            anchor="w"
        ).pack(fill="x", pady=(15, 5))
        
        for label_text, variable in campos:
            # RÃ³tulo
            ctk.CTkLabel(
                parent, 
                text=label_text, 
                text_color=("#1e293b", "#e2e8f0"), # Preto no Light
                font=("Arial", 12), 
                anchor="w"
            ).pack(fill="x")
            
            # Campo de Texto (Branco no Light para destacar do fundo cinza)
            ctk.CTkEntry(
                parent, 
                textvariable=variable, 
                height=30, 
                fg_color=("#ffffff", "#0f172a"), 
                border_color=("#94a3b8", "#334155"), 
                text_color=("#000000", "#ffffff")
            ).pack(fill="x", pady=(0, 10))

    def _inicializar_dados(self):
        self.carregar_parametros()
        threading.Thread(target=self.gerenciar_cache_marcas, daemon=True).start()

    # --- LÃ“GICA DE MARCAS (Mantida Integralmente) ---
    def gerenciar_cache_marcas(self):
        if self.cache_path.exists():
            try:
                self.dashboard.log("ğŸ“‚ Carregando marcas do cache...")
                with open(self.cache_path, 'r', encoding='utf-8') as f:
                    self.todas_marcas = json.load(f)
                    self.after(0, lambda: self.filtrar_marcas(""))
                    self.dashboard.log(f"âœ… {len(self.todas_marcas)} marcas carregadas.")
                    return
            except Exception: pass
        self.forcar_atualizacao_marcas()

    def forcar_atualizacao_marcas(self):
        self.dashboard.log("â³ Indexando marcas do banco...")
        try:
            if not self.db_path.exists(): return
            con = duckdb.connect(":memory:")
            con.execute(f"ATTACH '{str(self.db_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            res = con.execute("SELECT DISTINCT marca FROM sqlite_db.produtos_gerais WHERE marca IS NOT NULL AND marca != '' ORDER BY 1").fetchall()
            self.todas_marcas = ["TODAS"] + [str(r[0]) for r in res]
            
            with open(self.cache_path, 'w', encoding='utf-8') as f: json.dump(self.todas_marcas, f)
            
            self.after(0, lambda: self.filtrar_marcas(""))
            self.dashboard.log(f"âœ… IndexaÃ§Ã£o concluÃ­da.")
            con.close()
        except Exception as e: self.dashboard.log(f"âŒ Erro marcas: {e}")

    def filtrar_marcas(self, termo=""):
        termo = termo.upper() if termo else ""
        lista = [m for m in self.todas_marcas if termo in m.upper()] if termo else self.todas_marcas
        self.dashboard.renderizar_lista_marcas(lista)

    # --- MOTOR DE CÃLCULO (Mantido Integralmente) ---
    def iniciar_processamento(self, simulacao=True):
        self.salvar_parametros()
        if not simulacao: self.dashboard.focar_aba_log()
        
        self.sidebar.set_estado_gerar("disabled")
        self.dashboard.set_estado_processamento(True)
        self.dashboard.limpar_log()

        threading.Thread(target=lambda: self.rodar_script(simulacao), daemon=True).start()

    def rodar_script(self, simulacao):
        try:
            marca = self.dashboard.get_marca_selecionada()
            python_exec = sys.executable 
            cmd = [python_exec, str(self.script_path), "--marca", marca]
            if simulacao: cmd.append("--simulacao")

            self.dashboard.log(f"ğŸš€ Iniciando motor: {marca}")
            
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1, encoding='utf-8', errors='replace')

            for line in process.stdout:
                line_clean = line.strip()
                if "--- LOG START ---" not in line_clean and line_clean:
                    self.after(0, lambda l=line_clean: self.dashboard.log(l))

            process.wait()
            
            if process.stderr.read(): self.dashboard.log(f"ğŸ”´ STDERR detectado.")

            if process.returncode == 0:
                self._carregar_resultados()

            self.after(0, lambda: self.finalizar_processo(simulacao, process.returncode))

        except Exception as e:
            self.dashboard.log(f"âŒ ERRO CRÃTICO: {e}")
            self.after(0, lambda: self.finalizar_processo(simulacao, 1))

    def _carregar_resultados(self):
        try:
            stats_path = self.root_dir / "data" / "cache" / "last_run_stats.json"
            if stats_path.exists():
                with open(stats_path, 'r', encoding='utf-8') as f:
                    data = json.load(f).get("data", {})
                    self.after(0, lambda: self.dashboard.atualizar_kpis_dict(data))
        except Exception: pass

    def finalizar_processo(self, simulacao, codigo_retorno):
        self.dashboard.set_estado_processamento(False)
        self.sidebar.set_estado_gerar("normal")
        
        if codigo_retorno == 0:
            if simulacao:
                self.dashboard.habilitar_excel()
                self.dashboard.focar_aba_dashboard()
                self.dashboard.log("âœ… SimulaÃ§Ã£o concluÃ­da.")
                messagebox.showinfo("Sucesso", "SimulaÃ§Ã£o finalizada!")
            else:
                self.dashboard.log("âœ… Excel gerado.")
                messagebox.showinfo("Sucesso", "RelatÃ³rio gerado!")
                try: os.startfile(str(self.root_dir / "data" / "exports"))
                except: pass
        else:
            self.dashboard.focar_aba_log()
            messagebox.showerror("Erro", "Ocorreu uma falha. Verifique o Log.")

    # --- CONFIGURAÃ‡ÃƒO ---
    def carregar_parametros(self):
        try:
            if not self.config_path.exists(): return
            with open(self.config_path, 'r', encoding='utf-8') as f: data = yaml.safe_load(f)
            self.var_cobertura.set(str(data.get('compras', {}).get('meses_cobertura', 1.5)))
            self.var_lead_time.set(str(data.get('lead_time', {}).get('padrao_dias', 10)))
            self.var_dias_novo.set(str(data.get('produto', {}).get('dias_lancamento', 60)))
        except: pass

    def salvar_parametros(self):
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f: data = yaml.safe_load(f) or {}
            if 'compras' not in data: data['compras'] = {}
            if 'lead_time' not in data: data['lead_time'] = {}
            if 'produto' not in data: data['produto'] = {}

            data['compras']['meses_cobertura'] = float(self.var_cobertura.get())
            data['lead_time']['padrao_dias'] = int(self.var_lead_time.get())
            data['produto']['dias_lancamento'] = int(self.var_dias_novo.get())
            
            with open(self.config_path, 'w', encoding='utf-8') as f: yaml.dump(data, f)
            messagebox.showinfo("Salvo", "ParÃ¢metros atualizados!")
        except Exception as e: messagebox.showerror("Erro", str(e))

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()

    # MELHOR ATÃ‰ AGORA 18 12 2025 23H15M
--------------------------------------------------------------------------------
END FILE: launcher_gui.py


START FILE: export_full_project.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

# --- CONFIGURAÃ‡Ã•ES ---
PROJECT_ROOT = Path(__file__).parent
OUTPUT_FILE = "contexto_completo_do_sistema.txt"

# Pastas para ignorar (nÃ£o entra nem lÃª nada dentro)
IGNORE_DIRS = {
    ".git", 
    ".venv", 
    "venv", 
    "env", 
    "__pycache__", 
    ".idea", 
    ".vscode", 
    "data",       # Ignora bancos de dados binÃ¡rios
    "logs",       # Ignora logs de execuÃ§Ã£o
    "exports",    # Ignora os Excels gerados
    "build",
    "dist"
}

# ExtensÃµes permitidas (sÃ³ salva arquivos deste tipo)
INCLUDE_EXTS = {
    ".py", 
    ".yaml", 
    ".yml", 
    ".sql", 
    ".json", 
    ".md", 
    ".txt", 
    ".toml", 
    ".ini"
}

# Arquivos especÃ­ficos para ignorar (caso necessÃ¡rio)
IGNORE_FILES = {
    OUTPUT_FILE, # NÃ£o ler o prÃ³prio arquivo de saÃ­da
    "package-lock.json",
    ".DS_Store"
}

def generate_tree(path, prefix=""):
    """Gera uma string visual da estrutura de pastas."""
    tree_str = ""
    try:
        # Pega itens e ordena (pastas primeiro, depois arquivos)
        items = list(path.iterdir())
        items.sort(key=lambda x: (not x.is_dir(), x.name.lower()))
        
        # Filtra itens ignorados
        items = [i for i in items if i.name not in IGNORE_DIRS and i.name not in IGNORE_FILES]
        
        count = len(items)
        for i, item in enumerate(items):
            is_last = (i == count - 1)
            connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            
            tree_str += f"{prefix}{connector}{item.name}\n"
            
            if item.is_dir():
                extension = "    " if is_last else "â”‚   "
                tree_str += generate_tree(item, prefix + extension)
                
    except PermissionError:
        tree_str += f"{prefix}â””â”€â”€ [Acesso Negado]\n"
        
    return tree_str

def main():
    print(f"ğŸš€ Iniciando exportaÃ§Ã£o do projeto em: {PROJECT_ROOT}")
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # 1. CabeÃ§alho Principal
        out.write("="*80 + "\n")
        out.write(f"PROJETO: COMPRAS-ESTOQUE-SISTEMA\n")
        out.write(f"DATA GERACAO: {os.path.basename(str(PROJECT_ROOT))}\n")
        out.write("="*80 + "\n\n")

        # 2. Estrutura de DiretÃ³rios (Ãrvore)
        out.write("ESTRUTURA DE DIRETÃ“RIOS:\n")
        out.write("-" * 40 + "\n")
        out.write(generate_tree(PROJECT_ROOT))
        out.write("\n" + "="*80 + "\n\n")
        
        # 3. ConteÃºdo dos Arquivos
        file_count = 0
        
        for root, dirs, files in os.walk(PROJECT_ROOT):
            # Modifica dirs in-place para pular pastas ignoradas no walk
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            
            for file in files:
                if file in IGNORE_FILES:
                    continue
                
                file_path = Path(root) / file
                
                # Verifica extensÃ£o
                if file_path.suffix.lower() not in INCLUDE_EXTS:
                    continue

                # Caminho relativo para exibiÃ§Ã£o
                rel_path = file_path.relative_to(PROJECT_ROOT)
                
                try:
                    content = file_path.read_text(encoding="utf-8", errors="ignore")
                    
                    # Escreve separador e conteÃºdo
                    out.write(f"START FILE: {rel_path}\n")
                    out.write("-" * 80 + "\n")
                    out.write(content)
                    out.write("\n")
                    out.write("-" * 80 + "\n")
                    out.write(f"END FILE: {rel_path}\n")
                    out.write("\n\n")
                    
                    file_count += 1
                    print(f"âœ… IncluÃ­do: {rel_path}")
                    
                except Exception as e:
                    print(f"âŒ Erro ao ler {rel_path}: {e}")

    print(f"\nâœ¨ ConcluÃ­do! {file_count} arquivos salvos em '{OUTPUT_FILE}'.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: export_full_project.py


START FILE: conftest.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: conftest.py


START FILE: verificar_ambiente.py
--------------------------------------------------------------------------------
import sys
import os
import subprocess
from pathlib import Path

def diagnostico():
    print("--- ğŸ” DIAGNÃ“STICO DE AMBIENTE ---")
    print(f"Caminho do ExecutÃ¡vel Python: {sys.executable}")
    print(f"VersÃ£o do Python: {sys.version}")
    print(f"Pasta Atual (CWD): {os.getcwd()}")
    
    # 1. Tenta importar pandera
    print("\n--- ğŸ“¦ TESTE DE BIBLIOTECAS ---")
    try:
        import pandera
        print(f"âœ… Pandera: Instalado (VersÃ£o: {pandera.__version__})")
        print(f"   Local: {pandera.__file__}")
    except ImportError:
        print("âŒ Pandera: NÃƒO ENCONTRADO neste ambiente.")

    try:
        import matplotlib
        print(f"âœ… Matplotlib: Instalado")
    except ImportError:
        print("âŒ Matplotlib: NÃƒO ENCONTRADO.")

    # 2. Verifica estrutura do venv
    print("\n--- ğŸ“ ESTRUTURA DE PASTAS ---")
    venv_path = Path("./venv/bin/python")
    print(f"O arquivo ./venv/bin/python existe? {'âœ… Sim' if venv_path.exists() else 'âŒ NÃ£o'}")

    # 3. Testa como o subprocesso seria chamado
    print("\n--- ğŸš€ TESTE DE CHAMADA (SUBPROCESSO) ---")
    try:
        # Tenta rodar o python do venv pedindo a versÃ£o
        res = subprocess.run([str(venv_path), "--version"], capture_output=True, text=True)
        print(f"Chamada './venv/bin/python --version' retornou: {res.stdout.strip()}")
    except Exception as e:
        print(f"âŒ Erro ao tentar chamar o python do venv: {e}")

if __name__ == "__main__":
    diagnostico()
--------------------------------------------------------------------------------
END FILE: verificar_ambiente.py


START FILE: pyproject.toml
--------------------------------------------------------------------------------
[project]
name = "compras-estoque-sistema"
version = "1.0.0"
description = "Sistema modular de compras e gestÃ£o de estoque"
requires-python = ">=3.11"
dependencies = [
    "duckdb>=1.1.0",
    "polars-lts-cpu>=1.12.0",
    "pyarrow>=14.0.0",
    "pydantic>=2.9.0",
    "pyyaml>=6.0.2",
    "pandera[polars]>=0.20.4",
    "structlog>=24.4.0",
    "openpyxl>=3.1.5",
    "reportlab>=4.2.5",
    "pyinstaller>=6.11.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.3",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "hypothesis>=6.115.6",
    "ruff>=0.7.4",
    "mypy>=1.13.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
dev-dependencies = ["ruff", "mypy", "pytest"]

[tool.hatch.build.targets.wheel]
packages = ["src/compras_sistema"]

--------------------------------------------------------------------------------
END FILE: pyproject.toml


START FILE: auditor_item_completo.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
AUDITOR DE ITEM - VALIDAÃ‡ÃƒO COMPLETA DE CÃLCULOS (STANDALONE)
Sistema: GestÃ£o de Compras e Estoque
Autor: RobÃ©rio (com assistÃªncia de IA)
Data: 16/12/2025

VersÃ£o standalone - nÃ£o depende de mÃ³dulos externos
CORRIGIDO: Nomes de colunas conforme schema real do banco
"""

import sys
from pathlib import Path
import math
from datetime import datetime
import yaml

try:
    import duckdb
except ImportError:
    print("âŒ ERRO: Biblioteca 'duckdb' nÃ£o encontrada!")
    print("   Instale com: pip install duckdb")
    sys.exit(1)


class ConfigSimples:
    """Gerenciador simples de configuraÃ§Ãµes"""

    def __init__(self, config_path):
        self.config_path = Path(config_path)
        self.parametros = self._carregar_config()

    def _carregar_config(self):
        """Carrega configuraÃ§Ãµes do YAML"""
        if not self.config_path.exists():
            print(f"âš ï¸  Arquivo de config nÃ£o encontrado: {self.config_path}")
            print("   Usando valores padrÃ£o...")
            return {
                'compras': {
                    'leadtime_padrao': 7,
                    'meses_cobertura': 2
                },
                'produto': {
                    'dias_lancamento': 365
                }
            }

        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            return config
        except Exception as e:
            print(f"âš ï¸  Erro ao ler config: {e}")
            print("   Usando valores padrÃ£o...")
            return {
                'compras': {
                    'leadtime_padrao': 7,
                    'meses_cobertura': 2
                },
                'produto': {
                    'dias_lancamento': 365
                }
            }


class AuditorItem:
    """Auditor completo de cÃ¡lculos de um item"""

    def __init__(self, db_path, config):
        self.db_path = Path(db_path)
        self.config = config
        self.conn = None
        self.resultado = {}

    def conectar(self):
        """Conecta ao banco de dados"""
        if not self.db_path.exists():
            print(f"âŒ ERRO: Banco de dados nÃ£o encontrado: {self.db_path}")
            return False

        try:
            self.conn = duckdb.connect(':memory:')
            self.conn.execute(f"ATTACH '{self.db_path}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
            print(f"âœ… Conectado ao banco: {self.db_path.name}")
            return True
        except Exception as e:
            print(f"âŒ ERRO ao conectar: {e}")
            return False

    def desconectar(self):
        """Desconecta do banco"""
        if self.conn:
            self.conn.close()
            self.conn = None

    def auditar(self, cod_produto):
        """Executa auditoria completa de um produto"""
        print("=" * 80)
        print(f"AUDITORIA COMPLETA - ITEM: {cod_produto}")
        print(f"Data/Hora: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        print("=" * 80)
        print()

        # Etapa 1: Dados Cadastrais
        print("â–¶ ETAPA 1: DADOS CADASTRAIS")
        print("-" * 80)
        cadastro = self._buscar_cadastro(cod_produto)
        if not cadastro:
            print("âŒ ERRO: Produto nÃ£o encontrado no cadastro!")
            return False
        self._exibir_cadastro(cadastro)
        self.resultado['cadastro'] = cadastro

        # Etapa 2: Saldo e Estoque
        print("\nâ–¶ ETAPA 2: POSIÃ‡ÃƒO DE ESTOQUE")
        print("-" * 80)
        estoque = self._buscar_estoque(cod_produto)
        if not estoque:
            print("âŒ ERRO: Estoque nÃ£o encontrado!")
            return False
        self._exibir_estoque(estoque)
        self.resultado['estoque'] = estoque

        # Etapa 3: HistÃ³rico de Vendas
        print("\nâ–¶ ETAPA 3: ANÃLISE DE VENDAS")
        print("-" * 80)
        vendas = self._buscar_vendas(cod_produto)
        self._exibir_vendas(vendas)
        self.resultado['vendas'] = vendas

        # Etapa 4: ClassificaÃ§Ãµes ABC e XYZ
        print("\nâ–¶ ETAPA 4: CLASSIFICAÃ‡Ã•ES")
        print("-" * 80)
        classificacao = self._buscar_classificacao(cod_produto)
        self._exibir_classificacao(classificacao)
        self.resultado['classificacao'] = classificacao

        # Etapa 5: CÃ¡lculo de TendÃªncias
        print("\nâ–¶ ETAPA 5: TENDÃŠNCIAS")
        print("-" * 80)
        tendencias = self._calcular_tendencias(vendas)
        self._exibir_tendencias(tendencias)
        self.resultado['tendencias'] = tendencias

        # Etapa 6: CÃ¡lculo de SeguranÃ§a (Z-Score)
        print("\nâ–¶ ETAPA 6: ESTOQUE DE SEGURANÃ‡A")
        print("-" * 80)
        seguranca = self._calcular_seguranca(vendas, classificacao)
        self._exibir_seguranca(seguranca)
        self.resultado['seguranca'] = seguranca

        # Etapa 7: Ponto de Suprimento e Estoque Meta
        print("\nâ–¶ ETAPA 7: PONTO DE SUPRIMENTO E ESTOQUE META")
        print("-" * 80)
        necessidades = self._calcular_necessidades(
            vendas, seguranca, estoque, cadastro, classificacao
        )
        self._exibir_necessidades(necessidades)
        self.resultado['necessidades'] = necessidades

        # Etapa 8: SugestÃ£o Bruta e Final
        print("\nâ–¶ ETAPA 8: CÃLCULO DA SUGESTÃƒO DE COMPRA")
        print("-" * 80)
        sugestao = self._calcular_sugestao(necessidades, estoque, cadastro)
        self._exibir_sugestao(sugestao)
        self.resultado['sugestao'] = sugestao

        # Etapa 9: Score de Prioridade
        print("\nâ–¶ ETAPA 9: SCORE DE PRIORIZAÃ‡ÃƒO")
        print("-" * 80)
        score = self._calcular_score(sugestao, vendas, estoque, classificacao, tendencias)
        self._exibir_score(score)
        self.resultado['score'] = score

        # Etapa 10: DiagnÃ³stico e ValidaÃ§Ãµes
        print("\nâ–¶ ETAPA 10: DIAGNÃ“STICO E BLOQUEIOS")
        print("-" * 80)
        diagnostico = self._gerar_diagnostico(
            cadastro, estoque, vendas, sugestao, necessidades
        )
        self._exibir_diagnostico(diagnostico)
        self.resultado['diagnostico'] = diagnostico

        # Etapa 11: ComparaÃ§Ã£o com Sistema (opcional)
        print("\nâ–¶ ETAPA 11: COMPARAÃ‡ÃƒO COM SISTEMA")
        print("-" * 80)
        comparacao = self._comparar_com_sistema(cod_produto, diagnostico)
        self.resultado['comparacao'] = comparacao

        # Etapa 12: OpiniÃ£o TÃ©cnica Final
        print("\n" + "=" * 80)
        print("ğŸ“Š OPINIÃƒO TÃ‰CNICA - VALIDAÃ‡ÃƒO DA AUDITORIA")
        print("=" * 80)
        self._emitir_parecer()

        return True

    def _buscar_cadastro(self, cod_produto):
        """Busca dados cadastrais do produto"""
        try:
            # CORRIGIDO: usando cod_produto com underscore
            result = self.conn.execute(f"""
                SELECT 
                    cod_produto,
                    descricao_produto,
                    marca,
                    ref_fornecedor,
                    ativo,
                    qtd_economica,
                    data_cadastro
                FROM sqlite_db.produtos_gerais
                WHERE CAST(cod_produto AS VARCHAR) = '{cod_produto}'
            """).fetchone()

            if not result:
                return None

            data_cadastro = result[6]
            if data_cadastro:
                try:
                    dt_cad = datetime.fromisoformat(data_cadastro)
                    dias_vida = (datetime.now() - dt_cad).days
                except:
                    dias_vida = 9999
            else:
                dias_vida = 9999

            return {
                'codigo': result[0],
                'descricao': result[1],
                'marca': result[2],
                'ref_fornecedor': result[3],
                'ativo': result[4],
                'lote_economico': result[5] if result[5] else 1,
                'data_cadastro': data_cadastro,
                'dias_vida': dias_vida
            }
        except Exception as e:
            print(f"âš ï¸  Erro ao buscar cadastro: {e}")
            return None

    def _buscar_estoque(self, cod_produto):
        """Busca posiÃ§Ã£o de estoque"""
        try:
            # CORRIGIDO: usando cod_produto com underscore
            result = self.conn.execute(f"""
                SELECT 
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
                WHERE CAST(cod_produto AS VARCHAR) = '{cod_produto}'
            """).fetchone()

            if not result:
                return None

            return {
                'saldo_fisico': result[0] if result[0] else 0,
                'saldo_oc': result[1] if result[1] else 0,
                'custo_unitario': float(result[2]) if result[2] else 0.0,
                'ultima_entrada': result[3],
                'estoque_total': (result[0] if result[0] else 0) + (result[1] if result[1] else 0)
            }
        except Exception as e:
            print(f"âš ï¸  Erro ao buscar estoque: {e}")
            return None

    def _buscar_vendas(self, cod_produto):
        """Busca histÃ³rico completo de vendas"""
        try:
            # CORRIGIDO: usando cod_produto e data_movimento
            # Vendas 12 meses
            vendas_12m = self.conn.execute(f"""
                SELECT SUM(quantidade)
                FROM sqlite_db.vendas
                WHERE cod_produto = '{cod_produto}'
                AND CAST(data_movimento AS DATE) >= CURRENT_DATE - INTERVAL 365 days
            """).fetchone()[0] or 0

            # EstatÃ­sticas gerais (Ãºltimos 12 meses)
            stats = self.conn.execute(f"""
                SELECT 
                    COUNT(DISTINCT CAST(data_movimento AS DATE)) as dias_com_venda,
                    SUM(quantidade) as total_vendido,
                    MIN(data_movimento) as primeira_venda,
                    MAX(data_movimento) as ultima_venda,
                    STDDEV_POP(quantidade) as std_venda,
                    COUNT(DISTINCT cod_clifor) as total_clientes
                FROM sqlite_db.vendas
                WHERE cod_produto = '{cod_produto}'
                AND CAST(data_movimento AS DATE) >= CURRENT_DATE - INTERVAL 12 months
            """).fetchone()

            dias_com_venda = stats[0] or 0
            total_vendido = stats[1] or 0
            primeira_venda = stats[2]
            ultima_venda = stats[3]
            std_venda = float(stats[4]) if stats[4] else 0.0
            total_clientes = stats[5] or 0

            # Calcula dias desde Ãºltima venda
            if ultima_venda:
                try:
                    dt_ult = datetime.fromisoformat(ultima_venda)
                    dias_sem_venda = (datetime.now() - dt_ult).days
                except:
                    dias_sem_venda = 9999
            else:
                dias_sem_venda = 9999

            # Calcula mÃ©dia diÃ¡ria baseada no intervalo
            if primeira_venda and ultima_venda:
                try:
                    dt_pri = datetime.fromisoformat(primeira_venda)
                    dt_ult = datetime.fromisoformat(ultima_venda)
                    dias_intervalo = (dt_ult - dt_pri).days + 1
                    media_dia = total_vendido / dias_intervalo if dias_intervalo > 0 else 0
                except:
                    media_dia = 0.0
            else:
                media_dia = 0.0

            # TendÃªncia trimestral
            trim_atual = self.conn.execute(f"""
                SELECT SUM(quantidade), COUNT(DISTINCT cod_clifor)
                FROM sqlite_db.vendas
                WHERE cod_produto = '{cod_produto}'
                AND CAST(data_movimento AS DATE) >= CURRENT_DATE - INTERVAL 90 days
            """).fetchone()

            trim_anterior = self.conn.execute(f"""
                SELECT SUM(quantidade), COUNT(DISTINCT cod_clifor)
                FROM sqlite_db.vendas
                WHERE cod_produto = '{cod_produto}'
                AND CAST(data_movimento AS DATE) >= CURRENT_DATE - INTERVAL 180 days
                AND CAST(data_movimento AS DATE) < CURRENT_DATE - INTERVAL 90 days
            """).fetchone()

            qtd_trim_atual = trim_atual[0] or 0
            cli_trim_atual = trim_atual[1] or 0
            qtd_trim_anterior = trim_anterior[0] or 0
            cli_trim_anterior = trim_anterior[1] or 0

            return {
                'vendas_12m': vendas_12m,
                'dias_com_venda': dias_com_venda,
                'total_vendido': total_vendido,
                'media_dia': media_dia,
                'media_dia_real_12m': vendas_12m / 365.0,
                'std_venda_dia': std_venda,
                'primeira_venda': primeira_venda,
                'ultima_venda': ultima_venda,
                'dias_sem_venda': dias_sem_venda,
                'total_clientes': total_clientes,
                'qtd_trim_atual': qtd_trim_atual,
                'qtd_trim_anterior': qtd_trim_anterior,
                'cli_trim_atual': cli_trim_atual,
                'cli_trim_anterior': cli_trim_anterior
            }
        except Exception as e:
            print(f"âš ï¸  Erro ao buscar vendas: {e}")
            return {
                'vendas_12m': 0,
                'dias_com_venda': 0,
                'total_vendido': 0,
                'media_dia': 0.0,
                'media_dia_real_12m': 0.0,
                'std_venda_dia': 0.0,
                'primeira_venda': None,
                'ultima_venda': None,
                'dias_sem_venda': 9999,
                'total_clientes': 0,
                'qtd_trim_atual': 0,
                'qtd_trim_anterior': 0,
                'cli_trim_atual': 0,
                'cli_trim_anterior': 0
            }

    def _buscar_classificacao(self, cod_produto):
        """Busca classificaÃ§Ã£o ABC e XYZ"""
        try:
            # CORRIGIDO: usando cod_produto
            # Busca ABC
            abc_result = self.conn.execute(f"""
                SELECT curva_abc
                FROM curva_abc_financeira
                WHERE cod_produto = '{cod_produto}'
            """).fetchone()

            abc = abc_result[0] if abc_result else 'C'

            # Busca XYZ
            xyz_result = self.conn.execute(f"""
                SELECT curva_xyz
                FROM curva_xyz_consistencia
                WHERE cod_produto = '{cod_produto}'
            """).fetchone()

            xyz = xyz_result[0] if xyz_result else 'Z'

        except Exception as e:
            print(f"âš ï¸  Tabelas de classificaÃ§Ã£o nÃ£o encontradas: {e}")
            abc = 'C'
            xyz = 'Z'

        # Lead time da config
        cfg_compras = self.config.parametros.get('compras', {})
        lead_time_padrao = cfg_compras.get('leadtime_padrao', 7)

        return {
            'curva_abc': abc,
            'curva_xyz': xyz,
            'lead_time_dias': lead_time_padrao
        }

    def _calcular_tendencias(self, vendas):
        """Calcula tendÃªncias de vendas e clientes"""
        # VariaÃ§Ã£o de vendas
        if vendas['qtd_trim_anterior'] > 0:
            var_vendas = (vendas['qtd_trim_atual'] - vendas['qtd_trim_anterior']) / vendas['qtd_trim_anterior']
        else:
            var_vendas = 0.0

        # TendÃªncia vendas
        if var_vendas >= 0.20:
            tend_vendas = "EM ALTA"
        elif var_vendas <= -0.20:
            tend_vendas = "EM QUEDA"
        else:
            tend_vendas = "ESTÃVEL"

        # Saldo clientes
        saldo_clientes = vendas['cli_trim_atual'] - vendas['cli_trim_anterior']

        # TendÃªncia clientes
        if saldo_clientes > 0:
            tend_clientes = f"GANHO +{saldo_clientes}"
        elif saldo_clientes < 0:
            tend_clientes = f"PERDA {saldo_clientes}"
        else:
            tend_clientes = "MANTEVE"

        # Perfil cliente
        qtd_clientes = vendas['total_clientes']
        if qtd_clientes == 0:
            perfil = "Sem Venda"
        elif qtd_clientes <= 2:
            perfil = "Dedicado (1-2)"
        elif qtd_clientes <= 9:
            perfil = "Concentrado (3-9)"
        else:
            perfil = "Pulverizado (10+)"

        return {
            'var_vendas': var_vendas,
            'tendencia_vendas': tend_vendas,
            'saldo_clientes': saldo_clientes,
            'tendencia_clientes': tend_clientes,
            'perfil_cliente': perfil
        }

    def _calcular_seguranca(self, vendas, classificacao):
        """Calcula estoque de seguranÃ§a"""
        # Fator Z baseado em XYZ
        xyz = classificacao['curva_xyz']
        if xyz == 'X':
            fator_z = 1.65
        elif xyz == 'Y':
            fator_z = 1.28
        else:
            fator_z = 0.84

        # Estoque de seguranÃ§a
        lead_time = classificacao['lead_time_dias']
        std_dia = vendas['std_venda_dia']

        estoque_seguranca = fator_z * std_dia * math.sqrt(lead_time)

        return {
            'fator_z': fator_z,
            'std_venda_dia': std_dia,
            'lead_time': lead_time,
            'estoque_seguranca': round(estoque_seguranca, 0)
        }

    def _calcular_necessidades(self, vendas, seguranca, estoque, cadastro, classificacao):
        """Calcula ponto de suprimento e estoque meta"""
        cfg_compras = self.config.parametros.get('compras', {})
        cfg_produto = self.config.parametros.get('produto', {})

        meses_cobertura = cfg_compras.get('meses_cobertura', 2)
        dias_novo = cfg_produto.get('dias_lancamento', 365)

        media_dia = vendas['media_dia']
        lead_time = seguranca['lead_time']
        est_seguranca = seguranca['estoque_seguranca']
        dias_vida = cadastro['dias_vida']
        dias_sem_venda = vendas['dias_sem_venda']
        abc = classificacao['curva_abc']

        # LÃ“GICA DE AJUSTE PARA ITEM NOVO (Boost anti-ruptura)
        if (estoque['saldo_fisico'] == 0 and 
            abc in ['A', 'B'] and 
            dias_vida <= dias_novo):

            if dias_sem_venda <= 30:
                media_calculo = media_dia * 1.20
                boost_aplicado = "1.20x (Sem venda â‰¤ 30 dias)"
            elif dias_sem_venda <= 90:
                media_calculo = media_dia * 1.50
                boost_aplicado = "1.50x (Sem venda â‰¤ 90 dias)"
            else:
                media_calculo = media_dia * 2.00
                boost_aplicado = "2.00x (Sem venda > 90 dias)"
        else:
            media_calculo = media_dia
            boost_aplicado = "Nenhum (Item normal)"

        # Ponto de Suprimento
        ponto_suprimento = round(media_calculo * lead_time + est_seguranca, 0)

        # Estoque Meta
        estoque_meta = round(media_calculo * 30 * meses_cobertura + est_seguranca, 0)

        return {
            'media_calculo': media_calculo,
            'boost_aplicado': boost_aplicado,
            'ponto_suprimento': ponto_suprimento,
            'estoque_meta': estoque_meta,
            'meses_cobertura': meses_cobertura
        }

    def _calcular_sugestao(self, necessidades, estoque, cadastro):
        """Calcula sugestÃ£o de compra"""
        estoque_meta = necessidades['estoque_meta']
        saldo_fisico = estoque['saldo_fisico']
        saldo_oc = max(0, estoque['saldo_oc'])  # Sanitiza OC negativa

        # SugestÃ£o bruta
        sugestao_bruta = estoque_meta - saldo_fisico - saldo_oc

        # Necessidade lÃ­quida
        necessidade_liquida = max(0, sugestao_bruta)

        # Arredonda para lotes econÃ´micos
        lote_economico = cadastro['lote_economico']
        if necessidade_liquida > 0:
            lotes_cheios = math.ceil(necessidade_liquida / lote_economico)
            sugestao_final = lotes_cheios * lote_economico
        else:
            lotes_cheios = 0
            sugestao_final = 0

        # Subtotal
        subtotal = sugestao_final * estoque['custo_unitario']

        return {
            'sugestao_bruta': sugestao_bruta,
            'necessidade_liquida': necessidade_liquida,
            'lotes_cheios': lotes_cheios,
            'sugestao_final': sugestao_final,
            'subtotal': subtotal
        }

    def _calcular_score(self, sugestao, vendas, estoque, classificacao, tendencias):
        """Calcula score de priorizaÃ§Ã£o"""
        score = 0
        detalhes = []

        # Ruptura total
        if estoque['saldo_fisico'] <= 0:
            score += 5000
            detalhes.append("Ruptura Total: +5000")

        # Risco iminente
        if (estoque['saldo_fisico'] <= 
            vendas['media_dia'] * classificacao['lead_time_dias']):
            score += 2500
            detalhes.append("Risco Iminente: +2500")

        # Curva ABC
        abc = classificacao['curva_abc']
        if abc == 'A':
            score += 1000
            detalhes.append("Curva A: +1000")
        elif abc == 'B':
            score += 500
            detalhes.append("Curva B: +500")
        else:
            score += 100
            detalhes.append("Curva C: +100")

        # TendÃªncia alta
        if tendencias['tendencia_vendas'] == "EM ALTA":
            score += 500
            detalhes.append("TendÃªncia Alta: +500")

        # Giro financeiro
        giro_financeiro = int(vendas['media_dia'] * estoque['custo_unitario'])
        score += giro_financeiro
        detalhes.append(f"Giro Financeiro: +{giro_financeiro}")

        return {
            'score': score,
            'detalhes': detalhes
        }

    def _gerar_diagnostico(self, cadastro, estoque, vendas, sugestao, necessidades):
        """Gera diagnÃ³stico e aplica bloqueios"""
        cfg_produto = self.config.parametros.get('produto', {})
        dias_novo = cfg_produto.get('dias_lancamento', 365)

        # Cobertura virtual
        estoque_total = estoque['estoque_total']
        venda_mensal = vendas['media_dia'] * 30

        if venda_mensal > 0:
            cobertura_meses = estoque_total / venda_mensal
        else:
            cobertura_meses = 99.0

        # ValidaÃ§Ã£o de Giro (O Juiz)
        if (estoque['saldo_fisico'] == 0 and 
            estoque['saldo_oc'] == 0 and 
            vendas['media_dia'] == 0):

            if cadastro['dias_vida'] <= dias_novo:
                validacao_giro = "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)"
            else:
                validacao_giro = "SEM MOVIMENTO (Item velho parado)"
        elif cobertura_meses > 6:
            validacao_giro = f"ALERTA: Excesso ({cobertura_meses:.1f}m)"
        elif vendas['media_dia'] < 0.05 and sugestao['sugestao_final'] > 0:
            validacao_giro = "ALERTA: Sem Venda Recente"
        else:
            validacao_giro = "COERENTE"

        # Define motivo de bloqueio
        if cadastro['ativo'] == 'NÃƒO':
            motivo_bloqueio = "Produto inativo no cadastro"
            bloqueado = True
        elif "ALERTA" in validacao_giro:
            motivo_bloqueio = validacao_giro
            bloqueado = True
        else:
            motivo_bloqueio = ""
            bloqueado = False

        # SugestÃ£o calculada (antes do bloqueio)
        sugestao_calculada = sugestao['sugestao_final']

        # Aplica bloqueio na sugestÃ£o final
        if cadastro['ativo'] == 'NÃƒO':
            sugestao_final = 0
        elif "ALERTA" in validacao_giro:
            sugestao_final = 0
        elif validacao_giro == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)":
            sugestao_final = cadastro['lote_economico']  # 1 lote para item novo
        else:
            sugestao_final = sugestao['sugestao_final']

        return {
            'cobertura_virtual_meses': cobertura_meses,
            'validacao_giro': validacao_giro,
            'motivo_bloqueio': motivo_bloqueio,
            'bloqueado': bloqueado,
            'sugestao_calculada': sugestao_calculada,
            'sugestao_final': sugestao_final
        }

    def _comparar_com_sistema(self, cod_produto, diagnostico):
        """Compara cÃ¡lculo manual com o do sistema (se existir tabela)"""
        try:
            # Tenta buscar valor do sistema
            sistema = self.conn.execute(f"""
                SELECT sugestao_final, validacao_giro, motivo_bloqueio
                FROM relatorio_final
                WHERE cod_produto = '{cod_produto}'
            """).fetchone()

            if not sistema:
                print("â„¹ï¸  Item nÃ£o encontrado no relatÃ³rio do sistema")
                return {'encontrado': False}

            sugestao_sistema = sistema[0] or 0
            validacao_sistema = sistema[1]
            motivo_sistema = sistema[2]

            # Compara
            diferenca = diagnostico['sugestao_final'] - sugestao_sistema
            percentual = (abs(diferenca) / sugestao_sistema * 100) if sugestao_sistema > 0 else 0

            if diferenca == 0:
                print("âœ… CÃLCULOS VALIDADOS: Auditoria = Sistema")
                print(f"   SugestÃ£o: {diagnostico['sugestao_final']} pÃ§s")
            else:
                print("âš ï¸  DIVERGÃŠNCIA DETECTADA")
                print(f"   Sistema: {sugestao_sistema} pÃ§s")
                print(f"   Auditoria: {diagnostico['sugestao_final']} pÃ§s")
                print(f"   DiferenÃ§a: {diferenca:+} pÃ§s ({percentual:.1f}%)")

            return {
                'encontrado': True,
                'sugestao_sistema': sugestao_sistema,
                'sugestao_auditoria': diagnostico['sugestao_final'],
                'diferenca': diferenca,
                'percentual_diferenca': percentual,
                'validacao_sistema': validacao_sistema,
                'motivo_sistema': motivo_sistema,
                'match': diferenca == 0
            }

        except Exception as e:
            print(f"â„¹ï¸  Tabela relatorio_final nÃ£o encontrada ou erro: {e}")
            return {'encontrado': False}

    # =====================================================================
    # MÃ‰TODOS DE EXIBIÃ‡ÃƒO
    # =====================================================================

    def _exibir_cadastro(self, cadastro):
        """Exibe dados cadastrais"""
        print(f"CÃ³digo: {cadastro['codigo']}")
        print(f"DescriÃ§Ã£o: {cadastro['descricao']}")
        print(f"Marca: {cadastro['marca']}")
        print(f"ReferÃªncia: {cadastro['ref_fornecedor']}")
        print(f"Status: {cadastro['ativo']}")
        print(f"Lote EconÃ´mico: {cadastro['lote_economico']}")
        print(f"Data Cadastro: {cadastro['data_cadastro']}")
        print(f"Dias de Vida: {cadastro['dias_vida']} dias")

        if cadastro['dias_vida'] <= 365:
            print(f"  â„¹ï¸  Este Ã© um ITEM NOVO (menos de 1 ano)")

    def _exibir_estoque(self, estoque):
        """Exibe posiÃ§Ã£o de estoque"""
        print(f"Saldo FÃ­sico: {estoque['saldo_fisico']}")
        print(f"Saldo OC: {estoque['saldo_oc']}")
        print(f"Estoque Total: {estoque['estoque_total']}")
        print(f"Custo UnitÃ¡rio: R$ {estoque['custo_unitario']:.2f}")
        print(f"Ãšltima Entrada: {estoque['ultima_entrada']}")

        if estoque['saldo_fisico'] <= 0:
            print(f"  âš ï¸  RUPTURA DE ESTOQUE!")
        if estoque['saldo_oc'] < 0:
            print(f"  âš ï¸  OC NEGATIVA (erro de lanÃ§amento)")

    def _exibir_vendas(self, vendas):
        """Exibe anÃ¡lise de vendas"""
        print(f"Vendas Ãºltimos 12 meses: {vendas['vendas_12m']} pÃ§s")
        print(f"MÃ©dia DiÃ¡ria (Base 12m): {vendas['media_dia_real_12m']:.4f} pÃ§s/dia")
        print(f"MÃ©dia DiÃ¡ria (Intervalo): {vendas['media_dia']:.4f} pÃ§s/dia")
        print(f"Desvio PadrÃ£o: {vendas['std_venda_dia']:.4f}")
        print(f"Dias com Venda: {vendas['dias_com_venda']}")
        print(f"Dias sem Venda: {vendas['dias_sem_venda']}")
        print(f"Total de Clientes: {vendas['total_clientes']}")
        print(f"Primeira Venda: {vendas['primeira_venda']}")
        print(f"Ãšltima Venda: {vendas['ultima_venda']}")

        if vendas['vendas_12m'] == 0:
            print(f"  âš ï¸  Item SEM VENDAS nos Ãºltimos 12 meses!")

    def _exibir_classificacao(self, classificacao):
        """Exibe classificaÃ§Ãµes"""
        print(f"Curva ABC: {classificacao['curva_abc']}")
        print(f"Curva XYZ: {classificacao['curva_xyz']}")
        print(f"Lead Time: {classificacao['lead_time_dias']} dias")

    def _exibir_tendencias(self, tendencias):
        """Exibe tendÃªncias"""
        print(f"VariaÃ§Ã£o Vendas: {tendencias['var_vendas']:.2%}")
        print(f"TendÃªncia Vendas: {tendencias['tendencia_vendas']}")
        print(f"Saldo Clientes: {tendencias['saldo_clientes']}")
        print(f"TendÃªncia Clientes: {tendencias['tendencia_clientes']}")
        print(f"Perfil Cliente: {tendencias['perfil_cliente']}")

    def _exibir_seguranca(self, seguranca):
        """Exibe cÃ¡lculo de seguranÃ§a"""
        print(f"Curva XYZ: {self.resultado['classificacao']['curva_xyz']}")
        print(f"Fator Z: {seguranca['fator_z']}")
        print(f"FÃ³rmula: Estoque Seg. = Z Ã— Ïƒ Ã— âˆšLead Time")
        print(f"CÃ¡lculo: {seguranca['fator_z']} Ã— {seguranca['std_venda_dia']:.4f} Ã— âˆš{seguranca['lead_time']}")
        print(f"Estoque de SeguranÃ§a: {seguranca['estoque_seguranca']:.0f} pÃ§s")

    def _exibir_necessidades(self, necessidades):
        """Exibe ponto de suprimento e estoque meta"""
        print(f"MÃ©dia Base: {self.resultado['vendas']['media_dia']:.4f} pÃ§s/dia")
        print(f"Boost Aplicado: {necessidades['boost_aplicado']}")
        print(f"MÃ©dia de CÃ¡lculo: {necessidades['media_calculo']:.4f} pÃ§s/dia")
        print(f"Meses de Cobertura: {necessidades['meses_cobertura']}")
        print()
        print(f"ğŸ“ Ponto de Suprimento:")
        print(f"   FÃ³rmula: MÃ©dia Ã— Lead Time + Estoque SeguranÃ§a")
        print(f"   CÃ¡lculo: {necessidades['media_calculo']:.4f} Ã— {self.resultado['seguranca']['lead_time']} + {self.resultado['seguranca']['estoque_seguranca']}")
        print(f"   Resultado: {necessidades['ponto_suprimento']:.0f} pÃ§s")
        print()
        print(f"ğŸ¯ Estoque Meta:")
        print(f"   FÃ³rmula: MÃ©dia Ã— 30 Ã— Meses Cobertura + Estoque SeguranÃ§a")
        print(f"   CÃ¡lculo: {necessidades['media_calculo']:.4f} Ã— 30 Ã— {necessidades['meses_cobertura']} + {self.resultado['seguranca']['estoque_seguranca']}")
        print(f"   Resultado: {necessidades['estoque_meta']:.0f} pÃ§s")

    def _exibir_sugestao(self, sugestao):
        """Exibe cÃ¡lculo da sugestÃ£o"""
        print(f"Estoque Meta: {self.resultado['necessidades']['estoque_meta']:.0f}")
        print(f"(-) Saldo FÃ­sico: {self.resultado['estoque']['saldo_fisico']}")
        print(f"(-) Saldo OC: {max(0, self.resultado['estoque']['saldo_oc'])}")
        print(f"(=) SugestÃ£o Bruta: {sugestao['sugestao_bruta']:.0f}")
        print()
        print(f"Necessidade LÃ­quida: {sugestao['necessidade_liquida']:.0f}")
        print(f"Lote EconÃ´mico: {self.resultado['cadastro']['lote_economico']}")
        print(f"Lotes Cheios: {sugestao['lotes_cheios']}")
        print()
        print(f"âœ… SUGESTÃƒO FINAL (antes bloqueio): {sugestao['sugestao_final']} pÃ§s")
        print(f"ğŸ’° Subtotal: R$ {sugestao['subtotal']:.2f}")

    def _exibir_score(self, score):
        """Exibe score de priorizaÃ§Ã£o"""
        print(f"Score Total: {score['score']} pontos")
        print()
        print("ComposiÃ§Ã£o:")
        for detalhe in score['detalhes']:
            print(f"  â€¢ {detalhe}")

    def _exibir_diagnostico(self, diagnostico):
        """Exibe diagnÃ³stico e validaÃ§Ãµes"""
        print(f"Cobertura Virtual: {diagnostico['cobertura_virtual_meses']:.1f} meses")
        print(f"ValidaÃ§Ã£o de Giro: {diagnostico['validacao_giro']}")
        print()

        if diagnostico['bloqueado']:
            print(f"ğŸš« COMPRA BLOQUEADA")
            print(f"   Motivo: {diagnostico['motivo_bloqueio']}")
            print(f"   SugestÃ£o Calculada: {diagnostico['sugestao_calculada']} pÃ§s")
            print(f"   SugestÃ£o Final: {diagnostico['sugestao_final']} pÃ§s")
        else:
            print(f"âœ… COMPRA APROVADA")
            print(f"   SugestÃ£o Final: {diagnostico['sugestao_final']} pÃ§s")

    def _emitir_parecer(self):
        """Emite parecer tÃ©cnico final"""
        cadastro = self.resultado['cadastro']
        estoque = self.resultado['estoque']
        vendas = self.resultado['vendas']
        classificacao = self.resultado['classificacao']
        necessidades = self.resultado['necessidades']
        sugestao = self.resultado['sugestao']
        diagnostico = self.resultado['diagnostico']
        tendencias = self.resultado['tendencias']

        print()
        print("-" * 80)
        print("ANÃLISE TÃ‰CNICA:")
        print("-" * 80)

        # AnÃ¡lise do item
        if cadastro['ativo'] == 'NÃƒO':
            print("âŒ RECOMENDAÃ‡ÃƒO: NÃƒO COMPRAR")
            print("   Produto estÃ¡ INATIVO no cadastro.")
            print("   AÃ§Ã£o sugerida: Verificar se deve ser reativado.")
            return

        if vendas['vendas_12m'] == 0:
            if cadastro['dias_vida'] <= 365:
                print("âš ï¸  RECOMENDAÃ‡ÃƒO: AGUARDAR OU COMPRAR 1 LOTE")
                print("   Item NOVO sem vendas ainda.")
                print("   Considere comprar 1 lote para teste de mercado.")
            else:
                print("âŒ RECOMENDAÃ‡ÃƒO: NÃƒO COMPRAR")
                print("   Item VELHO sem vendas hÃ¡ mais de 12 meses.")
                print("   Produto provavelmente descontinuado.")
            return

        if diagnostico['cobertura_virtual_meses'] > 6:
            print("âš ï¸  RECOMENDAÃ‡ÃƒO: NÃƒO COMPRAR (Excesso)")
            print(f"   Cobertura atual: {diagnostico['cobertura_virtual_meses']:.1f} meses")
            print("   Risco: ObsolescÃªncia e capital parado.")
            return

        if estoque['saldo_fisico'] <= 0:
            print("ğŸš¨ PRIORIDADE MÃXIMA: RUPTURA DE ESTOQUE")
            print(f"   SugestÃ£o: {diagnostico['sugestao_final']} pÃ§s")
            print(f"   Investimento: R$ {sugestao['subtotal']:.2f}")
            print("   AÃ§Ã£o: Comprar URGENTE!")
            return

        if sugestao['sugestao_final'] > 0:
            print("âœ… RECOMENDAÃ‡ÃƒO: COMPRAR")
            print(f"   SugestÃ£o: {diagnostico['sugestao_final']} pÃ§s")
            print(f"   Investimento: R$ {sugestao['subtotal']:.2f}")
            print(f"   Cobertura apÃ³s compra: ~{necessidades['meses_cobertura']} meses")
            print(f"   Curva ABC: {classificacao['curva_abc']} | XYZ: {classificacao['curva_xyz']}")

            if tendencias['tendencia_vendas'] == "EM ALTA":
                print("   ğŸ“ˆ TendÃªncia de vendas em ALTA")
            elif tendencias['tendencia_vendas'] == "EM QUEDA":
                print("   ğŸ“‰ AtenÃ§Ã£o: TendÃªncia de vendas em QUEDA")
        else:
            print("âœ… RECOMENDAÃ‡ÃƒO: NÃƒO COMPRAR")
            print("   Estoque atual Ã© suficiente.")
            print(f"   Cobertura: {diagnostico['cobertura_virtual_meses']:.1f} meses")

        print()
        print("=" * 80)


def main():
    """FunÃ§Ã£o principal"""

    print("=" * 80)
    print("AUDITOR DE ITEM - Sistema de Compras e Estoque")
    print("VersÃ£o Standalone - sem dependÃªncias de mÃ³dulos")
    print("=" * 80)
    print()

    # Caminhos padrÃ£o
    PROJECT_ROOT = Path.cwd()

    # Verifica se estamos na pasta correta
    if not (PROJECT_ROOT / "data").exists():
        print("âš ï¸  Pasta 'data' nÃ£o encontrada no diretÃ³rio atual")
        print(f"   DiretÃ³rio atual: {PROJECT_ROOT}")
        resposta = input("\nDeseja informar o caminho do projeto? (s/n): ").strip().lower()
        if resposta == 's':
            caminho = input("Digite o caminho completo do projeto: ").strip()
            PROJECT_ROOT = Path(caminho)
        else:
            print("âŒ OperaÃ§Ã£o cancelada")
            return

    sqlite_path = PROJECT_ROOT / "data" / "vendas.db"
    config_path = PROJECT_ROOT / "config" / "config.yaml"

    # Carrega configuraÃ§Ãµes
    config = ConfigSimples(config_path)

    # Cria auditor
    auditor = AuditorItem(sqlite_path, config)

    # Conecta ao banco
    if not auditor.conectar():
        return

    try:
        # Solicita cÃ³digo do produto
        cod_produto = input("\nDigite o CÃ“DIGO DO PRODUTO para auditar: ").strip()

        if not cod_produto:
            print("âŒ CÃ³digo nÃ£o informado!")
            return

        print()

        # Executa auditoria
        sucesso = auditor.auditar(cod_produto)

        if sucesso:
            print("\nâœ… Auditoria concluÃ­da com sucesso!")
        else:
            print("\nâŒ Auditoria falhou!")

    except KeyboardInterrupt:
        print("\n\nâš ï¸  OperaÃ§Ã£o cancelada pelo usuÃ¡rio")
    except Exception as e:
        print(f"\nâŒ ERRO: {e}")
        import traceback
        traceback.print_exc()
    finally:
        auditor.desconectar()


if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
END FILE: auditor_item_completo.py


START FILE: tests/conftest.py
--------------------------------------------------------------------------------
# tests/conftest.py
import pytest
import polars as pl
from datetime import datetime, timedelta
import sys
from pathlib import Path

# Adiciona o src ao path para importar os mÃ³dulos do sistema
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

@pytest.fixture
def config_mock():
    """Simula o objeto de configuraÃ§Ã£o carregado do YAML."""
    class MockConfig:
        def __init__(self):
            # Simula a estrutura hÃ­brida (Objeto/Dict) que o seu sistema usa
            self.compras = {'meses_cobertura': 1.5}
            self.produto = {'dias_lancamento': 60}
            self.lead_time = {'padrao_dias': 10}
            
            # Permite acesso via dicionÃ¡rio tambÃ©m (para compatibilidade com _ler_config)
            self._data = {
                'compras': self.compras,
                'produto': self.produto,
                'lead_time': self.lead_time
            }
        
        def __getitem__(self, item):
            return self._data[item]

    return MockConfig()

@pytest.fixture
def df_produto_base():
    """Retorna um DataFrame Polars bÃ¡sico para testes de cÃ¡lculo."""
    return pl.DataFrame({
        "cod_produto": ["PROD-001"],
        "data_cadastro": [datetime.now() - timedelta(days=365)], # Item velho
        "saldo_estoque": [100],
        "saldo_oc": [0],
        "media_venda_dia": [2.0],
        "std_venda_dia": [0.5],
        "lead_time_dias": [10],
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "lote_economico": [10],
        "custo_unitario": [50.0],
        "dias_sem_venda": [0],
        "ativo": ["SIM"]
    })
--------------------------------------------------------------------------------
END FILE: tests/conftest.py


START FILE: tests/integration/test_classifiers.py
--------------------------------------------------------------------------------
# tests/integration/test_classifiers.py
import pytest
import duckdb
import polars as pl
from datetime import datetime, timedelta
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier

@pytest.fixture
def db_manager_mock():
    """Cria um DuckDB em memÃ³ria com dados falsos de venda."""
    conn = duckdb.connect(":memory:")
    
    # Cria estrutura simulando o attach do SQLite
    conn.execute("CREATE SCHEMA sqlite_db")
    
    # Cria tabela de vendas fake
    conn.execute("""
        CREATE TABLE sqlite_db.vendas (
            cod_produto VARCHAR,
            data_movimento DATE,
            quantidade INTEGER,
            valor_total DECIMAL(10,2),
            cod_clifor INTEGER
        )
    """)
    
    # Classe Mock para substituir o DuckDBManager real
    class MockDB:
        def get_connection(self):
            # Retorna um context manager falso que devolve a conexÃ£o aberta
            class ConnContext:
                def __enter__(ctx): return conn
                def __exit__(ctx, exc_type, exc_val, exc_tb): pass
            return ConnContext()
            
    return MockDB()

def test_abc_classifier(db_manager_mock):
    """Testa se a classificaÃ§Ã£o ABC (Pareto 80/15/5) funciona."""
    conn = db_manager_mock.get_connection().__enter__()
    
    # Insere dados:
    # Prod A: R$ 8000 (80%)
    # Prod B: R$ 1500 (15%)
    # Prod C: R$ 500  (5%)
    hoje = datetime.now().strftime("%Y-%m-%d")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-A', '{hoje}', 10, 8000, 1)")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-B', '{hoje}', 10, 1500, 1)")
    conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-C', '{hoje}', 10, 500, 1)")
    
    classifier = ABCClassifier(db_manager_mock)
    
    # Como o ABCClassifier lÃª um arquivo SQL externo, precisamos garantir que
    # o arquivo exista. Se o teste falhar por FileNotFoundError, 
    # o caminho no ABCClassifier.__init__ precisa ser ajustado ou mockado.
    # Assumindo que o arquivo existe no disco:
    
    try:
        df = classifier.run()
        
        # ValidaÃ§Ãµes
        row_a = df.filter(pl.col("cod_produto") == "PROD-A").row(0, named=True)
        assert row_a["curva_abc"] == "A"
        
        row_b = df.filter(pl.col("cod_produto") == "PROD-B").row(0, named=True)
        assert row_b["curva_abc"] == "B"
        
    except FileNotFoundError:
        pytest.skip("Arquivo SQL abc_financeiro.sql nÃ£o encontrado no ambiente de teste")

def test_xyz_classifier_z_score(db_manager_mock, config_mock):
    """Testa a variabilidade (Coeficiente de VariaÃ§Ã£o)."""
    conn = db_manager_mock.get_connection().__enter__()
    
    # Prod X: Venda muito estÃ¡vel (10 todo dia)
    # Prod Z: Venda errÃ¡tica (0, 100, 0, 0)
    
    base_date = datetime.now()
    for i in range(10):
        dt = (base_date - timedelta(days=i)).strftime("%Y-%m-%d")
        conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-X', '{dt}', 10, 100, 1)")
        
        qtd_z = 100 if i == 0 else 0
        conn.execute(f"INSERT INTO sqlite_db.vendas VALUES ('PROD-Z', '{dt}', {qtd_z}, 100, 1)")

    classifier = XYZClassifier(db_manager_mock, config_mock)
    df = classifier.run()
    
    xyz_x = df.filter(pl.col("cod_produto") == "PROD-X")["curva_xyz"].item()
    xyz_z = df.filter(pl.col("cod_produto") == "PROD-Z")["curva_xyz"].item()
    
    assert xyz_x == "X"  # CV baixo
    assert xyz_z == "Z"  # CV alto
--------------------------------------------------------------------------------
END FILE: tests/integration/test_classifiers.py


START FILE: tests/unit/test_correcoes_estoque.py
--------------------------------------------------------------------------------
import unittest
import polars as pl
from datetime import datetime, timedelta
import sys
import os

# --- CORREÃ‡ÃƒO DO IMPORT ---
# Pega o caminho onde este arquivo de teste estÃ¡
diretorio_teste = os.path.dirname(os.path.abspath(__file__))
# Sobe dois nÃ­veis (sai de 'unit', sai de 'tests') e aponta para 'src'
caminho_src = os.path.abspath(os.path.join(diretorio_teste, '../../src'))

# Adiciona ao sistema para o Python encontrar
if caminho_src not in sys.path:
    sys.path.append(caminho_src)

# Agora o import deve funcionar corretamente
try:
    from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
    print(f"Sucesso: EstoqueMath importado de {caminho_src}")
except ImportError as e:
    print(f"ERRO CRÃTICO DE IMPORTAÃ‡ÃƒO: {e}")
    print(f"O Python procurou em: {sys.path}")
    raise e
# ---------------------------

class TestCorrecoesEstoque(unittest.TestCase):
    def setUp(self):
        # ConfiguraÃ§Ã£o Mock (Simulada) para passar nos mÃ©todos
        self.config_mock = {
            'compras': {'meses_cobertura': 1},
            'produto': {'dias_lancamento': 90}, # Produtos com mais de 90 dias nÃ£o sÃ£o "novos"
            'estoque': {'fator_z': {'X': 1.65, 'Y': 1.28, 'Z': 0.84}}
        }
        
        # Data base para simular "dias_vida" antigos
        self.data_antiga = datetime.now() - timedelta(days=500)

    def test_correcao_1_boost_anti_ruptura(self):
        """
        Teste da CorreÃ§Ã£o de LÃ³gica:
        Verifica se a regra de > 90 dias (1.5x) tem prioridade sobre a de > 30 dias (1.2x).
        Antes, o >30 sombreava o >90.
        """
        print("\n--- TESTE 1: ValidaÃ§Ã£o da LÃ³gica Boost Anti-Ruptura ---")
        
        # CenÃ¡rio: Produtos A em rutura (saldo 0) e antigos
        df_input = pl.DataFrame({
            "sku": ["ITEM_35_DIAS", "ITEM_100_DIAS"],
            "saldo_estoque": [0.0, 0.0],
            "saldo_oc": [0.0, 0.0],
            "curva_abc": ["A", "A"],
            "data_cadastro": [self.data_antiga, self.data_antiga],
            "media_venda_dia": [10.0, 10.0],
            "dias_sem_venda": [35, 100], # O ponto chave do teste
            "lead_time_dias": [10, 10],
            "estoque_seguranca": [0, 0]
        })

        # Executa o cÃ¡lculo
        df_result = EstoqueMath.calcular_necessidades(df_input, self.config_mock)
        
        # Extrai os resultados
        res_35 = df_result.filter(pl.col("sku") == "ITEM_35_DIAS")["media_calculo"][0]
        res_100 = df_result.filter(pl.col("sku") == "ITEM_100_DIAS")["media_calculo"][0]
        
        print(f"Item (35 dias sem venda) -> MÃ©dia Original: 10.0 | MÃ©dia Calculada: {res_35}")
        print(f"Item (100 dias sem venda) -> MÃ©dia Original: 10.0 | MÃ©dia Calculada: {res_100}")

        # AsserÃ§Ãµes (ValidaÃ§Ãµes)
        # 35 dias (>30) deve ter boost de 20% -> 10 * 1.2 = 12.0
        self.assertAlmostEqual(res_35, 12.0, places=2, msg="FALHA: Regra de 30 dias nÃ£o aplicada corretamente.")
        
        # 100 dias (>90) deve ter boost de 50% -> 10 * 1.5 = 15.0
        # Se a ordem estiver errada, daria 12.0 (cairia na regra de 30)
        self.assertAlmostEqual(res_100, 15.0, places=2, msg="ERRO CRÃTICO: A regra de 30 dias estÃ¡ a bloquear a regra de 90 dias!")
        print(">> SUCESSO: A ordem lÃ³gica dos boosts estÃ¡ correta.")

    def test_correcao_2_trava_zumbi(self):
        """
        Teste da CorreÃ§Ã£o de Risco:
        Verifica se produtos sem venda hÃ¡ > 180 dias tÃªm a sugestÃ£o ZERADA,
        mesmo que tenham mÃ©dia de venda alta.
        """
        print("\n--- TESTE 2: ValidaÃ§Ã£o da Trava Zumbi (Risco de NegÃ³cio) ---")
        
        df_input = pl.DataFrame({
            "sku": ["ITEM_ATIVO", "ITEM_ZUMBI"],
            "saldo_estoque": [0.0, 0.0], # Ambos precisam de compra teoricamente
            "saldo_oc": [0.0, 0.0],
            "curva_abc": ["A", "A"],
            "data_cadastro": [self.data_antiga, self.data_antiga],
            "media_venda_dia": [10.0, 10.0], # MÃ©dia alta para ambos
            "dias_sem_venda": [10, 200], # Ativo (10 dias), Zumbi (200 dias)
            "lead_time_dias": [30, 30],
            "estoque_seguranca": [0, 0]
        })

        # Executa o cÃ¡lculo
        df_result = EstoqueMath.calcular_necessidades(df_input, self.config_mock)

        # Resultados
        sugestao_ativo = df_result.filter(pl.col("sku") == "ITEM_ATIVO")["sugestao_bruta"][0]
        sugestao_zumbi = df_result.filter(pl.col("sku") == "ITEM_ZUMBI")["sugestao_bruta"][0]

        print(f"Item Ativo (10 dias parado) -> SugestÃ£o Bruta: {sugestao_ativo}")
        print(f"Item Zumbi (200 dias parado) -> SugestÃ£o Bruta: {sugestao_zumbi}")

        # ValidaÃ§Ã£o do Item Ativo (Controlo)
        # Meta aprox: 10 * 30 (cobertura) = 300. SugestÃ£o deve ser ~300 (ou com boost)
        self.assertTrue(sugestao_ativo > 0, "O item ativo deveria ter sugestÃ£o de compra.")

        # ValidaÃ§Ã£o do Item Zumbi (O Teste Real)
        self.assertEqual(sugestao_zumbi, 0.0, "ERRO CRÃTICO: O sistema sugeriu comprar um produto Zumbi!")
        print(">> SUCESSO: A Trava Zumbi funcionou e bloqueou a compra.")

if __name__ == '__main__':
    unittest.main()
--------------------------------------------------------------------------------
END FILE: tests/unit/test_correcoes_estoque.py


START FILE: tests/unit/test_estoque_math.py
--------------------------------------------------------------------------------
# tests/unit/test_estoque_math.py
import polars as pl
from datetime import datetime, timedelta
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

def test_calculo_estoque_seguranca(df_produto_base, config_mock):
    """Verifica se o cÃ¡lculo do Z-Score para XYZ estÃ¡ correto."""
    df = EstoqueMath.calcular_seguranca(df_produto_base, config_mock)
    resultado = df["estoque_seguranca"].item()
    
    # 1.65 * 0.5 * sqrt(10) approx 2.61
    assert resultado > 2.0
    assert resultado < 3.0

def test_ponto_suprimento_e_meta(df_produto_base, config_mock):
    """Testa a lÃ³gica principal de reposiÃ§Ã£o."""
    
    # Precisamos calcular a seguranÃ§a antes, pois calcular_necessidades depende dela
    df = EstoqueMath.calcular_seguranca(df_produto_base, config_mock)
    df = EstoqueMath.calcular_necessidades(df, config_mock)
    
    row = df.row(0, named=True)
    
    # Ponto Suprimento = (2 * 10) + ES(~2.6) â‰ˆ 22.6 -> Arredonda 23
    # Estoque Meta = (2 * 45) + ES(~2.6) â‰ˆ 92.6 -> Arredonda 93
    assert row["ponto_suprimento"] >= 22
    assert row["estoque_meta"] >= 92

def test_boost_anti_ruptura(df_produto_base, config_mock):
    """Valida a regra de aumentar a mÃ©dia se o item A/B estiver zerado."""
    # CenÃ¡rio: Estoque 0, Curva A, Item Antigo
    df_ruptura = df_produto_base.with_columns([
        pl.lit(0).alias("saldo_estoque"),
        pl.lit("A").alias("curva_abc"),
        pl.lit(31).alias("dias_sem_venda"), # > 30 dias parado
        pl.lit(0.0).alias("estoque_seguranca") # <--- CORREÃ‡ÃƒO: Coluna necessÃ¡ria para o cÃ¡lculo
    ])
    
    df = EstoqueMath.calcular_necessidades(df_ruptura, config_mock)
    
    media_original = 2.0
    media_calculada = df["media_calculo"].item()
    
    # Regra: Se > 30 dias sem venda, boost de 20%
    assert media_calculada == media_original * 1.20

def test_item_novo_sem_movimento(df_produto_base, config_mock):
    """Valida a lÃ³gica de diagnÃ³stico para item recÃ©m cadastrado."""
    # Item com 10 dias de vida (menor que config 60)
    df_novo = df_produto_base.with_columns([
        pl.lit(datetime.now() - timedelta(days=10)).alias("data_cadastro"),
        pl.lit(0).alias("media_venda_dia"),
        pl.lit(0).alias("saldo_estoque"),
        pl.lit(0).alias("saldo_oc"),
        pl.lit(100).alias("score") # <--- CORREÃ‡ÃƒO: Coluna necessÃ¡ria para recalculo de score
    ])
    
    # Gera sugestÃ£o forÃ§ada para testar bloqueio/liberaÃ§Ã£o
    df_novo = df_novo.with_columns(pl.lit(100).alias("sugestao_final"))
    
    df = EstoqueMath.gerar_diagnostico(df_novo, config_mock)
    diag = df["validacao_giro"].item()
    
    # Deve identificar como item novo
    assert "ITEM NOVO" in diag 
    # Item novo deve sugerir compra mÃ­nima (1 lote)
    assert df["sugestao_final"].item() == df["lote_economico"].item()
    # Score deve ser boostado para 9999
    assert df["score"].item() == 9999

def test_lote_economico(df_produto_base, config_mock):
    """Testa arredondamento para lotes."""
    # SugestÃ£o Bruta: 15
    # Lote: 10
    # Deve virar 20 (2 lotes)
    
    df = df_produto_base.with_columns([
        pl.lit(15).alias("sugestao_bruta"),
        pl.lit(10).alias("lote_economico")
    ])
    
    df = EstoqueMath.aplicar_lote_economico(df, config_mock)
    assert df["sugestao_final"].item() == 20
--------------------------------------------------------------------------------
END FILE: tests/unit/test_estoque_math.py


START FILE: tests/unit/test_validator.py
--------------------------------------------------------------------------------
import polars as pl
import pytest
from datetime import date
from compras_sistema.rule_engine.validators.input_schema import InputCalcSchema
from pandera.errors import SchemaError

def test_validador_sucesso():
    # Dados corretos
    df = pl.DataFrame({
        "cod_produto": ["A"],
        "saldo_estoque": [10],
        "saldo_oc": [0],
        "media_venda_dia": [1.5],
        "std_venda_dia": [0.1],
        "lead_time_dias": [10.0],
        "lote_economico": [12],
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "data_cadastro": [date(2023, 1, 1)]
    })
    # NÃ£o deve levantar erro
    InputCalcSchema.validate(df)

def test_validador_falha_lote_zero():
    # Lote = 0 (Erro)
    df = pl.DataFrame({
        "cod_produto": ["A"],
        "saldo_estoque": [10],
        "saldo_oc": [0],
        "media_venda_dia": [1.5],
        "std_venda_dia": [0.1],
        "lead_time_dias": [10.0],
        "lote_economico": [0], # <--- ERRO AQUI (gt=0)
        "curva_abc": ["A"],
        "curva_xyz": ["X"],
        "data_cadastro": [date(2023, 1, 1)]
    })
    
    with pytest.raises(SchemaError):
        InputCalcSchema.validate(df)
--------------------------------------------------------------------------------
END FILE: tests/unit/test_validator.py


START FILE: src/compras_sistema/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/__init__.py


START FILE: src/compras_sistema/core/reporter.py
--------------------------------------------------------------------------------
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any

class ExecutionReporter:
    """
    ResponsÃ¡vel por salvar os resultados da execuÃ§Ã£o de forma estruturada.
    Substitui o uso frÃ¡gil de 'print' para comunicaÃ§Ã£o com o Frontend.
    """
    
    def __init__(self, data_dir: Path):
        self.report_path = data_dir / "cache" / "last_run_stats.json"
        # Garante que a pasta existe
        self.report_path.parent.mkdir(parents=True, exist_ok=True)

    def salvar_stats(self, stats: Dict[str, Any]):
        """Salva as estatÃ­sticas finais em JSON atÃ´mico."""
        payload = {
            "timestamp": datetime.now().isoformat(),
            "status": "success",
            "data": stats
        }
        
        # Escrita segura (utf-8)
        with open(self.report_path, 'w', encoding='utf-8') as f:
            json.dump(payload, f, indent=2)
            
    def ler_ultimo_status(self) -> Dict[str, Any]:
        """LÃª o Ãºltimo relatÃ³rio gerado."""
        if not self.report_path.exists():
            return {}
            
        with open(self.report_path, 'r', encoding='utf-8') as f:
            return json.load(f)

    def limpar_stats_anteriores(self):
        """Remove dados antigos para evitar falsos positivos."""
        if self.report_path.exists():
            try:
                self.report_path.unlink()
            except Exception:
                pass
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/reporter.py


START FILE: src/compras_sistema/core/system_guard.py
--------------------------------------------------------------------------------
import psutil
import logging
import sys
from pathlib import Path
from datetime import datetime

class SystemGuard:
    def __init__(self, log_dir: Path):
        self.log_dir = log_dir
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.setup_logger()

    def setup_logger(self):
        filename = f"mrp_log_{datetime.now().strftime('%Y-%m-%d')}.txt"
        log_path = self.log_dir / filename
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s | %(levelname)s | %(message)s',
            handlers=[
                logging.FileHandler(log_path),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger("MRP_Guard")

    def log(self, message):
        self.logger.info(message)

    def check_memory(self, min_mb=500):
        """
        Verifica se hÃ¡ memÃ³ria RAM disponÃ­vel suficiente.
        Se houver menos que 'min_mb', avisa ou aborta.
        """
        mem = psutil.virtual_memory()
        available_mb = mem.available / (1024 * 1024)
        
        self.logger.info(f"RAM DisponÃ­vel: {available_mb:.0f} MB")

        if available_mb < min_mb:
            self.logger.warning(f"âš ï¸ PERIGO: MemÃ³ria crÃ­tica! Apenas {available_mb:.0f}MB livres.")
            self.logger.warning("âš ï¸ Feche o navegador (Chrome/Firefox) imediatamente.")
            # Opcional: input("Pressione Enter quando liberar memÃ³ria...") 
            # No seu caso, vamos apenas logar o perigo.

    def log_performance(self, task_name, start_time):
        elapsed = (datetime.now() - start_time).total_seconds()
        self.logger.info(f"â±ï¸ Tarefa '{task_name}' concluÃ­da em {elapsed:.2f} segundos.")
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/system_guard.py


START FILE: src/compras_sistema/core/config.py
--------------------------------------------------------------------------------
from pathlib import Path
from typing import Any, Dict, Union
import yaml
from pydantic import BaseModel, Field

class XYZConfig(BaseModel):
    threshold: float
    z_score: float

class LoteConfig(BaseModel):
    minima_absoluta: int
    limite_virada: float

# --- CLASSES AUXILIARES ---
class LeadTimeConfig(BaseModel):
    padrao_dias: float
    desvio_padrao: float

class ComprasConfig(BaseModel):
    meses_cobertura: float

# ----------------------------------------------------------

class ParametrosConfig(BaseModel):
    lead_time: LeadTimeConfig 
    compras: ComprasConfig
    
    historico: Dict[str, int]
    produto: Dict[str, int]
    xyz: Dict[str, XYZConfig]
    abc: Dict[str, float]
    tolerancia_abc: Dict[str, float]
    lote: LoteConfig
    outlier: Dict[str, float]
    
    # [CORREÃ‡ÃƒO 1] Mudado para float para aceitar 0.05
    giro: Dict[str, float]  
    
    risco: Dict[str, Any]
    sazonalidade: Dict[str, Any]
    ruptura: Dict[str, float]

    # [CORREÃ‡ÃƒO 2] Adicionado para suportar a Fase 2 (Fator Z)
    # Usamos Any para permitir flexibilidade na estrutura interna
    estoque: Dict[str, Any] = Field(default_factory=dict)
    
    @classmethod
    def from_yaml(cls, path: Path) -> "ParametrosConfig":
        if not path.exists():
            raise FileNotFoundError(f"Arquivo de configuraÃ§Ã£o nÃ£o encontrado: {path}")
        with open(path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        return cls(**data)

class ConfigManager:
    """Singleton para gerenciamento de configuraÃ§Ãµes."""
    
    _instance = None
    _parametros: ParametrosConfig | None = None
    _pesos_score: dict | None = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def load_configs(self, config_dir: Path):
        """Carrega todos os arquivos de configuraÃ§Ã£o."""
        self._parametros = ParametrosConfig.from_yaml(
            config_dir / "parametros.yaml"
        )
        
        score_path = config_dir / "pesos_score.yaml"
        if score_path.exists():
            with open(score_path, 'r', encoding='utf-8') as f:
                self._pesos_score = yaml.safe_load(f)
        else:
            self._pesos_score = {}

    @property
    def parametros(self) -> ParametrosConfig:
        if self._parametros is None:
            raise RuntimeError("ConfiguraÃ§Ãµes nÃ£o carregadas. Chame load_configs() primeiro.")
        return self._parametros
    
    @property
    def pesos_score(self) -> dict:
        if self._pesos_score is None:
            raise RuntimeError("Pesos de score nÃ£o carregados.")
        return self._pesos_score
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/config.py


START FILE: src/compras_sistema/core/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/core/__init__.py


START FILE: src/compras_sistema/export/excel_exporter.py
--------------------------------------------------------------------------------
import polars as pl
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)


class ExcelExporter:
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def exportar_sugestao(self, df: pl.DataFrame, filename: str = None):
        if filename is None:
            data_hoje = datetime.now().strftime("%Y%m%d_%H%M")
            filename = f"sugestao_compras_{data_hoje}.xlsx"
        
        filepath = self.output_dir / filename
        logger.info("iniciando_export_excel", path=str(filepath))
        
        # ======== ORDEM DAS COLUNAS (REORGANIZADA) ========
        cols_export = [
            "status_diagnostico",
            "cod_produto",
            "descricao",
            "ref_fornecedor",
            "marca",
            "curva_abc",
            "curva_xyz",
            "sugestao_final",           # SugestÃ£o Final (Resultado)
            
            # --- BLOCO DE ANÃLISE DO CÃLCULO ---
            "sugestao_calculada",       # 1. MatemÃ¡tica Pura
            "alerta_dados",             # 2. Auditoria (PosiÃ§Ã£o Solicitada)
            "calculado_mas_bloqueado",  # 3. Flag de Bloqueio
            "motivo_bloqueio",          # 4. RazÃ£o
            # -----------------------------------
            
            "meta_pos_compra",
            "fator_sazonal",
            "lote_economico",
            "subtotal",
            "saldo_estoque",
            "saldo_oc",
            "cobertura_virtual_meses",
            "media_venda_base",
            "media_venda_dia",
            "tendencia_vendas",
            "tendencia_clientes",
            "perfil_cliente",
            "validacao_giro",
            "custo_unitario",
            "score"
        ]
        
        cols_presentes = [c for c in cols_export if c in df.columns]
        records = df.select(cols_presentes).to_dicts()
        
        # ======== CRIAÃ‡ÃƒO DO EXCEL ========
        wb = Workbook()
        ws = wb.active
        ws.title = "Analise Compras"
        
        # Estilos Gerais
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        center_align = Alignment(horizontal="center")
        left_align = Alignment(horizontal="left")
        thin_border = Border(
            left=Side(style="thin"), right=Side(style="thin"),
            top=Side(style="thin"), bottom=Side(style="thin")
        )
        
        # Cores
        fill_green = PatternFill(start_color="CCFFCC", fill_type="solid")
        fill_yellow = PatternFill(start_color="FFFFE0", fill_type="solid")
        fill_orange = PatternFill(start_color="FFD700", fill_type="solid")
        fill_blue_light = PatternFill(start_color="E6F3FF", fill_type="solid")
        fill_implanta = PatternFill(start_color="E0FFFF", fill_type="solid")
        fill_red = PatternFill(start_color="FFB6C1", fill_type="solid")
        fill_alert = PatternFill(start_color="FFFF00", fill_type="solid") # Amarelo forte
        
        # Mapeamento de nomes
        mapa_nomes = {
            "ALERTA_DADOS": "âš ï¸ ALERTA DADOS",
            "META_POS_COMPRA": "POSIÃ‡ÃƒO FINAL",
            "FATOR_SAZONAL": "IDX SAZONAL",
            "MEDIA_VENDA_DIA": "GIRO DIA (AJUST)",
            "MEDIA_VENDA_BASE": "GIRO DIA (BASE)",
            "COBERTURA_VIRTUAL_MESES": "COBERTURA MESES",
            "REF_FORNECEDOR": "REF. FABRICA",
            "SUGESTAO_CALCULADA": "CALC. ORIGINAL",
            "CALCULADO_MAS_BLOQUEADO": "BLOQUEADO?",
            "MOTIVO_BLOQUEIO": "MOTIVO BLOQUEIO"
        }
        
        headers = [c.replace("_", " ").upper() for c in cols_presentes]
        headers = [mapa_nomes.get(h, h) for h in headers]
        
        ws.append(headers)
        
        # Formata cabeÃ§alho
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_align
        
        # Preenche dados
        for row_idx, row_data in enumerate(records, 2):
            for col_idx, col_name in enumerate(cols_presentes, 1):
                val = row_data[col_name]
                cell = ws.cell(row=row_idx, column=col_idx, value=val)
                cell.border = thin_border
                
                # Alinhamento
                if col_name == "descricao":
                    cell.alignment = left_align
                else:
                    cell.alignment = center_align
                
                # FormataÃ§Ã£o numÃ©rica
                if col_name in ["custo_unitario", "subtotal"]:
                    cell.number_format = 'R$ #,##0.00'
                elif col_name in ["media_venda_dia", "media_venda_base", "fator_sazonal"]:
                    cell.number_format = '0.00'
                elif col_name in ["cobertura_virtual_meses"]:
                    cell.number_format = '0.0'
                elif col_name == "score":
                    cell.number_format = '#,##0'
                
                # ======== FORMATAÃ‡ÃƒO CONDICIONAL ========
                
                # 1. ALERTA DE DADOS
                if col_name == "alerta_dados" and val:
                    cell.font = Font(bold=True, color="FF0000")
                    cell.fill = fill_alert
                
                # 2. SugestÃµes de compra
                if col_name in ["sugestao_final", "subtotal"] and row_data.get("sugestao_final", 0) > 0:
                    cell.font = Font(bold=True, color="006400")
                    cell.fill = fill_green
                
                # 3. Produtos bloqueados
                if col_name == "calculado_mas_bloqueado" and val == "SIM":
                    cell.fill = fill_red
                    cell.font = Font(bold=True, color="8B0000")
                
                # 4. Motivo do bloqueio
                if col_name == "motivo_bloqueio" and val:
                    cell.font = Font(color="DC143C", italic=True)
                
                # 5. Fator sazonal
                if col_name == "fator_sazonal":
                    if isinstance(val, (int, float)):
                        if val < 0.90:
                            cell.font = Font(color="0000FF")
                            cell.fill = fill_blue_light
                        elif val > 1.10:
                            cell.font = Font(color="B22222", bold=True)
                
                # 6. Status diagnÃ³stico
                if col_name == "status_diagnostico":
                    val_str = str(val).upper()
                    if "IMPLANTAÃ‡ÃƒO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "RUPTURA" in val_str:
                        cell.fill = PatternFill(start_color="FF0000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "BLOQUEADO" in val_str:
                        cell.fill = PatternFill(start_color="808080", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "INATIVO" in val_str:
                        cell.fill = PatternFill(start_color="000000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "ALERTA" in val_str:
                        cell.fill = PatternFill(start_color="FF8C00", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "EXCESSO" in val_str:
                        cell.fill = fill_yellow
                    elif "COMPRAR" in val_str:
                        cell.fill = fill_green
                
                # 7. TendÃªncia
                if col_name == "tendencia_vendas":
                    val_str = str(val).upper()
                    if "ALTA" in val_str:
                        cell.font = Font(color="006400", bold=True)
                    elif "QUEDA" in val_str:
                        cell.font = Font(color="FF0000", bold=True)
                
                # 8. ValidaÃ§Ã£o Giro
                if col_name == "validacao_giro":
                    val_str = str(val)
                    if "ITEM NOVO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "SEM MOVIMENTO" in val_str:
                        cell.font = Font(color="808080", italic=True)
                    elif "Excesso" in val_str:
                        cell.font = Font(bold=True, color="B22222")
                        cell.fill = fill_orange
        
        # Ajuste de largura
        for col_idx, column_cells in enumerate(ws.columns, 1):
            max_length = 0
            column = get_column_letter(col_idx)
            limit = 60 if cols_presentes[col_idx-1] == "descricao" else 40
            
            for cell in column_cells:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            ws.column_dimensions[column].width = min(max_length + 3, limit)
        
        wb.save(filepath)
        logger.info("export_excel_concluido")
        return filepath
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/export/excel_exporter.py


START FILE: src/compras_sistema/data_engine/analytics_service.py
--------------------------------------------------------------------------------
import polars as pl
import duckdb
from datetime import datetime

class AnalyticsService:
    def __init__(self, db_manager):
        """
        ServiÃ§o de InteligÃªncia de Dados.
        ResponsÃ¡vel por transformar dados brutos do DuckDB em KPIs e TendÃªncias.
        """
        self.db_manager = db_manager

    def _obter_conexao_segura(self):
        """Garante que a conexÃ£o seja extraÃ­da corretamente do db_manager."""
        try:
            return self.db_manager.get_connection()
        except Exception as e:
            if "inicializado" in str(e).lower():
                raise RuntimeError("DuckDB nÃ£o inicializado. Chame initialize() no Launcher.")
            raise e

    def get_kpis_atuais(self, marca="TODAS"):
        """
        Calcula os KPIs financeiros e operacionais do Ãºltimo snapshot.
        Permite filtragem dinÃ¢mica por marca.
        """
        try:
            # SQL dinÃ¢mico para filtragem por marca
            condicao_marca = "" if marca == "TODAS" else f"AND marca = '{marca}'"
            
            query = f"""
                WITH ultimo_snapshot AS (
                    SELECT MAX(data_snapshot) as data_viga FROM historico_snapshots
                )
                SELECT 
                    CAST(MAX(data_snapshot) AS TIMESTAMP) as data_referencia,
                    SUM(saldo_estoque * custo_unitario) as valor_estoque,
                    SUM(sugestao_final * custo_unitario) as investimento_pendente,
                    AVG(cobertura_meses) as cobertura_media
                FROM historico_snapshots
                WHERE data_snapshot = (SELECT data_viga FROM ultimo_snapshot)
                {condicao_marca}
            """
            
            print(f"ğŸ” [Analytics] Buscando KPIs atuais para marca: {marca}")
            
            with self._obter_conexao_segura() as conn:
                res = conn.execute(query).df()
            
            if res.empty or res["valor_estoque"][0] is None:
                print(f"âš ï¸ [Analytics] Nenhum dado encontrado para a marca: {marca}")
                return {
                    "status": "vazio",
                    "data_referencia": datetime.now(),
                    "valor_estoque": 0.0,
                    "investimento_pendente": 0.0,
                    "cobertura_media": 0.0
                }

            return {
                "status": "ok",
                "data_referencia": res["data_referencia"][0],
                "valor_estoque": float(res["valor_estoque"][0]),
                "investimento_pendente": float(res["investimento_pendente"][0]),
                "cobertura_media": float(res["cobertura_media"][0])
            }

        except Exception as e:
            print(f"âŒ [Analytics] Erro crÃ­tico ao buscar KPIs: {str(e)}")
            return {"status": "erro", "erro_msg": str(e)}

    def get_tendencia_cobertura(self, marca="TODAS", dias_historico=90):
        """Busca a evoluÃ§Ã£o da cobertura por Curva ABC para o grÃ¡fico."""
        try:
            condicao_marca = "" if marca == "TODAS" else f"WHERE marca = '{marca}'"
            
            query = f"""
                SELECT 
                    CAST(data_snapshot AS DATE) as data,
                    curva_abc,
                    AVG(cobertura_meses) as cobertura_meses
                FROM historico_snapshots
                {condicao_marca}
                GROUP BY 1, 2
                HAVING data >= CURRENT_DATE - INTERVAL {dias_historico} DAY
                ORDER BY 1 ASC, 2 ASC
            """
            
            print(f"ğŸ“ˆ [Analytics] Gerando tendÃªncia de cobertura (Marca: {marca})")
            
            with self._obter_conexao_segura() as conn:
                return conn.execute(query).pl()

        except Exception as e:
            print(f"âŒ [Analytics] Erro ao processar tendÃªncia: {str(e)}")
            return pl.DataFrame()
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/analytics_service.py


START FILE: src/compras_sistema/data_engine/duckdb_manager.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path
from contextlib import contextmanager
from threading import Lock
import structlog
import sys

logger = structlog.get_logger(__name__)

class DuckDBManager:
    """
    Gerenciador singleton de conexÃµes DuckDB.
    Refatorado (Fase 1.3): Inclui Health Check para garantir integridade do banco.
    """
    
    def __init__(self, memory_limit: str = "2GB", threads: int = 4):
        self.memory_limit = memory_limit
        self.threads = threads
        self._conn = None
        self._lock = Lock()
        
    def initialize(self, sqlite_path: Path):
        """
        Inicializa conexÃ£o DuckDB, anexa o SQLite e VALIDA a estrutura.
        Se falhar, aborta o sistema imediatamente.
        """
        # 1. ValidaÃ§Ã£o FÃ­sica
        if not sqlite_path.exists():
            msg = f"CRÃTICO: Banco de dados nÃ£o encontrado em {sqlite_path}"
            logger.critical("db_not_found", path=str(sqlite_path))
            raise FileNotFoundError(msg)

        with self._lock:
            # Se jÃ¡ existe conexÃ£o, fecha para reiniciar limpo
            if self._conn is not None:
                try: self._conn.close()
                except: pass
                
            try:
                self._conn = duckdb.connect(":memory:")
                
                # ConfiguraÃ§Ãµes de performance
                self._conn.execute(f"SET memory_limit='{self.memory_limit}'")
                self._conn.execute(f"SET threads TO {self.threads}")
                self._conn.execute("SET enable_progress_bar=true")
                
                # 2. Attach SQLite (FederaÃ§Ã£o)
                logger.info("connecting_sqlite", path=str(sqlite_path))
                self._conn.execute(f"""
                    ATTACH '{str(sqlite_path)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)
                """)
                
                # 3. HEALTH CHECK (A Blindagem Nova)
                self._validar_tabelas_criticas()
                
                logger.info("duckdb_initialized_successfully")

            except Exception as e:
                # Se algo der errado, matamos a conexÃ£o para nÃ£o deixar um objeto "zumbi"
                if self._conn:
                    try: self._conn.close()
                    except: pass
                self._conn = None
                
                logger.critical("duckdb_init_failed", error=str(e))
                raise RuntimeError(f"Falha CrÃ­tica na InicializaÃ§Ã£o do Banco: {e}")

    def _validar_tabelas_criticas(self):
        """Verifica se as tabelas essenciais existem no banco anexado."""
        tabelas_necessarias = ["saldo_custo_entrada", "produtos_gerais"]
        
        # Pega todas as tabelas do schema sqlite_db
        # Nota: DuckDB usa information_schema
        try:
            # Lista tabelas no schema anexado
            df_tables = self._conn.execute("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_catalog = 'sqlite_db'
            """).pl()
            
            tabelas_existentes = [t.lower() for t in df_tables["table_name"].to_list()]
            
            for necessaria in tabelas_necessarias:
                if necessaria.lower() not in tabelas_existentes:
                    raise ValueError(f"Tabela obrigatÃ³ria '{necessaria}' nÃ£o encontrada no banco de dados!")
                    
            logger.info("schema_validation_passed", tables=tabelas_necessarias)
            
        except Exception as e:
            # Re-lanÃ§a como erro de validaÃ§Ã£o claro
            raise ValueError(f"O banco de dados parece corrompido ou incompleto: {e}")

    @contextmanager
    def get_connection(self):
        """Context manager para obter conexÃ£o thread-safe."""
        with self._lock:
            if self._conn is None:
                raise RuntimeError("ERRO INTERNO: Tentativa de usar DuckDB sem inicializaÃ§Ã£o (initialize() nÃ£o foi chamado ou falhou).")
            yield self._conn

    def execute_query_file(self, query_file: Path) -> duckdb.DuckDBPyRelation:
        """Executa query SQL de arquivo."""
        if not query_file.exists():
            raise FileNotFoundError(f"Arquivo de query nÃ£o encontrado: {query_file}")

        with open(query_file, 'r', encoding='utf-8') as f:
            query = f.read()
        
        with self.get_connection() as conn:
            return conn.execute(query)

    def close(self):
        """Fecha conexÃ£o DuckDB."""
        with self._lock:
            if self._conn:
                try:
                    self._conn.close()
                except Exception as e:
                    logger.warning("error_closing_connection", error=str(e))
                finally:
                    self._conn = None
                    logger.info("duckdb_closed")
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/duckdb_manager.py


START FILE: src/compras_sistema/data_engine/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/__init__.py


START FILE: src/compras_sistema/data_engine/history_recorder.py
--------------------------------------------------------------------------------
import polars as pl
import duckdb
from datetime import datetime
from pathlib import Path
import json
import structlog
from typing import Dict, Any

logger = structlog.get_logger(__name__)

class HistoryRecorder:
    """
    Grava o histÃ³rico de execuÃ§Ãµes para auditoria e anÃ¡lise de tendÃªncias.
    PadrÃ£o Arquitetural: Header-Detail (Mestre-Detalhe).
    """
    
    def __init__(self, db_manager):
        # Usamos um arquivo separado para nÃ£o pesar o banco transacional principal
        self.history_db_path = Path("data/analytics.duckdb")
        self.db_manager = db_manager
        # Garante que a pasta data existe
        self.history_db_path.parent.mkdir(parents=True, exist_ok=True)

    def inicializar_tabela(self):
        """Cria o esquema relacional (Header e Detalhes) se nÃ£o existir."""
        try:
            with duckdb.connect(str(self.history_db_path)) as conn:
                # 1. SequÃªncia para gerar IDs Ãºnicos de execuÃ§Ã£o
                conn.execute("CREATE SEQUENCE IF NOT EXISTS seq_execucao_id")

                # 2. Tabela HEADER (Metadados da ExecuÃ§Ã£o)
                # Guarda QUEM rodou, QUANDO, com quais PARÃ‚METROS e TOTAIS.
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS historico_execucoes (
                        id_execucao INTEGER PRIMARY KEY DEFAULT nextval('seq_execucao_id'),
                        data_registro TIMESTAMP,
                        marca_filtro VARCHAR,
                        usuario VARCHAR,
                        total_sugestao_valor DOUBLE,
                        total_itens_comprar INTEGER,
                        config_snapshot JSON  -- O "Segredo": salva como estava o YAML no momento
                    )
                """)

                # 3. Tabela DETALHES (Os Produtos em si)
                # Guarda o estado de cada item naquele momento.
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS historico_detalhes (
                        id_execucao INTEGER, -- Chave Estrangeira (Virtual)
                        cod_produto VARCHAR,
                        descricao VARCHAR,
                        curva_abc VARCHAR,
                        curva_xyz VARCHAR,
                        saldo_estoque INTEGER,
                        saldo_oc INTEGER,
                        media_venda_dia DOUBLE,
                        custo_unitario DOUBLE,
                        sugestao_final INTEGER,
                        fator_z DOUBLE,
                        motivo_bloqueio VARCHAR
                    )
                """)
                
                logger.info("schema_historico_verificado", path=str(self.history_db_path))
                
        except Exception as e:
            logger.error("erro_inicializar_historico", error=str(e))

    def gravar_snapshot(self, df_final: pl.DataFrame, context_data: Dict[str, Any]):
        """
        Grava uma execuÃ§Ã£o completa (Header + Detalhes).
        
        Args:
            df_final: DataFrame com os produtos calculados.
            context_data: DicionÃ¡rio contendo metadados (marca, config, stats).
        """
        try:
            logger.info("iniciando_gravacao_historico")
            
            # ExtraÃ§Ã£o de Contexto
            marca = context_data.get('marca', 'TODAS')
            usuario = context_data.get('usuario', 'SYSTEM')
            stats = context_data.get('stats', {})
            config_dict = context_data.get('config', {}) # ConfiguraÃ§Ã£o completa em dict

            # Prepara JSON de config (converte objetos Pydantic se necessÃ¡rio)
            if hasattr(config_dict, 'model_dump_json'):
                config_json = config_dict.model_dump_json()
            else:
                config_json = json.dumps(config_dict, default=str)

            with duckdb.connect(str(self.history_db_path)) as conn:
                # --- PASSO 1: INSERIR HEADER E PEGAR ID ---
                # Usamos RETURNING id_execucao para saber qual ID foi gerado
                query_header = """
                    INSERT INTO historico_execucoes (
                        data_registro, marca_filtro, usuario, 
                        total_sugestao_valor, total_itens_comprar, config_snapshot
                    ) VALUES (
                        current_timestamp, ?, ?, ?, ?, ?
                    ) RETURNING id_execucao
                """
                
                # Executa e pega o ID gerado
                id_execucao = conn.execute(query_header, [
                    marca, 
                    usuario, 
                    stats.get('total_valor', 0.0),
                    stats.get('total_skus', 0),
                    config_json
                ]).fetchone()[0]
                
                logger.info("historico_header_criado", id=id_execucao)

                # --- PASSO 2: PREPARAR DATAFRAME DE DETALHES ---
                # Adiciona o ID da execuÃ§Ã£o em todas as linhas
                df_detalhes = df_final.with_columns(
                    pl.lit(id_execucao).alias("id_execucao")
                )

                # Seleciona e renomeia colunas para bater com a tabela SQL
                # Garante que campos opcionais existam
                cols_necessarias = [
                    "id_execucao", "cod_produto", "descricao", 
                    "curva_abc", "curva_xyz", 
                    "saldo_estoque", "saldo_oc", "media_venda_dia", "custo_unitario", 
                    "sugestao_final", "fator_z", "motivo_bloqueio"
                ]
                
                # Preenche colunas faltantes com null/default para nÃ£o quebrar o insert
                for col in cols_necessarias:
                    if col not in df_detalhes.columns:
                        df_detalhes = df_detalhes.with_columns(pl.lit(None).alias(col))

                # Ordena colunas para inserÃ§Ã£o
                df_insert = df_detalhes.select(cols_necessarias)

                # --- PASSO 3: INSERT BULK (Alta Performance) ---
                # O DuckDB permite inserir direto de um DataFrame Polars
                conn.register("view_temp_insert", df_insert)
                conn.execute("INSERT INTO historico_detalhes SELECT * FROM view_temp_insert")
                conn.unregister("view_temp_insert")
                
                logger.info("historico_detalhes_gravado", linhas=len(df_insert))

        except Exception as e:
            logger.error("erro_fatal_gravacao_historico", error=str(e))
            # NÃ£o damos raise aqui para nÃ£o travar a geraÃ§Ã£o do Excel se o log falhar
            # Mas o erro fica registrado no structlog
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/history_recorder.py


START FILE: src/compras_sistema/data_engine/queries/abc_financeiro.sql
--------------------------------------------------------------------------------
/*
  CÃ¡lculo da Curva ABC Financeira (Pareto)
  Regra: 
    A = AtÃ© 80% do faturamento acumulado
    B = De 80% atÃ© 95%
    C = Restante
*/

WITH vendas_por_produto AS (
    SELECT 
        cod_produto,
        SUM(valor_total) as total_vendido
    FROM sqlite_db.vendas
    WHERE 
        -- Converte texto para data e pega os Ãºltimos 12 meses
        TRY_CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '12 months')
    GROUP BY cod_produto
    HAVING total_vendido > 0
),

calculo_acumulado AS (
    SELECT 
        cod_produto,
        total_vendido,
        -- Soma acumulada ordenada do maior para o menor
        SUM(total_vendido) OVER (ORDER BY total_vendido DESC) as valor_acumulado,
        -- Valor total geral de todas as vendas
        SUM(total_vendido) OVER () as valor_total_geral
    FROM vendas_por_produto
)

SELECT 
    cod_produto,
    total_vendido,
    valor_acumulado,
    (valor_acumulado / valor_total_geral) as percentual_acumulado,
    CASE 
        WHEN (valor_acumulado / valor_total_geral) <= 0.80 THEN 'A'
        WHEN (valor_acumulado / valor_total_geral) <= 0.95 THEN 'B'
        ELSE 'C'
    END as curva_abc
FROM calculo_acumulado
ORDER BY total_vendido DESC;
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/queries/abc_financeiro.sql


START FILE: src/compras_sistema/data_engine/queries/estatisticas_vendas.sql
--------------------------------------------------------------------------------
/*
  CÃ¡lculo de EstatÃ­sticas AvanÃ§adas: TendÃªncias e ValidaÃ§Ã£o de Giro (12m)
  CorreÃ§Ã£o: ReintroduÃ§Ã£o da coluna dias_com_venda necessÃ¡ria para o XYZ.
*/

WITH vendas_tratadas AS (
    SELECT 
        cod_produto,
        TRY_CAST(data_movimento AS DATE) as data_venda,
        quantidade,
        cod_clifor,
        MAX(ref_fornecedor) OVER (PARTITION BY cod_produto) as ref_fornecedor,
        MAX(marca) OVER (PARTITION BY cod_produto) as marca
    FROM sqlite_db.vendas
    WHERE 
        -- Pega histÃ³rico longo para cÃ¡lculo de Dias de Vida
        TRY_CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '48 months')
),

periodos AS (
    SELECT
        cod_produto,
        MAX(marca) as marca,
        MAX(ref_fornecedor) as ref_fornecedor,
        
        -- PerÃ­odos Curtos para TendÃªncia (90 dias)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '90 days') THEN quantidade ELSE 0 END) as qtd_trimestre_atual,
        COUNT(DISTINCT CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '90 days') THEN cod_clifor END) as clientes_trimestre_atual,
        SUM(CASE WHEN data_venda < (CURRENT_DATE - INTERVAL '90 days') AND data_venda >= (CURRENT_DATE - INTERVAL '180 days') THEN quantidade ELSE 0 END) as qtd_trimestre_anterior,
        COUNT(DISTINCT CASE WHEN data_venda < (CURRENT_DATE - INTERVAL '90 days') AND data_venda >= (CURRENT_DATE - INTERVAL '180 days') THEN cod_clifor END) as clientes_trimestre_anterior,

        -- Venda 12 Meses (CrÃ­tico para ValidaÃ§Ã£o de Giro)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '12 months') THEN quantidade ELSE 0 END) as venda_total_12m,

        -- Dados Gerais (Baseados no parametro meses_analise)
        SUM(CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '{meses_analise} months') THEN quantidade ELSE 0 END) as total_vendido,
        
        -- A COLUNA QUE FALTAVA FOI REINSERIDA ABAIXO:
        COUNT(DISTINCT CASE WHEN data_venda >= (CURRENT_DATE - INTERVAL '{meses_analise} months') THEN data_venda END) as dias_com_venda,
        
        MAX(data_venda) as ultima_venda,
        MIN(data_venda) as primeira_venda,
        COUNT(DISTINCT cod_clifor) as total_clientes_unicos,
        STDDEV_POP(quantidade) as std_venda_dia_amostra
    FROM vendas_tratadas
    GROUP BY cod_produto
)

SELECT 
    *,
    DATE_DIFF('day', primeira_venda, ultima_venda) + 1 as dias_intervalo,
    CASE 
        WHEN (DATE_DIFF('day', primeira_venda, ultima_venda) + 1) <= 1 THEN total_vendido 
        ELSE CAST(total_vendido AS DOUBLE) / (DATE_DIFF('day', primeira_venda, ultima_venda) + 1)
    END as media_venda_dia,
    COALESCE(std_venda_dia_amostra, 0.0) as std_venda_dia
FROM periodos;

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/data_engine/queries/estatisticas_vendas.sql


START FILE: src/compras_sistema/utils/sanitizer.py
--------------------------------------------------------------------------------
# Arquivo: src/compras_sistema/utils/sanitizer.py
import polars as pl
import logging

def sanear_dados_dataframe(df: pl.DataFrame) -> pl.DataFrame:
    """
    Blindagem de Dados (RefatoraÃ§Ã£o Fase 1):
    Garante que nÃºmeros crÃ­ticos para a matemÃ¡tica nÃ£o quebrem o cÃ¡lculo.
    """
    logger = logging.getLogger("Sanitizer")
    
    # ValidaÃ§Ã£o prÃ©via para evitar erro se dataframe estiver vazio
    if df.height == 0:
        return df

    # 1. Lead Time: NÃ£o pode ser negativo. Se for, assume 0.
    if "lead_time_dias" in df.columns:
        qtd_negativos = df.filter(pl.col("lead_time_dias") < 0).height
        if qtd_negativos > 0:
            logger.warning(f"âš ï¸ BLINDAGEM: Encontrados {qtd_negativos} produtos com Lead Time negativo. ForÃ§ados para 0.")
            
        df = df.with_columns(
            pl.when(pl.col("lead_time_dias") < 0)
            .then(0)
            .otherwise(pl.col("lead_time_dias"))
            .alias("lead_time_dias")
        )
    
    # 2. MÃ©dia de Venda: Nulo vira 0.0
    if "media_venda_dia" in df.columns:
        df = df.with_columns(
            pl.col("media_venda_dia").fill_null(0.0)
        )
    
    # 3. Estoque e OC: Nulos viram 0
    cols_zero = ["saldo_estoque", "saldo_oc"]
    cols_existentes = [c for c in cols_zero if c in df.columns]
    
    if cols_existentes:
        df = df.with_columns([
            pl.col(c).fill_null(0) for c in cols_existentes
        ])
    
    return df
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/utils/sanitizer.py


START FILE: src/compras_sistema/utils/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/utils/__init__.py


START FILE: src/compras_sistema/rule_engine/base_rule.py
--------------------------------------------------------------------------------
from abc import ABC, abstractmethod
import polars as pl
from typing import Dict, Any

class BaseRule(ABC):
    """
    Classe abstrata para todas as regras de negÃ³cio.
    Garante que toda regra tenha um mÃ©todo 'apply'.
    """
    
    @abstractmethod
    def apply(self, df: pl.LazyFrame, config: Any) -> pl.LazyFrame:
        """
        Aplica a regra de negÃ³cio ao DataFrame.
        """
        pass
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/base_rule.py


START FILE: src/compras_sistema/rule_engine/stock/estoque_math.py
--------------------------------------------------------------------------------
import polars as pl
import numpy as np
from datetime import datetime

class EstoqueMath:
    """Classe com mÃ©todos estÃ¡ticos para cÃ¡lculos de estoque (Refatorada Fases 2 e 3)"""
    
    @staticmethod
    def _ler_config(objeto_config, atributo_ou_chave):
        """Tenta ler uma configuraÃ§Ã£o seja ela um Atributo (Objeto) ou Chave (Dict)."""
        try:
            return getattr(objeto_config, atributo_ou_chave)
        except AttributeError:
            # Suporte a dicionÃ¡rios aninhados e acesso seguro
            try:
                return objeto_config[atributo_ou_chave]
            except (KeyError, TypeError):
                raise Exception(f"ConfiguraÃ§Ã£o '{atributo_ou_chave}' nÃ£o encontrada")

    @staticmethod
    def aplicar_sazonalidade_projetada(df: pl.DataFrame, indices_dict: dict) -> pl.DataFrame:
        """Calcula o fator sazonal baseando-se na DATA DE CHEGADA da mercadoria."""
        if not indices_dict or len(indices_dict) != 12:
            return df.with_columns(pl.lit(1.0).alias("fator_sazonal_projetado"))
        
        lista_indices = [indices_dict.get(m, 1.0) for m in range(1, 13)]
        mes_atual = datetime.now().month
        
        def calcular_fator_futuro(leadtime):
            if leadtime is None:
                leadtime = 7
            
            meses_espera = leadtime / 30.0
            duracao_estoque = 1.5
            soma_indices = 0.0
            pontos_verificados = 0
            cursor = meses_espera
            fim_janela = meses_espera + duracao_estoque
            
            while cursor < fim_janela:
                mes_futuro_absoluto = mes_atual + int(cursor)
                index_lista = (mes_futuro_absoluto - 1) % 12
                soma_indices += lista_indices[index_lista]
                pontos_verificados += 1
                cursor += 0.5
            
            if pontos_verificados == 0:
                return 1.0
            
            fator = soma_indices / pontos_verificados
            return max(0.5, min(fator, 2.5))
        
        return df.with_columns([
            pl.col("lead_time_dias").map_elements(
                calcular_fator_futuro, return_dtype=pl.Float64
            ).alias("fator_sazonal_projetado")
        ])

    @staticmethod
    def calcular_tendencias(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula as classificaÃ§Ãµes de TendÃªncia e Perfil de Cliente."""
        if "var_vendas" not in df.columns:
            df = df.with_columns([
                pl.lit(0.0).alias("var_vendas"),
                pl.lit(0).alias("saldo_clientes"),
                pl.lit(0).alias("qtd_clientes_ativos")
            ])
        
        return df.with_columns([
            pl.when(pl.col("var_vendas").fill_null(0.0) > 0.20).then(pl.lit("EM ALTA"))
            .when(pl.col("var_vendas").fill_null(0.0) < -0.20).then(pl.lit("EM QUEDA"))
            .otherwise(pl.lit("ESTÃVEL")).alias("tendencia_vendas"),
            
            pl.when(pl.col("saldo_clientes").fill_null(0) > 0)
            .then(pl.format("GANHO +{}", pl.col("saldo_clientes")))
            .when(pl.col("saldo_clientes").fill_null(0) < 0)
            .then(pl.format("PERDA {}", pl.col("saldo_clientes")))
            .otherwise(pl.lit("MANTEVE")).alias("tendencia_clientes"),
            
            pl.when(pl.col("qtd_clientes_ativos").fill_null(0) == 0).then(pl.lit("Sem Venda"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 2).then(pl.lit("Dedicado (1-2)"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 9).then(pl.lit("Concentrado (3-9)"))
            .otherwise(pl.lit("Pulverizado (10+)")).alias("perfil_cliente")
        ])

    @staticmethod
    def calcular_seguranca(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Estoque de SeguranÃ§a (Refatorado FASE 2 - Config DinÃ¢mica)."""
        # --- LÃ³gica de Leitura de ConfiguraÃ§Ã£o com Fallback ---
        try:
            cfg_estoque = EstoqueMath._ler_config(config, 'estoque')
            cfg_fatores = EstoqueMath._ler_config(cfg_estoque, 'fator_z')
            z_x = float(EstoqueMath._ler_config(cfg_fatores, 'X'))
            z_y = float(EstoqueMath._ler_config(cfg_fatores, 'Y'))
            z_z = float(EstoqueMath._ler_config(cfg_fatores, 'Z'))
        except Exception:
            z_x, z_y, z_z = 1.65, 1.28, 0.84

        def get_z_factor(xyz):
            if xyz == "X": return z_x
            if xyz == "Y": return z_y
            return z_z
        
        return df.with_columns([
            pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64).alias("fator_z"),
            (
                pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64) *
                pl.col("std_venda_dia") *
                pl.col("lead_time_dias").fill_null(7).sqrt()
            ).fill_null(0).alias("estoque_seguranca")
        ])

    @staticmethod
    def calcular_necessidades(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Ponto de Suprimento e Estoque Meta (COM TRAVA ZUMBI)."""
        cfg_compras = EstoqueMath._ler_config(config, 'compras')
        cfg_produto = EstoqueMath._ler_config(config, 'produto')
        meses_cobertura = EstoqueMath._ler_config(cfg_compras, 'meses_cobertura')
        dias_novo = EstoqueMath._ler_config(cfg_produto, 'dias_lancamento')
        
        # Cria a coluna dias_vida
        df = df.with_columns([
            (pl.lit(datetime.now()) - pl.col("data_cadastro").cast(pl.Datetime)).dt.total_days().alias("dias_vida")
        ])
        
        # Calcula a mÃ©dia ajustada (Boost anti-ruptura jÃ¡ estÃ¡ correto aqui)
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                pl.col("curva_abc").is_in(["A", "B"]) &
                (pl.col("dias_vida") > dias_novo) 
            )
            .then(
                pl.when(pl.col("dias_sem_venda") > 90).then(pl.col("media_venda_dia") * 1.50)
                .when(pl.col("dias_sem_venda") > 30).then(pl.col("media_venda_dia") * 1.20)
                .otherwise(pl.col("media_venda_dia") * 2.00)
            )
            .otherwise(pl.col("media_venda_dia"))
            .alias("media_calculo")
        ])
        
        # Calcula os alvos
        df = df.with_columns([
            (pl.col("media_calculo") * pl.col("lead_time_dias") + pl.col("estoque_seguranca")).round(0).alias("ponto_suprimento"),
            (pl.col("media_calculo") * 30 * meses_cobertura + pl.col("estoque_seguranca")).round(0).alias("estoque_meta")
        ])

        # --- ALTERAÃ‡ÃƒO AQUI: IMPLEMENTAÃ‡ÃƒO DA TRAVA ZUMBI ---
        return df.with_columns([
            pl.when(pl.col("dias_sem_venda") > 180) # Se nÃ£o vende hÃ¡ 6 meses
            .then(0.0)                              # Mata a sugestÃ£o (Zumbi)
            .otherwise(                             # Caso contrÃ¡rio, segue o cÃ¡lculo normal
                pl.col("estoque_meta") - pl.col("saldo_estoque") - pl.col("saldo_oc")
            ).alias("sugestao_bruta")
        ])
        
    @staticmethod
    def aplicar_lote_economico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Arredonda para lotes econÃ´micos usando Limite de Virada."""
        cfg_lote = EstoqueMath._ler_config(config, 'lote')
        limite = EstoqueMath._ler_config(cfg_lote, 'limite_virada')

        return df.with_columns([
            pl.when(pl.col("sugestao_bruta") <= 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("necessidade_liquida")
        ]).with_columns([
            (pl.col("necessidade_liquida") % pl.col("lote_economico")).alias("resto")
        ]).with_columns([
            pl.when(pl.col("resto") < (pl.col("lote_economico") * limite))
            .then((pl.col("necessidade_liquida") / pl.col("lote_economico")).floor())
            .otherwise((pl.col("necessidade_liquida") / pl.col("lote_economico")).ceil())
            .alias("lotes_cheios")
        ]).with_columns([
            (pl.col("lotes_cheios") * pl.col("lote_economico")).cast(pl.Int32).alias("sugestao_final")
        ]).with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal")
        ])

    @staticmethod
    def calcular_score(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula pontuaÃ§Ã£o de prioridade."""
        return df.with_columns([
            (
                pl.when(pl.col("saldo_estoque") == 0).then(5000).otherwise(0) +
                pl.when(pl.col("saldo_estoque") < pl.col("media_venda_dia") * pl.col("lead_time_dias")).then(2500).otherwise(0) +
                pl.when(pl.col("curva_abc") == "A").then(1000).when(pl.col("curva_abc") == "B").then(500).otherwise(100) +
                pl.when(pl.col("tendencia_vendas") == "EM ALTA").then(500).otherwise(0) +
                (pl.col("media_venda_dia") * pl.col("custo_unitario")).fill_null(0)
            ).round(0).cast(pl.Int32).alias("score")
        ])

    @staticmethod
    def gerar_diagnostico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Gera diagnÃ³sticos e bloqueios de seguranÃ§a (Refatorado FASE 3 - Config DinÃ¢mica)."""
        
        # --- 1. Leitura de ParÃ¢metros (Giro e Risco) ---
        try:
            cfg_giro = EstoqueMath._ler_config(config, 'giro')
            cfg_produto = EstoqueMath._ler_config(config, 'produto')
            
            # Limites do Config
            limite_cobertura = float(EstoqueMath._ler_config(cfg_giro, 'limite_meses_cobertura'))
            min_venda_dia = float(EstoqueMath._ler_config(cfg_giro, 'minimo_venda_dia'))
            dias_novo = int(EstoqueMath._ler_config(cfg_produto, 'dias_lancamento'))
        except Exception:
            # Fallback Seguro
            limite_cobertura = 6.0
            min_venda_dia = 0.05
            dias_novo = 180

        # --- 2. PreparaÃ§Ã£o de Colunas Auxiliares ---
        estoque_total = pl.col("saldo_estoque") + pl.col("saldo_oc")
        venda_mensal = pl.col("media_venda_dia") * 30
        
        if "dias_vida" not in df.columns:
            df = df.with_columns([
                (pl.lit(datetime.now()) - pl.col("data_cadastro").cast(pl.Datetime)).dt.total_days().alias("dias_vida")
            ])
        
        base_calc = pl.when(estoque_total == 0).then(0.0).otherwise(estoque_total / venda_mensal)
        calc_cobertura = pl.when(base_calc.is_infinite()).then(99.0).otherwise(base_calc).fill_nan(99.0)
        
        df = df.with_columns([calc_cobertura.alias("cobertura_virtual_meses")])
        
        # --- 3. AplicaÃ§Ã£o das Regras ---
        df = df.with_columns([
            pl.when((pl.col("saldo_estoque") == 0) & (pl.col("saldo_oc") == 0) & (pl.col("media_venda_dia") == 0))
                .then(
                    pl.when(pl.col("dias_vida") <= dias_novo)
                    .then(pl.lit("SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)"))
                    .otherwise(pl.lit("SEM MOVIMENTO (Item velho parado)"))
                )
                .when(pl.col("cobertura_virtual_meses") > limite_cobertura)
                .then(pl.lit(f"ALERTA: Excesso > {limite_cobertura}m"))
                .when((pl.col("media_venda_dia") < min_venda_dia) & (pl.col("sugestao_final") > 0))
                .then(pl.lit("ALERTA: Sem Venda Recente"))
                .otherwise(pl.lit("COERENTE")).alias("validacao_giro")
        ])
        
        df = df.with_columns([pl.col("sugestao_final").alias("sugestao_calculada")])
        
        # --- 4. Bloqueios ---
        df = df.with_columns([
            pl.when(pl.col("ativo") == "NO").then(pl.lit("Produto inativo no cadastro"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.col("validacao_giro"))
            .otherwise(pl.lit("")).alias("motivo_bloqueio"),
            
            pl.when((pl.col("sugestao_final") > 0) & ((pl.col("ativo") == "NO") | pl.col("validacao_giro").str.contains("ALERTA")))
            .then(pl.lit("SIM")).otherwise(pl.lit("NÃƒO")).alias("calculado_mas_bloqueado"),
            
            pl.when(pl.col("ativo") == "NO").then(0)
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)")
            .then(pl.col("lote_economico"))  
            .otherwise(pl.col("sugestao_final")).alias("sugestao_final")
        ])
        
        # --- 5. Score e Status Final ---
        df = df.with_columns([
            pl.when(pl.col("sugestao_final") == 0).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit(9999))
            .otherwise(pl.col("score")).alias("score")
        ])
        
        return df.with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal"),
            pl.when(pl.col("ativo") == "NO").then(pl.lit("INATIVO"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.lit("BLOQUEADO"))
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit("IMPLANTAÃ‡ÃƒO"))
            .when(pl.col("saldo_estoque") == 0).then(pl.lit("RUPTURA"))
            .when(pl.col("sugestao_final") > 0).then(pl.lit("COMPRAR"))
            .when(pl.col("cobertura_virtual_meses") > 12).then(pl.lit("EXCESSO"))
            .otherwise(pl.lit("OK")).alias("status_diagnostico")
        ])
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/stock/estoque_math.py


START FILE: src/compras_sistema/rule_engine/validators/input_schema.py
--------------------------------------------------------------------------------
import pandera.polars as pa
import polars as pl

class InputCalcSchema(pa.DataFrameModel):
    """
    Contrato de dados obrigatÃ³rio antes de entrar no Motor MatemÃ¡tico.
    Garante que nÃ£o existem nulos onde nÃ£o deve e que os tipos estÃ£o certos.
    """
    
    # IdentificaÃ§Ã£o
    cod_produto: str
    
    # Dados de Estoque (NÃ£o podem ser nulos)
    # coerce=True tenta converter string "10" para int 10 automaticamente
    saldo_estoque: int = pa.Field(coerce=True) 
    saldo_oc: int = pa.Field(coerce=True)
    
    # Dados de Venda (Essenciais para o cÃ¡lculo)
    media_venda_dia: float = pa.Field(ge=0.0, coerce=True)
    std_venda_dia: float = pa.Field(ge=0.0, coerce=True)
    
    # ParÃ¢metros LogÃ­sticos
    lead_time_dias: float = pa.Field(ge=0, coerce=True)
    
    # CRÃTICO: Lote 0 causa divisÃ£o por zero no script
    lote_economico: int = pa.Field(gt=0, coerce=True) 
    
    # ClassificaÃ§Ãµes
    curva_abc: str = pa.Field(isin=["A", "B", "C"])
    curva_xyz: str = pa.Field(isin=["X", "Y", "Z"])
    
    # Datas (Essencial para a lÃ³gica de Item Novo)
    data_cadastro: pl.Date

    class Config:
        # strict=False permite que o DataFrame tenha colunas extras (descricao, marca, etc)
        # sem dar erro. Validamos apenas as colunas essenciais listadas acima.
        strict = False
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/validators/input_schema.py


START FILE: src/compras_sistema/rule_engine/validators/__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/validators/__init__.py


START FILE: src/compras_sistema/rule_engine/classification/xyz_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

class XYZClassifier:
    def __init__(self, db_manager: DuckDBManager, config):
        self.db = db_manager
        self.config = config

    def run(self) -> pl.DataFrame:
        # A Query continua a mesma (Corrigida para olhar apenas os Ãºltimos 365 dias)
        query = """
        WITH vendas_recentes AS (
            -- 1. Pega apenas vendas dos Ãºltimos 365 dias
            SELECT 
                cod_produto,
                CAST(data_movimento AS DATE) as data,
                SUM(quantidade) as qtd_dia
            FROM sqlite_db.vendas
            WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            GROUP BY 1, 2
        ),
        estatisticas AS (
            SELECT 
                cod_produto,
                -- Desvio padrÃ£o das vendas nos dias que houve venda
                STDDEV(qtd_dia) as std_venda_dia,
                
                -- MÃ‰DIA CORRETA: Total vendido no ano / 365 dias
                -- (Isso garante que dias sem venda puxem a mÃ©dia para baixo)
                SUM(qtd_dia) / 365.0 as media_venda_dia,
                
                -- Coeficiente de VariaÃ§Ã£o (CV)
                (STDDEV(qtd_dia) / NULLIF(AVG(qtd_dia), 0)) as cv
            FROM vendas_recentes
            GROUP BY 1
        )
        SELECT 
            CAST(cod_produto AS VARCHAR) as cod_produto,
            COALESCE(media_venda_dia, 0.0) as media_venda_dia,
            COALESCE(std_venda_dia, 0.0) as std_venda_dia,
            CASE 
                WHEN media_venda_dia <= 0 THEN 'Z' -- Se mÃ©dia Ã© 0, Ã© Z (Morto)
                WHEN cv <= 0.5 THEN 'X'  -- Muito estÃ¡vel
                WHEN cv <= 1.0 THEN 'Y'  -- VariÃ¡vel
                ELSE 'Z'                 -- ImprevisÃ­vel
            END as curva_xyz
        FROM estatisticas
        """
        
        # --- CORREÃ‡ÃƒO AQUI ---
        # Usamos o gerenciador de contexto para abrir a conexÃ£o de forma segura
        with self.db.get_connection() as conn:
            # Executa a query e converte direto para Polars
            df = conn.execute(query).pl()
        
        return df
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/xyz_classifier.py


START FILE: src/compras_sistema/rule_engine/classification/abc_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from pathlib import Path
from ...data_engine.duckdb_manager import DuckDBManager
from ...core.config import ConfigManager
import structlog

logger = structlog.get_logger(__name__)

class ABCClassifier:
    """
    Calcula a Curva ABC Financeira.
    Refatorado (Fase 4): LÃ³gica movida do SQL para Python (Polars) para permitir configuraÃ§Ã£o.
    """
    
    def __init__(self, db_manager: DuckDBManager):
        self.db = db_manager
        # [MUDANÃ‡A] Agora apontamos para um SQL 'burro' que sÃ³ traz totais
        self.query_path = Path(__file__).parent.parent.parent / "data_engine" / "queries" / "abc_financeiro_base.sql"
        # Se o arquivo novo nÃ£o existir, usamos o antigo temporariamente (fallback)
        if not self.query_path.exists():
            self.query_path = Path(__file__).parent.parent.parent / "data_engine" / "queries" / "abc_financeiro.sql"

    @staticmethod
    def calcular_abc_polars(df: pl.DataFrame, config_abc: dict) -> pl.DataFrame:
        """
        MÃ©todo EstÃ¡tico Puro: Recebe dados brutos e aplica as regras ABC do config.
        Isso permite testar a lÃ³gica sem precisar de banco de dados.
        """
        if df.height == 0:
            return df.with_columns(pl.lit("C").alias("curva_abc"))

        # 1. Ordenar do maior para o menor (Pareto)
        df = df.sort("total_vendido", descending=True)

        # 2. Calcular Acumulados
        total_geral = df["total_vendido"].sum()
        
        # Evitar divisÃ£o por zero
        if total_geral == 0:
            return df.with_columns(pl.lit("C").alias("curva_abc"))

        df = df.with_columns([
            pl.col("total_vendido").cum_sum().alias("valor_acumulado")
        ])

        df = df.with_columns([
            (pl.col("valor_acumulado") / total_geral).alias("percentual_acumulado")
        ])

        # 3. Ler ConfiguraÃ§Ã£o e Definir Cortes
        # Ex: A=80, B=15. 
        # Corte A = 0.80
        # Corte B = 0.80 + 0.15 = 0.95
        pct_a = config_abc.get("A", 80.0) / 100.0
        pct_b = config_abc.get("B", 15.0) / 100.0
        
        corte_a = pct_a
        corte_b = pct_a + pct_b

        # 4. Aplicar ClassificaÃ§Ã£o
        df = df.with_columns([
            pl.when(pl.col("percentual_acumulado") <= corte_a).then(pl.lit("A"))
            .when(pl.col("percentual_acumulado") <= corte_b).then(pl.lit("B"))
            .otherwise(pl.lit("C"))
            .alias("curva_abc")
        ])

        return df

    def run(self) -> pl.DataFrame:
        """Executa o fluxo completo: Banco -> LÃ³gica -> Resultado"""
        logger.info("iniciando_curva_abc_v2")
        
        # 1. Carregar ConfiguraÃ§Ã£o
        try:
            config = ConfigManager().parametros
            # Tenta pegar dict de float, se der erro converte ou usa padrao
            abc_dict = config.abc if hasattr(config, 'abc') else {'A': 80.0, 'B': 15.0, 'C': 5.0}
        except Exception as e:
            logger.warning(f"Erro ao ler config ABC ({e}). Usando padrÃ£o 80/15/5.")
            abc_dict = {'A': 80.0, 'B': 15.0, 'C': 5.0}

        # 2. Buscar Dados Brutos (Total vendido por produto)
        # Se estivermos usando o SQL antigo (que jÃ¡ calcula ABC), precisamos apenas das colunas de valor
        # para recalcular ou ignorar o cÃ¡lculo do SQL.
        # EstratÃ©gia Segura: Ler o SQL, se vier com ABC, ignoramos e recalculamos.
        
        with open(self.query_path, 'r', encoding='utf-8') as f:
            query = f.read()

        with self.db.get_connection() as conn:
            df_bruto = conn.execute(query).pl()

        # 3. Aplicar LÃ³gica Python
        # Se o SQL for o antigo, ele retorna 'curva_abc'. Vamos sobrescrever.
        # Garantimos que existe 'total_vendido'
        if "total_vendido" not in df_bruto.columns:
            logger.error("Coluna 'total_vendido' nÃ£o encontrada no retorno do SQL.")
            return df_bruto

        df_final = self.calcular_abc_polars(df_bruto, abc_dict)
        
        logger.info("curva_abc_concluida", total_produtos=len(df_final))
        return df_final
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/abc_classifier.py


START FILE: src/compras_sistema/rule_engine/classification/trend_classifier.py
--------------------------------------------------------------------------------
import polars as pl
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

class TrendClassifier:
    def __init__(self, db_manager: DuckDBManager):
        self.db = db_manager

    def run(self) -> pl.DataFrame:
        """
        Calcula tendÃªncias de Vendas, Clientes e DIAS SEM VENDA (Ruptura Temporal).
        """
        query = """
        WITH periodos AS (
            SELECT 
                cod_produto,
                MAX(data_movimento) as ultima_venda,
                -- Vendas Recentes (90 dias) vs Ano (365 dias)
                SUM(CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '90 days') THEN quantidade ELSE 0 END) as qtd_90d,
                SUM(CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days') THEN quantidade ELSE 0 END) as qtd_365d,
                
                -- Contagem de Clientes Ãšnicos
                COUNT(DISTINCT CASE WHEN CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '90 days') THEN cod_clifor END) as clientes_atuais,
                COUNT(DISTINCT CASE WHEN CAST(data_movimento AS DATE) < (CURRENT_DATE - INTERVAL '90 days') 
                                     AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '180 days') THEN cod_clifor END) as clientes_anteriores
            FROM sqlite_db.vendas
            WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            GROUP BY 1
        )
        SELECT 
            CAST(cod_produto AS VARCHAR) as cod_produto,
            
            -- CÃ¡lculo de dias sem venda (usado para boost de ruptura)
            date_diff('day', CAST(ultima_venda AS DATE), CURRENT_DATE) as dias_sem_venda,

            -- VariaÃ§Ã£o de Vendas (%)
            CASE 
                WHEN qtd_365d = 0 THEN 0
                ELSE ((qtd_90d * 4.0) / qtd_365d) - 1.0 
            END as var_vendas,
            
            -- Saldo de Clientes
            (clientes_atuais - clientes_anteriores) as saldo_clientes,
            clientes_atuais as qtd_clientes_ativos
        FROM periodos
        """
        
        with self.db.get_connection() as conn:
            return conn.execute(query).pl()
--------------------------------------------------------------------------------
END FILE: src/compras_sistema/rule_engine/classification/trend_classifier.py


START FILE: src/ui/components/sidebar.py
--------------------------------------------------------------------------------
import customtkinter as ctk
from typing import Callable, Optional

# Cores Adaptativas (Light Mode / Dark Mode)
COLOR_TEXT_PRIMARY = ("#1e293b", "#f1f5f9")  # Slate 800 / Slate 100
COLOR_TEXT_SECONDARY = ("#64748b", "#94a3b8") # Slate 500 / Slate 400
COLOR_BTN_HOVER = ("#e2e8f0", "#334155")

class Sidebar(ctk.CTkFrame):
    """
    Barra Lateral Refinada.
    Foco: Identidade Visual e Acesso a ConfiguraÃ§Ãµes.
    """

    def __init__(self, master, 
                 titulo: str = "AnalyticX",
                 subtitulo: str = "GestÃ£o de Compras",
                 command_gerar: Optional[Callable] = None, # Mantido p/ compatibilidade, mas nÃ£o usado visualmente
                 command_config: Optional[Callable] = None,
                 **kwargs):
        
        super().__init__(master, width=200, corner_radius=0, fg_color=("white", "#1e293b"), **kwargs)
        
        self.command_config = command_config
        self.titulo_text = titulo
        self.subtitulo_text = subtitulo

        self._criar_widgets()

    def _criar_widgets(self):
        self.grid_rowconfigure(4, weight=1) 

        # --- 1. CabeÃ§alho (Identidade) ---
        # Frame azul para destacar o topo
        header = ctk.CTkFrame(self, fg_color="#2563eb", corner_radius=0, height=80)
        header.grid(row=0, column=0, sticky="ew")
        header.grid_propagate(False) # ForÃ§a altura
        
        lbl_titulo = ctk.CTkLabel(
            header, 
            text=self.titulo_text.upper(), 
            font=("Montserrat", 20, "bold"),
            text_color="white"
        )
        lbl_titulo.pack(side="bottom", pady=(0, 5))

        lbl_sub = ctk.CTkLabel(
            self, 
            text=self.subtitulo_text, 
            font=("Arial", 12),
            text_color=COLOR_TEXT_SECONDARY
        )
        lbl_sub.grid(row=1, column=0, pady=(10, 20))

        # --- 2. Ãrea de ConteÃºdo (Injetada pelo Launcher) ---
        # Aqui o Launcher vai colocar os inputs de parÃ¢metros.
        # Deixamos o espaÃ§o livre rows 2 e 3.

        # --- 3. Footer (AÃ§Ãµes Globais) ---
        # BotÃ£o Salvar ConfiguraÃ§Ãµes (Agora mais descritivo)
        self.btn_config = ctk.CTkButton(
            self, 
            text="ğŸ’¾  SALVAR PARÃ‚METROS", 
            command=self.command_config,
            fg_color="transparent",
            border_width=1,
            border_color=("#cbd5e1", "#475569"),
            text_color=COLOR_TEXT_PRIMARY,
            hover_color=COLOR_BTN_HOVER,
            height=35,
            anchor="center"
        )
        self.btn_config.grid(row=5, column=0, padx=20, pady=10, sticky="ew")

        # Controle de Tema
        self.opt_tema = ctk.CTkOptionMenu(
            self, 
            values=["Light", "Dark", "System"],
            command=self.mudar_tema,
            fg_color=("white", "#334155"),
            button_color=("#e2e8f0", "#475569"),
            button_hover_color=("#cbd5e1", "#64748b"),
            text_color=COLOR_TEXT_PRIMARY,
            dropdown_fg_color=("white", "#334155"),
            dropdown_text_color=COLOR_TEXT_PRIMARY
        )
        self.opt_tema.grid(row=6, column=0, padx=20, pady=(0, 20), sticky="ew")
        self.opt_tema.set("System")

    def mudar_tema(self, novo_tema: str):
        ctk.set_appearance_mode(novo_tema)

    def set_estado_gerar(self, estado: str):
        pass # MÃ©todo dummy para compatibilidade
--------------------------------------------------------------------------------
END FILE: src/ui/components/sidebar.py


START FILE: src/ui/components/dashboard.py
--------------------------------------------------------------------------------
import customtkinter as ctk
from typing import Callable, Optional, Dict, List
import time

# --- PALETA DE CORES PROFISSIONAL (Light / Dark) ---
COLOR_BG_MAIN = ("#f3f4f6", "#0f172a")      
COLOR_CARD_BG = ("#ffffff", "#1e293b")      

# Textos
COLOR_TEXT_PRIMARY = ("#1e293b", "#f8fafc") 
COLOR_TEXT_SECONDARY = ("#64748b", "#94a3b8") 

# Acentos
COLOR_PRIMARY = "#2563eb" # Royal Blue
COLOR_SUCCESS = "#16a34a" # Green
COLOR_WARNING = "#f59e0b" # Amber
COLOR_DANGER = "#dc2626"  # Red 600

class Dashboard(ctk.CTkFrame):
    
    def __init__(self, master, **kwargs):
        super().__init__(master, corner_radius=0, **kwargs)
        
        # Estados
        self.var_marca = ctk.StringVar(value="TODAS")
        self.var_busca = ctk.StringVar()
        
        # KPIs Gerais
        self.kpi_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_skus = ctk.StringVar(value="0")
        self.kpi_pecas = ctk.StringVar(value="0")
        self.kpi_estoque = ctk.StringVar(value="R$ 0,00")
        self.kpi_cobertura = ctk.StringVar(value="0.0 m")
        
        # KPIs de Risco (Completo)
        self.kpi_obs_valor = ctk.StringVar(value="R$ 0,00")
        self.kpi_obs_pct_valor = ctk.StringVar(value="0.0%")
        self.kpi_obs_skus = ctk.StringVar(value="0")
        self.kpi_obs_pct_skus = ctk.StringVar(value="0.0%")
        self.kpi_obs_pecas = ctk.StringVar(value="0")

        # Callbacks
        self.on_simular: Optional[Callable] = None
        self.on_excel: Optional[Callable] = None
        self.on_filter_change: Optional[Callable] = None

        self._construir_layout()

    def _construir_layout(self):
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

        # 1. Sistema de Abas
        self.tabs = ctk.CTkTabview(
            self, 
            fg_color="transparent", 
            text_color=COLOR_TEXT_PRIMARY, 
            segmented_button_fg_color=("white", "#1e293b"),
            segmented_button_selected_color=COLOR_PRIMARY,
            segmented_button_unselected_color=("white", "#1e293b"),
            segmented_button_selected_hover_color="#1d4ed8"
        )
        self.tabs.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        self.tab_dash = self.tabs.add("  ğŸ“Š PAINEL DE DECISÃƒO  ")
        self.tab_log = self.tabs.add("  ğŸ“ LOG & AUDITORIA  ")

        self._montar_aba_dashboard()
        self._montar_aba_log()

    def _montar_aba_dashboard(self):
        # --- 1. TOPO (Filtros e Marca) ---
        frame_top = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_CARD_BG, corner_radius=8)
        frame_top.pack(fill="x", pady=(10, 15))
        
        head = ctk.CTkFrame(frame_top, fg_color="transparent")
        head.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(head, text="MARCA SELECIONADA:", font=("Arial", 11, "bold"), text_color=COLOR_TEXT_SECONDARY).pack(side="left")
        ctk.CTkLabel(head, textvariable=self.var_marca, font=("Arial", 22, "bold"), text_color=COLOR_PRIMARY).pack(side="left", padx=15)
        
        self.entry_busca = ctk.CTkEntry(
            head, placeholder_text="ğŸ” Filtrar marca...", width=250, height=35, 
            font=("Arial", 12), textvariable=self.var_busca,
            fg_color=("#f1f5f9", "#0f172a"), border_color=("#cbd5e1", "#334155"), text_color=COLOR_TEXT_PRIMARY
        )
        self.entry_busca.pack(side="right")
        self.entry_busca.bind("<KeyRelease>", lambda e: self.on_filter_change(self.var_busca.get()) if self.on_filter_change else None)

        self.scroll_marcas = ctk.CTkScrollableFrame(frame_top, height=80, orientation="vertical", fg_color="transparent")
        self.scroll_marcas.pack(fill="x", padx=20, pady=(0, 20))
        self.lbl_loading = ctk.CTkLabel(self.scroll_marcas, text="Carregando banco de dados...", text_color="gray")
        self.lbl_loading.pack(pady=30)

        # --- 2. AÃ‡Ã•ES (Workflow) ---
        frame_actions = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        frame_actions.pack(fill="x", pady=5)
        
        self.btn_simular = ctk.CTkButton(
            frame_actions, text="1. PROCESSAR SIMULAÃ‡ÃƒO", height=50, 
            fg_color=COLOR_PRIMARY, font=("Arial", 14, "bold"), corner_radius=8,
            command=lambda: self.on_simular() if self.on_simular else None
        )
        self.btn_simular.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.btn_excel = ctk.CTkButton(
            frame_actions, text="2. EXPORTAR RELATÃ“RIO", height=50, 
            fg_color=COLOR_SUCCESS, font=("Arial", 14, "bold"), state="disabled", corner_radius=8,
            command=lambda: self.on_excel() if self.on_excel else None
        )
        self.btn_excel.pack(side="left", fill="x", expand=True, padx=(10, 0))

        # --- 3. KPIS (Resumo Geral) ---
        ctk.CTkLabel(
            self.tab_dash, text="RESUMO GERAL", font=("Arial", 16, "bold"), 
            text_color=COLOR_TEXT_PRIMARY
        ).pack(pady=(25, 10), anchor="center")
        
        grid_kpi = ctk.CTkFrame(self.tab_dash, fg_color="transparent")
        grid_kpi.pack(fill="x")
        grid_kpi.grid_columnconfigure((0,1,2,3,4), weight=1)

        self._criar_card_kpi(grid_kpi, 0, "SUGESTÃƒO (R$)", self.kpi_valor,   ("#e0f2fe", "#172554"), COLOR_PRIMARY)
        self._criar_card_kpi(grid_kpi, 1, "ITENS (SKU)",   self.kpi_skus,    ("#e0f2fe", "#172554"), COLOR_PRIMARY)
        self._criar_card_kpi(grid_kpi, 2, "PEÃ‡AS (QTD)",   self.kpi_pecas,   ("#e0f2fe", "#172554"), COLOR_PRIMARY)
        self._criar_card_kpi(grid_kpi, 3, "ESTOQUE ATUAL", self.kpi_estoque, ("#f3e8ff", "#581c87"), "#9333ea")
        self._criar_card_kpi(grid_kpi, 4, "COBERTURA",     self.kpi_cobertura,("#f3e8ff", "#581c87"), "#9333ea")

        # --- 4. ABC (AGORA AQUI EM CIMA) ---
        self.frame_abc = ctk.CTkFrame(self.tab_dash, fg_color=COLOR_CARD_BG, corner_radius=8)
        self.frame_abc.pack(fill="both", expand=True, pady=(20, 10))
        
        header_abc = ctk.CTkFrame(self.frame_abc, fg_color="transparent")
        header_abc.pack(fill="x", padx=20, pady=(15, 10))
        
        ctk.CTkLabel(
            header_abc, text="ANÃLISE ESTRATÃ‰GICA ABC (ESTOQUE vs. COMPRA)", 
            font=("Arial", 16, "bold"), text_color=COLOR_TEXT_PRIMARY
        ).pack(anchor="center")

        self.container_abc = ctk.CTkFrame(self.frame_abc, fg_color="transparent")
        self.container_abc.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        self.lbl_abc_placeholder = ctk.CTkLabel(self.container_abc, text="Execute uma simulaÃ§Ã£o para ver a anÃ¡lise ABC.", text_color="gray")
        self.lbl_abc_placeholder.pack(expand=True)

        # --- 5. ALERTA DE RISCO (AGORA AQUI EM BAIXO) ---
        self.frame_risk = ctk.CTkFrame(self.tab_dash, fg_color=("#fee2e2", "#450a0a"), corner_radius=8, border_width=1, border_color=COLOR_DANGER)
        self.frame_risk.pack(fill="x", pady=(10, 25))
        
        # Container FlexÃ­vel (Horizontal)
        risk_container = ctk.CTkFrame(self.frame_risk, fg_color="transparent")
        risk_container.pack(fill="x", padx=20, pady=8)

        # Coluna 1: TÃ­tulo e DescriÃ§Ã£o (Esquerda Fixa)
        f_tit = ctk.CTkFrame(risk_container, fg_color="transparent")
        f_tit.pack(side="left", fill="y", padx=(0, 20))
        
        ctk.CTkLabel(f_tit, text="âš ï¸ ESTOQUE OBSOLETO", font=("Arial", 16, "bold"), text_color=COLOR_DANGER).pack(anchor="w")
        ctk.CTkLabel(f_tit, text="Itens >180d, Saldo >0, Sem Venda >1 ano", font=("Arial", 11), text_color=("#7f1d1d", "#fca5a5")).pack(anchor="w")

        # Separador Vertical
        ctk.CTkFrame(risk_container, width=2, fg_color=("#fecaca", "#7f1d1d")).pack(side="left", fill="y", padx=15)

        # Coluna 2: Valor Financeiro (ExpandÃ­vel)
        f_fin = ctk.CTkFrame(risk_container, fg_color="transparent")
        f_fin.pack(side="left", expand=True, fill="x")
        
        ctk.CTkLabel(f_fin, text="VALOR TRAVADO", font=("Arial", 11, "bold"), text_color=COLOR_TEXT_SECONDARY).pack()
        # Fonte Gigante
        ctk.CTkLabel(f_fin, textvariable=self.kpi_obs_valor, font=("Arial", 22, "bold"), text_color=COLOR_DANGER).pack(pady=(0,2))
        ctk.CTkLabel(f_fin, textvariable=self.kpi_obs_pct_valor, font=("Arial", 13, "bold"), text_color=COLOR_DANGER).pack()

        # Separador Vertical
        ctk.CTkFrame(risk_container, width=2, fg_color=("#fecaca", "#7f1d1d")).pack(side="left", fill="y", padx=15)

        # Coluna 3: Dados LogÃ­sticos (ExpandÃ­vel)
        f_log = ctk.CTkFrame(risk_container, fg_color="transparent")
        f_log.pack(side="left", expand=True, fill="x")
        
        # Sub-linha para SKU e PeÃ§as
        f_sub = ctk.CTkFrame(f_log, fg_color="transparent")
        f_sub.pack(pady=2)
        
        # SKU
        f_sku = ctk.CTkFrame(f_sub, fg_color="transparent")
        f_sku.pack(side="left", padx=20)
        ctk.CTkLabel(f_sku, text="SKUS MORTOS", font=("Arial", 11, "bold"), text_color=COLOR_TEXT_SECONDARY).pack()
        ctk.CTkLabel(f_sku, textvariable=self.kpi_obs_skus, font=("Arial", 16, "bold"), text_color=COLOR_TEXT_PRIMARY).pack()
        ctk.CTkLabel(f_sku, textvariable=self.kpi_obs_pct_skus, font=("Arial", 11), text_color=COLOR_TEXT_SECONDARY).pack()
        
        # PeÃ§as
        f_pec = ctk.CTkFrame(f_sub, fg_color="transparent")
        f_pec.pack(side="left", padx=20)
        ctk.CTkLabel(f_pec, text="TOTAL PEÃ‡AS", font=("Arial", 11, "bold"), text_color=COLOR_TEXT_SECONDARY).pack()
        ctk.CTkLabel(f_pec, textvariable=self.kpi_obs_pecas, font=("Arial", 16, "bold"), text_color=COLOR_TEXT_PRIMARY).pack()

    def _montar_aba_log(self):
        self.txt_log = ctk.CTkTextbox(self.tab_log, font=("Consolas", 13), fg_color=("#ffffff", "#0f172a"), text_color=("#16a34a", "#22c55e"), border_width=1, border_color=("#e2e8f0", "#334155"))
        self.txt_log.pack(fill="both", expand=True, padx=0, pady=0)
        self.txt_log.configure(state="disabled")

    def _criar_card_kpi(self, parent, col, titulo, variavel, bg_tuple, text_color):
        card = ctk.CTkFrame(parent, fg_color=bg_tuple, corner_radius=8, border_width=1, border_color=bg_tuple)
        card.grid(row=0, column=col, padx=5, sticky="ew")
        ctk.CTkLabel(card, text=titulo, font=("Arial", 10, "bold"), text_color=text_color).pack(pady=(15, 0))
        ctk.CTkLabel(card, textvariable=variavel, font=("Arial", 18, "bold"), text_color=COLOR_TEXT_PRIMARY).pack(pady=(2, 15))

    # --- API PÃšBLICA ---

    def configurar_acoes(self, on_simular, on_excel, on_filter_change):
        self.on_simular = on_simular
        self.on_excel = on_excel
        self.on_filter_change = on_filter_change

    def renderizar_lista_marcas(self, lista_marcas: List[str]):
        for w in self.scroll_marcas.winfo_children(): w.destroy()
        self.scroll_marcas.grid_columnconfigure((0,1,2,3,4), weight=1)
        sel = self.var_marca.get()
        for i, marca in enumerate(lista_marcas):
            is_sel = (marca == sel)
            btn = ctk.CTkButton(
                self.scroll_marcas, text=marca, height=28, 
                fg_color=COLOR_PRIMARY if is_sel else "transparent",
                text_color="white" if is_sel else COLOR_TEXT_PRIMARY,
                hover_color="#1d4ed8" if is_sel else ("#e2e8f0", "#334155"),
                border_width=1, border_color=("#cbd5e1", "#475569"),
                command=lambda m=marca: self._selecionar_marca_interna(m)
            )
            btn.grid(row=i//5, column=i%5, padx=3, pady=3, sticky="ew")

    def _selecionar_marca_interna(self, marca):
        self.var_marca.set(marca)
        if self.on_filter_change: self.on_filter_change(self.var_busca.get())

    def atualizar_abc_stats(self, abc_data: Dict):
        for w in self.container_abc.winfo_children(): w.destroy()
        
        if not abc_data:
            ctk.CTkLabel(self.container_abc, text="Sem dados ABC disponÃ­veis.", text_color="gray").pack(pady=20)
            return

        total_est = sum(d['estoque'] for d in abc_data.values())
        total_cmp = sum(d['compra'] for d in abc_data.values())

        grid = self.container_abc
        grid.grid_columnconfigure(1, weight=1) 
        grid.grid_columnconfigure(3, weight=1)
        
        ctk.CTkLabel(grid, text="CLASSE", font=("Arial", 11, "bold"), width=60, anchor="w", text_color=COLOR_TEXT_SECONDARY).grid(row=0, column=0, padx=10)
        ctk.CTkLabel(grid, text="ESTOQUE ATUAL", font=("Arial", 11, "bold"), text_color="#9333ea").grid(row=0, column=1, sticky="w")
        ctk.CTkLabel(grid, text="SUGESTÃƒO COMPRA", font=("Arial", 11, "bold"), text_color=COLOR_PRIMARY).grid(row=0, column=3, sticky="w")

        row_idx = 1
        max_val = max(1, max(v['estoque'] for v in abc_data.values()), max(v['compra'] for v in abc_data.values()))

        def fmt(v, total): 
            pct = (v / total * 100) if total > 0 else 0
            val_str = f"R$ {float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
            return f"{val_str} ({pct:.1f}%)"

        for classe in ['A', 'B', 'C']:
            dados = abc_data.get(classe, {'estoque': 0, 'compra': 0})
            
            ctk.CTkLabel(grid, text=f"CURVA {classe}", font=("Arial", 16, "bold"), text_color=COLOR_TEXT_PRIMARY, width=60, anchor="w").grid(row=row_idx, column=0, pady=10, padx=10)

            # Barra Estoque (Mais fina)
            frm_est = ctk.CTkFrame(grid, height=25, fg_color="transparent")
            frm_est.grid(row=row_idx, column=1, sticky="ew", padx=10)
            width_est = (dados['estoque'] / max_val) if max_val > 0 else 0
            if width_est > 0:
                ctk.CTkProgressBar(frm_est, progress_color="#9333ea", height=10).pack(side="left", fill="x", expand=True)
                frm_est.winfo_children()[0].set(width_est)
            # Fonte Maior
            ctk.CTkLabel(frm_est, text=fmt(dados['estoque'], total_est), font=("Arial", 14, "bold"), text_color=COLOR_TEXT_PRIMARY).pack(side="left", padx=8)

            # Barra Compra (Mais fina)
            frm_cmp = ctk.CTkFrame(grid, height=25, fg_color="transparent")
            frm_cmp.grid(row=row_idx, column=3, sticky="ew", padx=10)
            width_cmp = (dados['compra'] / max_val) if max_val > 0 else 0
            if width_cmp > 0:
                ctk.CTkProgressBar(frm_cmp, progress_color=COLOR_PRIMARY, height=10).pack(side="left", fill="x", expand=True)
                frm_cmp.winfo_children()[0].set(width_cmp)
            # Fonte Maior
            ctk.CTkLabel(frm_cmp, text=fmt(dados['compra'], total_cmp), font=("Arial", 14, "bold"), text_color=COLOR_TEXT_PRIMARY).pack(side="left", padx=8)

            row_idx += 2 
            if classe != 'C': ctk.CTkFrame(grid, height=1, fg_color=("#e2e8f0", "#334155")).grid(row=row_idx, column=0, columnspan=5, sticky="ew", pady=5); row_idx += 1

    def get_marca_selecionada(self) -> str: return self.var_marca.get()
    
    def set_estado_processamento(self, processando: bool):
        if processando:
            self.btn_simular.configure(state="disabled", text="â³ CALCULANDO...", fg_color="gray")
            self.btn_excel.configure(state="disabled")
        else:
            self.btn_simular.configure(state="normal", text="1. REPROCESSAR SIMULAÃ‡ÃƒO", fg_color=COLOR_PRIMARY)
            
    def habilitar_excel(self): self.btn_excel.configure(state="normal", fg_color=COLOR_SUCCESS)

    def log(self, msg: str):
        self.txt_log.configure(state="normal")
        timestamp = time.strftime("[%H:%M:%S] ")
        self.txt_log.insert("end", f"{timestamp}{msg}\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")
        
    def limpar_log(self):
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

    def focar_aba_log(self): self.tabs.set("  ğŸ“ LOG & AUDITORIA  ")
    def focar_aba_dashboard(self): self.tabs.set("  ğŸ“Š PAINEL DE DECISÃƒO  ")

    def atualizar_kpis_dict(self, data: Dict):
        """Atualiza todos os nÃºmeros da tela, incluindo Risco Completo."""
        def fmt(v, prefix="R$ "): 
            if v is None: v = 0
            return f"{prefix}{float(v):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
            
        def fmt_int(v): 
            if v is None: v = 0
            return f"{int(v):,}".replace(",", ".")

        # KPIs Principais
        self.kpi_valor.set(fmt(data.get('total_valor', 0)))
        self.kpi_skus.set(fmt_int(data.get('total_skus', 0)))
        self.kpi_pecas.set(fmt_int(data.get('total_pecas', 0)))
        self.kpi_estoque.set(fmt(data.get('estoque_atual', 0)))
        self.kpi_cobertura.set(f"{float(data.get('cobertura_meses', 0) or 0):.1f} meses")
        
        # GrÃ¡fico ABC
        self.atualizar_abc_stats(data.get('abc_breakdown', {}))
        
        # KPIS DE RISCO (5 Indicadores)
        self.kpi_obs_valor.set(fmt(data.get('obs_valor', 0)))
        self.kpi_obs_pct_valor.set(f"{float(data.get('obs_pct_valor', 0) or 0)*100:.1f}% do valor total")
        
        self.kpi_obs_skus.set(fmt_int(data.get('obs_skus', 0)))
        self.kpi_obs_pct_skus.set(f"{float(data.get('obs_pct_skus', 0) or 0)*100:.1f}% do mix")
        
        self.kpi_obs_pecas.set(fmt_int(data.get('obs_pecas', 0)))

            # MELHOR ATÃ‰ AGORA 18 12 2025 23H15M
--------------------------------------------------------------------------------
END FILE: src/ui/components/dashboard.py


START FILE: scripts/auditor_real.py
--------------------------------------------------------------------------------
import sys
import os
import duckdb
import polars as pl
from datetime import datetime, timedelta
from decimal import Decimal

# --- CONFIGURAÃ‡ÃƒO ---
CAMINHO_BASE = "/home/roberio/Documentos/New4.2 THE BEST 18 12 2025/compras-estoque-sistema"
CAMINHO_DB = os.path.join(CAMINHO_BASE, "data/vendas.db")
CAMINHO_SRC = os.path.join(CAMINHO_BASE, "src")

sys.path.append(CAMINHO_SRC)
try:
    from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
except ImportError:
    print("âŒ Erro: NÃ£o foi possÃ­vel importar 'EstoqueMath'.")
    sys.exit(1)

# --- SEUS PARÃ‚METROS REAIS ---
CONFIG = {
    'compras': {'meses_cobertura': 3.0},  # <--- AJUSTADO PARA 3 MESES
    'produto': {'dias_lancamento': 180},
    'estoque': {'fator_z': {'X': 1.65, 'Y': 1.28, 'Z': 0.84}},
    'giro': {'limite_meses_cobertura': 6.0, 'minimo_venda_dia': 0.05},
    'lote': {'limite_virada': 0.3}
}

def to_float(val):
    if val is None: return 0.0
    if isinstance(val, Decimal): return float(val)
    return float(val)

def buscar_dados_completos(sku, lead_time_manual):
    if not os.path.exists(CAMINHO_DB):
        print(f"âŒ Banco nÃ£o encontrado: {CAMINHO_DB}")
        return None

    con = duckdb.connect(CAMINHO_DB)
    
    try:
        print(f"ğŸ” Consultando SKU '{sku}' (Ãšltimos 12 meses)...")
        
        # Data de corte: Hoje menos 365 dias
        data_corte = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')
        
        query = f"""
        WITH historico AS (
            SELECT 
                cod_produto,
                MAX(data_movimento) as ultima_venda,
                -- Soma apenas vendas apÃ³s a data de corte (Ãºltimos 12 meses)
                SUM(CASE WHEN data_movimento >= '{data_corte}' THEN quantidade ELSE 0 END) as total_vendido_12m,
                COUNT(*) as num_notas
            FROM vendas 
            WHERE cod_produto = '{sku}'
            GROUP BY cod_produto
        ),
        posicao_atual AS (
            SELECT
                cod_produto,
                saldo_estoque,
                saldo_oc,
                custo_unitario
            FROM saldo_custo_entrada
            WHERE cod_produto = '{sku}'
        )
        SELECT 
            h.ultima_venda,
            h.total_vendido_12m,
            p.saldo_estoque,
            p.saldo_oc,
            p.custo_unitario
        FROM historico h
        LEFT JOIN posicao_atual p ON h.cod_produto = p.cod_produto
        """
        
        df_raw = con.execute(query).pl()
        
        if df_raw.height == 0:
            print("âš ï¸ Item nÃ£o encontrado.")
            return None

        row = df_raw.row(0, named=True)
        hoje = datetime.now()

        # 1. Datas
        str_data_venda = row['ultima_venda']
        try:
            if "/" in str_data_venda: dt_venda = datetime.strptime(str_data_venda, "%d/%m/%Y")
            else: dt_venda = datetime.strptime(str_data_venda, "%Y-%m-%d")
        except: dt_venda = hoje
        
        dias_sem_venda = (hoje - dt_venda).days
        if dias_sem_venda < 0: dias_sem_venda = 0

        # 2. MÃ©dia (Baseada em 365 dias - Regra de 12 meses)
        total_12m = to_float(row['total_vendido_12m'])
        # Se o total for 48 (como vocÃª disse), a mÃ©dia serÃ¡ 48/365 = 0.13
        media_dia = total_12m / 365.0 

        # 3. Estoque
        saldo = to_float(row['saldo_estoque'])
        oc = to_float(row['saldo_oc'])
        custo = to_float(row['custo_unitario'])
        
        print(f"   âœ… Dados Calculados (Base 12 meses):")
        print(f"      â€¢ Total Vendido (12m): {total_12m} un")
        print(f"      â€¢ MÃ©dia Dia: {media_dia:.4f} un/dia")
        print(f"      â€¢ Estoque: {saldo} | OC: {oc}")
        print(f"      â€¢ Lead Time Configurado: {lead_time_manual} dias")

        return pl.DataFrame({
            "cod_produto": [sku],
            "saldo_estoque": [saldo],
            "saldo_oc": [oc],
            "media_venda_dia": [media_dia],
            "dias_sem_venda": [int(dias_sem_venda)],
            "lead_time_dias": [lead_time_manual], # Usa o parametro manual
            "std_venda_dia": [media_dia * 0.8], # Simulando variabilidade maior (tÃ­pico de baixa venda)
            "curva_abc": ["C" if media_dia < 0.5 else "A"], # Ajuste dinÃ¢mico para teste
            "curva_xyz": ["Z"],
            "tendencia_vendas": ["ESTÃVEL"],
            "data_cadastro": [datetime.now()],
            "custo_unitario": [custo],
            "lote_economico": [1],
            "ativo": ["SIM"]
        })

    except Exception as e:
        print(f"âŒ Erro SQL: {e}")
        return None
    finally:
        con.close()

def auditar_regras(df):
    try:
        # Pipeline Completo
        df = EstoqueMath.calcular_seguranca(df, CONFIG)
        df = EstoqueMath.calcular_necessidades(df, CONFIG)
        df = EstoqueMath.aplicar_lote_economico(df, CONFIG)
        df = EstoqueMath.calcular_score(df)
        df = EstoqueMath.gerar_diagnostico(df, CONFIG)
        
        row = df.to_dicts()[0]
        
        print("\n" + "="*50)
        print(f"ğŸ RESULTADO DA AUDITORIA: {row['cod_produto']}")
        print("="*50)
        print(f"ğŸ“Š ParÃ¢metros Usados:")
        print(f"   â€¢ Cobertura Alvo: {CONFIG['compras']['meses_cobertura']} meses (90 dias)")
        print(f"   â€¢ MÃ©dia Calculada: {row['media_venda_dia']:.4f}")
        
        # MemÃ³ria de CÃ¡lculo
        print(f"\nğŸ§® MEMÃ“RIA DE CÃLCULO:")
        print(f"   (+) Consumo Cobertura (90d * media): {row['media_venda_dia'] * 30 * 3:.2f}")
        print(f"   (+) Consumo Lead Time ({row['lead_time_dias']}d * media): {row['media_venda_dia'] * row['lead_time_dias']:.2f}")
        print(f"   (+) Estoque SeguranÃ§a: {row['estoque_seguranca']:.2f}")
        print(f"   (=) ESTOQUE META: {row['estoque_meta']}")
        print(f"   (-) Saldo Atual: {row['saldo_estoque']}")
        print(f"   (-) OC (Pedidos): {row['saldo_oc']}")
        print(f"   (=) NECESSIDADE: {row['sugestao_bruta']}")

        print(f"\nğŸ“¦ SUGESTÃƒO FINAL: {row['sugestao_final']} unidades")
        print("-" * 50 + "\n")

    except Exception as e:
        print(f"âŒ Erro: {e}")
        import traceback
        traceback.print_exc()

def main():
    print("\nğŸ¤– AUDITOR CALIBRADO (Base 12 Meses)")
    sku = input("Digite o SKU (ex: 30129): ").strip()
    if sku:
        # Pergunta o Lead Time para garantir que bate com seu parametro
        try:
            lead = int(input(f"Confirme o Lead Time (padrÃ£o 17): ") or 17)
        except:
            lead = 17
            
        df = buscar_dados_completos(sku, lead)
        if df is not None:
            auditar_regras(df)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/auditor_real.py


START FILE: scripts/gerar_relatorio_final.py
--------------------------------------------------------------------------------
import sys
import argparse
import json
from pathlib import Path
from datetime import datetime
import polars as pl
import traceback
from pandera.errors import SchemaError

# ==============================================================================
# 0. SETUP DE AMBIENTE E CAMINHOS
# ==============================================================================
# Adiciona o diretÃ³rio 'src' ao path para importar os mÃ³dulos do sistema
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

# Imports dos MÃ³dulos do Sistema (Core e Engines)
from compras_sistema.core.config import ConfigManager
from compras_sistema.core.system_guard import SystemGuard
from compras_sistema.core.reporter import ExecutionReporter
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.history_recorder import HistoryRecorder

# Imports das Regras de NegÃ³cio (Classificadores e MatemÃ¡tica)
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.classification.trend_classifier import TrendClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.export.excel_exporter import ExcelExporter
from compras_sistema.utils.sanitizer import sanear_dados_dataframe

# Tenta importar o Validador (Pandera), mas nÃ£o quebra se faltar
try:
    from compras_sistema.rule_engine.validators.input_schema import InputCalcSchema
except ImportError:
    InputCalcSchema = None

def main():
    # --- ConfiguraÃ§Ã£o de Argumentos via Linha de Comando ---
    parser = argparse.ArgumentParser()
    parser.add_argument("--marca", type=str, default="TODAS", help="Filtrar processamento por marca")
    parser.add_argument("--simulacao", action="store_true", help="Modo SimulaÃ§Ã£o: NÃ£o gera Excel, apenas calcula")
    args = parser.parse_args()
    
    # --- InicializaÃ§Ã£o de Logs e GuardiÃµes ---
    guard = SystemGuard(PROJECT_ROOT / "logs")
    print(f"--- LOG START ---") # Marcador visual para o Launcher
    guard.log(f"ğŸš€ Processamento Iniciado - Filtro Marca: {args.marca}")
    
    # Reporter: ResponsÃ¡vel por enviar dados JSON para o Dashboard
    reporter = ExecutionReporter(PROJECT_ROOT / "data")
    reporter.limpar_stats_anteriores()
    
    # Carregamento de ConfiguraÃ§Ãµes (YAML)
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    # InicializaÃ§Ã£o do Banco de Dados (Com Health Check)
    db = DuckDBManager()
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")
    
    # InicializaÃ§Ã£o do Gravador de HistÃ³rico (apenas se nÃ£o for simulaÃ§Ã£o)
    recorder = HistoryRecorder(db) if not args.simulacao else None
    if recorder:
        recorder.inicializar_tabela()
    
    try:
        # ==============================================================================
        # 1. MOTOR DE CLASSIFICAÃ‡ÃƒO (ABC, XYZ, TENDÃŠNCIAS)
        # ==============================================================================
        guard.log("ğŸ“Š Calculando ClassificaÃ§Ãµes EstatÃ­sticas (ABC, XYZ, Trends)...")
        
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        trend_engine = TrendClassifier(db)
        
        df_abc = abc_engine.run()
        df_xyz = xyz_engine.run()
        df_trend = trend_engine.run()
        
        # ==============================================================================
        # 2. LEITURA DE DADOS (SNAPSHOT DO ERP)
        # ==============================================================================
        guard.log("ğŸ’¾ Lendo Estoques e Cadastro Completo do Banco de Dados...")
        
        with db.get_connection() as conn:
            # 2.1 Leitura de Saldos e Custos
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto,
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
            """).pl()
            
            # 2.2 Leitura DinÃ¢mica do Cadastro de Produtos
            # Verifica quais colunas existem para evitar erros se o banco mudar
            try:
                cols_db = [c[1] for c in conn.execute("PRAGMA table_info(sqlite_db.produtos_gerais)").fetchall()]
                
                # Mapeamento seguro de colunas
                col_desc = "descricao_produto" if "descricao_produto" in cols_db else ("descricao" if "descricao" in cols_db else "''")
                col_data = "CAST(data_cadastro AS DATE)" if "data_cadastro" in cols_db else "CAST('2000-01-01' AS DATE)"
                col_ref = "ref_fornecedor" if "ref_fornecedor" in cols_db else "''"
                
                df_cadastro = conn.execute(f"""
                    SELECT 
                        CAST(cod_produto AS VARCHAR) as cod_produto,
                        CAST(qtd_economica AS INTEGER) as lote_economico,
                        marca,
                        {col_desc} as descricao,
                        {col_ref} as ref_fornecedor,
                        ativo,
                        {col_data} as data_cadastro
                    FROM sqlite_db.produtos_gerais
                """).pl()
            except Exception as e:
                guard.log(f"âš ï¸ Erro parcial ao ler cadastro: {e}. Usando estrutura de fallback.")
                df_cadastro = pl.DataFrame(schema={
                    "cod_produto": pl.Utf8, "lote_economico": pl.Int64, "marca": pl.Utf8,
                    "descricao": pl.Utf8, "ref_fornecedor": pl.Utf8, "ativo": pl.Utf8,
                    "data_cadastro": pl.Date
                })
        
        # 2.3 Carregamento de Sazonalidade (Analytics)
        indices_dict = {}
        try:
            analytics_path = PROJECT_ROOT / "data" / "analytics.duckdb"
            if analytics_path.exists():
                with db.get_connection() as conn:
                    conn.execute(f"ATTACH '{analytics_path}' AS analytics")
                    rows = conn.execute("SELECT mes, indice_sazonal FROM analytics.indices_sazonais").fetchall()
                    conn.execute("DETACH analytics")
                    for r in rows:
                        indices_dict[r[0]] = r[1]
        except Exception:
            pass # Sazonalidade Ã© opcional, segue sem erro crÃ­tico se falhar

        # ==============================================================================
        # 3. UNIFICAÃ‡ÃƒO DOS DADOS (O "BIG JOIN")
        # ==============================================================================
        guard.log("ğŸ”— Cruzando tabelas (Join)...")
        
        # Cria um universo com todos os cÃ³digos de produto encontrados em qualquer tabela
        df_universe = pl.concat([
            df_xyz.select("cod_produto"),
            df_saldo.select("cod_produto"),
            df_cadastro.select("cod_produto")
        ]).unique(subset="cod_produto")
        
        # Realiza os Left Joins para montar a tabela mestre
        df_final = (df_universe
            .join(df_xyz, on="cod_produto", how="left")
            .join(df_abc, on="cod_produto", how="left")
            .join(df_trend, on="cod_produto", how="left")
            .join(df_saldo, on="cod_produto", how="left")
            .join(df_cadastro, on="cod_produto", how="left"))
        
        # Garante que temos descriÃ§Ã£o
        if "descricao" not in df_final.columns:
            if "descricao_right" in df_final.columns:
                df_final = df_final.rename({"descricao_right": "descricao"})
            else:
                df_final = df_final.with_columns(pl.lit("SEM DESCRIÃ‡ÃƒO").alias("descricao"))
        
        # ==============================================================================
        # 4. TRATAMENTO E HIGIENIZAÃ‡ÃƒO DE DADOS
        # ==============================================================================
        
        # Recupera Lead Time do Config
        lead_time_padrao = config_mgr.parametros.lead_time.padrao_dias
        if isinstance(lead_time_padrao, dict):
            lead_time_padrao = lead_time_padrao.get('padrao_dias', 10)
            
        # 4.1 Preenchimento de Nulos (FillNA) - Bloco Expandido para Clareza
        df_final = df_final.with_columns([
            # MÃ©tricas de Venda
            pl.col("media_venda_dia").fill_null(0.0),
            pl.col("std_venda_dia").fill_null(0.0),
            pl.col("dias_sem_venda").fill_null(0).alias("dias_sem_venda"),
            
            # Dados Financeiros/LogÃ­sticos
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            pl.col("custo_unitario").fill_null(0.0),
            
            # ClassificaÃ§Ãµes
            pl.col("curva_abc").fill_null("C"),
            pl.col("curva_xyz").fill_null("Z"),
            
            # Cadastro
            pl.col("marca").fill_null("N/D"),
            pl.col("descricao").fill_null("DESCRIÃ‡ÃƒO NÃƒO ENCONTRADA"),
            pl.col("ref_fornecedor").fill_null(""),
            pl.col("lote_economico").fill_null(1).map_elements(lambda x: max(1, x), return_dtype=pl.Int64),
            pl.col("ativo").fill_null("SIM"),
            pl.col("data_cadastro").fill_null(pl.lit(datetime(2000,1,1)).cast(pl.Date)),
            
            # ParÃ¢metro Global
            pl.lit(lead_time_padrao).alias("lead_time_dias"),
        ])

        # 4.2 DetecÃ§Ã£o de Anomalias (Cria alertas visuais no Excel)
        df_final = df_final.with_columns([
            pl.when(pl.col("saldo_estoque") < 0)
            .then(pl.lit("ESTOQUE NEGATIVO"))
            .when(pl.col("saldo_oc") < 0)
            .then(pl.lit("OC NEGATIVA (ERRO ERP)"))
            .otherwise(None)
            .alias("alerta_dados")
        ])

        # 4.3 ValidaÃ§Ã£o Estrutural (Pandera) - Opcional mas Recomendado
        if InputCalcSchema:
            guard.log("ğŸ›¡ï¸ Validando integridade estrutural dos dados...")
            try:
                df_final = InputCalcSchema.validate(df_final)
            except SchemaError as e:
                guard.log(f"âŒ ERRO DE VALIDAÃ‡ÃƒO: {e.schema.name if e.schema else 'Global'}")
                sys.exit(1)

        # 4.4 SanitizaÃ§Ã£o Final de NegÃ³cios (Remove caracteres estranhos, espaÃ§os, etc)
        guard.log("ğŸ§¹ Aplicando SanitizaÃ§Ã£o de NegÃ³cios...")
        df_final = sanear_dados_dataframe(df_final)
        
        # ==============================================================================
        # 5. MOTOR MATEMÃTICO (CÃLCULO DE SUGESTÃƒO)
        # ==============================================================================
        guard.log("ğŸ§® Executando Motor MatemÃ¡tico de ReposiÃ§Ã£o...")
        
        # 5.1 Prepara Sazonalidade
        df_final = df_final.with_columns([pl.col("media_venda_dia").alias("media_venda_base")])
        df_final = EstoqueMath.aplicar_sazonalidade_projetada(df_final, indices_dict)
        df_final = df_final.with_columns([
            pl.col("fator_sazonal_projetado").alias("fator_sazonal"),
            (pl.col("media_venda_base") * pl.col("fator_sazonal_projetado")).alias("media_venda_dia")
        ])
        
        # 5.2 Cria DataFrame MatemÃ¡tico (TemporÃ¡rio)
        # Removemos OC negativa apenas para o cÃ¡lculo, para nÃ£o distorcer a conta.
        # No Excel final, o valor original negativo aparecerÃ¡ com alerta.
        df_math = df_final.with_columns([pl.col("saldo_oc").clip(lower_bound=0)])
        
        # 5.3 Pipeline de CÃ¡lculo
        df_math = EstoqueMath.calcular_tendencias(df_math)
        df_math = EstoqueMath.calcular_seguranca(df_math, config_mgr.parametros)
        df_math = EstoqueMath.calcular_necessidades(df_math, config_mgr.parametros)
        df_math = EstoqueMath.aplicar_lote_economico(df_math, config_mgr.parametros)
        df_math = EstoqueMath.calcular_score(df_math)
        df_math = EstoqueMath.gerar_diagnostico(df_math, config_mgr.parametros)
        
        # 5.4 Mesclagem dos Resultados
        cols_calculadas = [
            "tendencia_vendas", "tendencia_clientes", "perfil_cliente", 
            "estoque_seguranca", "fator_z",                             
            "ponto_suprimento", "estoque_meta", "sugestao_bruta",       
            "media_calculo", "dias_vida",                               
            "lotes_cheios", "sugestao_final", "subtotal",               
            "score",                                                    
            "validacao_giro", "motivo_bloqueio",                        
            "calculado_mas_bloqueado", "status_diagnostico", 
            "cobertura_virtual_meses", "sugestao_calculada"
        ]
        
        df_final = df_final.with_columns(df_math.select(cols_calculadas))
        
        # 5.5 KPI Final de PosiÃ§Ã£o
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") + pl.col("saldo_oc") + pl.col("sugestao_final")).alias("meta_pos_compra")
        ])
        
        # ==============================================================================
        # 6. PÃ“S-PROCESSAMENTO, ESTATÃSTICAS E EXPORTAÃ‡ÃƒO
        # ==============================================================================
        
        # 6.1 AplicaÃ§Ã£o de Filtro de Marca
        if args.marca and args.marca != "TODAS":
            guard.log(f"ğŸ” Filtrando relatÃ³rio para marca: {args.marca}")
            df_final = df_final.filter(pl.col("marca") == args.marca)
        
        # -------------------------------------------------------------------------
        # 6.2 CÃLCULO DE TOTAIS GERAIS (NecessÃ¡rio para Porcentagens)
        # -------------------------------------------------------------------------
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") * pl.col("custo_unitario")).fill_null(0).alias("vlr_estoque_total"),
            pl.col("subtotal").fill_null(0).alias("vlr_compra_total")
        ])

        val_estoque_atual = df_final["vlr_estoque_total"].sum()
        total_skus_geral = len(df_final)

        # -------------------------------------------------------------------------
        # 6.3 LÃ“GICA DE RISCO: ESTOQUE OBSOLETO (COM 5 INDICADORES)
        # -------------------------------------------------------------------------
        dias_novo_param = config_mgr.parametros.produto.get('dias_lancamento', 180)
        
        # Filtro: Antigo AND Tem Saldo AND (NÃ£o Vende hÃ¡ 1 ano OR Bug de venda 0 dias mas antigo)
        df_obsoleto = df_final.filter(
            (pl.col("dias_vida") > dias_novo_param) &
            (pl.col("saldo_estoque") > 0) &
            (
                (pl.col("dias_sem_venda") > 364) | 
                ((pl.col("dias_sem_venda") == 0) & (pl.col("dias_vida") > 364))
            )
        )
        
        # MÃ©tricas Absolutas de Obsoleto
        obs_valor = df_obsoleto["vlr_estoque_total"].sum()
        obs_skus = len(df_obsoleto)
        obs_pecas = df_obsoleto["saldo_estoque"].sum()

        # MÃ©tricas Relativas (%)
        pct_obs_valor = (obs_valor / val_estoque_atual) if val_estoque_atual > 0 else 0.0
        pct_obs_skus = (obs_skus / total_skus_geral) if total_skus_geral > 0 else 0.0

        guard.log(f"ğŸ” Risco: {obs_skus} SKUs obsoletos. Valor: R$ {obs_valor:.2f} ({pct_obs_valor*100:.1f}% do estoque)")

        # -------------------------------------------------------------------------
        # 6.4 ESTATÃSTICAS AVANÃ‡ADAS (ABC + Dashboard)
        # -------------------------------------------------------------------------
        
        # AgregaÃ§Ã£o ABC
        df_abc_summary = df_final.group_by("curva_abc").agg([
            pl.col("vlr_estoque_total").sum(),
            pl.col("vlr_compra_total").sum()
        ]).sort("curva_abc")
        
        abc_data = {}
        for row in df_abc_summary.iter_rows(named=True):
            curva = row['curva_abc'] if row['curva_abc'] else 'N/D'
            abc_data[curva] = {"estoque": row['vlr_estoque_total'], "compra": row['vlr_compra_total']}

        # Stats Gerais Finais
        val_compra_total = df_final["vlr_compra_total"].sum()
        
        try:
            val_venda_mensal = df_final.select((pl.col("media_venda_dia") * 30 * pl.col("custo_unitario")).sum()).item()
            cobertura = (val_estoque_atual / val_venda_mensal) if val_venda_mensal > 0 else 0.0
        except:
            cobertura = 0.0
        
        df_compra = df_final.filter(pl.col("sugestao_final") > 0)
        
        # PAYLOAD COMPLETO PARA O DASHBOARD (JSON)
        stats_payload = {
            # Gerais
            "total_valor": val_compra_total,
            "total_skus": len(df_compra),
            "total_pecas": df_compra["sugestao_final"].sum(),
            "estoque_atual": val_estoque_atual,
            "cobertura_meses": cobertura,
            "abc_breakdown": abc_data,
            
            # Detalhamento de Risco (Novos Campos)
            "obs_valor": obs_valor,
            "obs_pct_valor": pct_obs_valor,
            "obs_skus": obs_skus,
            "obs_pct_skus": pct_obs_skus,
            "obs_pecas": obs_pecas
        }
        
        # Envia para o Frontend via arquivo seguro
        reporter.salvar_stats(stats_payload)
        guard.log(f"âœ… EstatÃ­sticas calculadas e enviadas ao Dashboard.")
        
        # 6.5 ExportaÃ§Ã£o Excel e HistÃ³rico
        if not args.simulacao:
            guard.log("ğŸ“‘ Gerando relatÃ³rio Excel detalhado...")
            exporter = ExcelExporter(PROJECT_ROOT / "data" / "exports")
            
            # OrdenaÃ§Ã£o inteligente: Primeiro os problemas (Alertas), depois os Melhores (Score)
            df_final = df_final.sort(["alerta_dados", "score"], descending=[True, True])
            
            arquivo = exporter.exportar_sugestao(df_final)
            guard.log(f"âœ… RelatÃ³rio disponÃ­vel em: {arquivo}")
            
            if recorder:
                guard.log("ğŸ•°ï¸ Gravando snapshot no HistÃ³rico...")
                contexto = {
                    "marca": args.marca,
                    "usuario": "Usuario_Padrao",
                    "stats": stats_payload,
                    "config": config_mgr.parametros.model_dump()
                }
                recorder.gravar_snapshot(df_final, contexto)
        
        guard.log("ğŸ Processamento concluÃ­do com sucesso!")
        
    except Exception as e:
        guard.log(f"âŒ ERRO CRÃTICO DURANTE EXECUÃ‡ÃƒO: {e}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        db.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/gerar_relatorio_final.py


START FILE: scripts/auditoria_automatica.py
--------------------------------------------------------------------------------
import json
import sys
import yaml
import duckdb
from pathlib import Path
from decimal import Decimal

# =========================================================
# CONFIGURAÃ‡ÃƒO
# =========================================================
ROOT_DIR = Path(__file__).resolve().parent.parent
CONFIG_PATH = ROOT_DIR / "config" / "parametros.yaml"
DB_PATH = ROOT_DIR / "data" / "vendas.db"
SCRIPT_RESULTADO = ROOT_DIR / "scripts" / "gerar_relatorio_final.py"

MARCA_TESTE = sys.argv[1] if len(sys.argv) > 1 else "TODAS"

# =========================================================
# FUNÃ‡Ã•ES AUXILIARES
# =========================================================
def erro(msg):
    print(f"âŒ ERRO DE AUDITORIA: {msg}")
    sys.exit(1)

def ok(msg):
    print(f"âœ… {msg}")

def warn(msg):
    print(f"âš ï¸ {msg}")

# =========================================================
# 1. AUDITORIA DE PARÃ‚METROS
# =========================================================
print("\nğŸ” ETAPA 1 â€” VALIDANDO PARÃ‚METROS")

if not CONFIG_PATH.exists():
    erro("Arquivo parametros.yaml nÃ£o encontrado")

with open(CONFIG_PATH, "r", encoding="utf-8") as f:
    cfg = yaml.safe_load(f)

try:
    cobertura = float(cfg["compras"]["meses_cobertura"])
    lead_time = int(cfg["lead_time"]["padrao_dias"])
    dias_novo = int(cfg["produto"]["dias_lancamento"])
except Exception:
    erro("ParÃ¢metros invÃ¡lidos ou ausentes no YAML")

ok(f"ParÃ¢metros OK | Cobertura={cobertura}, LeadTime={lead_time}, DiasNovo={dias_novo}")

# =========================================================
# 2. AUDITORIA DO BANCO
# =========================================================
print("\nğŸ” ETAPA 2 â€” VALIDANDO BANCO DE DADOS")

if not DB_PATH.exists():
    erro("Banco de dados nÃ£o encontrado")

con = duckdb.connect(":memory:")
con.execute(f"ATTACH '{DB_PATH}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")

# Testa leitura bÃ¡sica
try:
    total_linhas = con.execute(
        "SELECT COUNT(*) FROM sqlite_db.produtos_gerais"
    ).fetchone()[0]
except Exception:
    erro("Tabela produtos_gerais nÃ£o acessÃ­vel")

ok(f"Banco acessÃ­vel | Total registros: {total_linhas}")

# =========================================================
# 3. AUDITORIA DE FILTRO DE MARCA
# =========================================================
print("\nğŸ” ETAPA 3 â€” VALIDANDO FILTRO DE MARCA")

query_marca = """
SELECT
    COUNT(DISTINCT sku),
    SUM(estoque_atual),
    SUM(valor_estoque)
FROM sqlite_db.produtos_gerais
WHERE (? = 'TODAS' OR marca = ?)
"""

skus_db, pecas_db, valor_db = con.execute(
    query_marca, [MARCA_TESTE, MARCA_TESTE]
).fetchone()

ok(f"Marca '{MARCA_TESTE}' | SKUs={skus_db}, PeÃ§as={pecas_db}, Valor={valor_db}")

# =========================================================
# 4. EXECUTA O MOTOR EM MODO SIMULAÃ‡ÃƒO
# =========================================================
print("\nğŸ” ETAPA 4 â€” EXECUTANDO MOTOR DE CÃLCULO")

import subprocess

cmd = [
    sys.executable,
    str(SCRIPT_RESULTADO),
    "--marca",
    MARCA_TESTE,
    "--simulacao"
]

process = subprocess.Popen(
    cmd,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
    encoding="utf-8"
)

stats = None

for line in process.stdout:
    if "STATS_DATA=" in line:
        stats = json.loads(line.replace("STATS_DATA=", "").strip())

process.wait()

if process.returncode != 0:
    erro("Motor de cÃ¡lculo retornou erro")

if not stats:
    erro("STATS_DATA nÃ£o encontrado na execuÃ§Ã£o")

ok("Motor executado com sucesso")

# =========================================================
# 5. AUDITORIA DE CONSISTÃŠNCIA DOS KPIs
# =========================================================
print("\nğŸ” ETAPA 5 â€” VALIDANDO KPIs")

def dec(v):
    return Decimal(str(v)).quantize(Decimal("0.01"))

total_skus = int(stats.get("total_skus", 0))
total_pecas = int(stats.get("total_pecas", 0))
total_valor = dec(stats.get("total_valor", 0))
estoque_atual = dec(stats.get("estoque_atual", 0))
cobertura_calc = float(stats.get("cobertura_meses", 0))

if total_skus < 0 or total_pecas < 0:
    erro("KPIs com valores negativos")

if total_skus > skus_db:
    erro("Total de SKUs maior que o banco")

if dec(valor_db) < estoque_atual:
    warn("Valor de estoque do KPI maior que o valor do banco (verifique regra)")

ok(f"KPIs OK | Valor={total_valor} | SKUs={total_skus} | PeÃ§as={total_pecas}")

# =========================================================
# 6. REGRAS DE SANIDADE
# =========================================================
print("\nğŸ” ETAPA 6 â€” REGRAS DE SANIDADE")

if cobertura_calc < 0:
    erro("Cobertura negativa detectada")

if cobertura_calc > 24:
    warn("Cobertura acima de 24 meses (verificar parÃ¢metros)")

ok(f"Cobertura vÃ¡lida: {cobertura_calc:.2f} meses")

# =========================================================
# FINAL
# =========================================================
con.close()

print("\nğŸ‰ AUDITORIA CONCLUÃDA COM SUCESSO")
print("âœ” Dados consistentes")
print("âœ” CÃ¡lculos coerentes")
print("âœ” KPIs validados")

--------------------------------------------------------------------------------
END FILE: scripts/auditoria_automatica.py


START FILE: scripts/export_project_context.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

# ConfiguraÃ§Ã£o
PROJECT_ROOT = Path(__file__).parent.parent
OUTPUT_FILE = PROJECT_ROOT / "contexto_completo_para_ia.txt"

# Pastas e arquivos que queremos incluir
INCLUDED_DIRS = [
    PROJECT_ROOT / "src",
    PROJECT_ROOT / "scripts",
    PROJECT_ROOT / "config",
]

# Arquivos especÃ­ficos para ignorar (opcional)
IGNORE_FILES = ["__pycache__", ".DS_Store", "vendas.db", "analytics.duckdb", ".git", ".vscode"]

def generate_tree(root_dir):
    """Gera uma representaÃ§Ã£o visual da Ã¡rvore de arquivos."""
    tree_str = "PROJECT STRUCTURE:\n"
    for path in sorted(root_dir.rglob('*')):
        if any(part.startswith('.') or part == "__pycache__" for part in path.parts):
            continue
        if path.is_file() and path.suffix in ['.py', '.yaml', '.json', '.sql']:
            depth = len(path.relative_to(root_dir).parts)
            indent = '    ' * (depth - 1)
            tree_str += f"{indent}â”œâ”€â”€ {path.name}\n"
    return tree_str + "\n" + "="*50 + "\n\n"

def main():
    print(f"ğŸ“¦ Empacotando projeto em: {OUTPUT_FILE}")
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # 1. Escreve o CabeÃ§alho e Estrutura
        out.write("CONTEXTO DO PROJETO DE COMPRAS E ESTOQUE\n")
        out.write("Linguagem: Python 3.11\n")
        out.write("Libs principais: Polars, DuckDB, OpenPyXL\n\n")
        out.write(generate_tree(PROJECT_ROOT))
        
        # 2. Varre os arquivos e escreve o conteÃºdo
        for folder in INCLUDED_DIRS:
            if not folder.exists(): continue
            
            for root, dirs, files in os.walk(folder):
                # Filtra pastas ignoradas
                dirs[:] = [d for d in dirs if d not in IGNORE_FILES]
                
                for file in files:
                    if file in IGNORE_FILES or not file.endswith(('.py', '.yaml')):
                        continue
                        
                    file_path = Path(root) / file
                    rel_path = file_path.relative_to(PROJECT_ROOT)
                    
                    # Escreve o separador e o nome do arquivo
                    out.write(f"FILE: {rel_path}\n")
                    out.write("-" * 50 + "\n")
                    
                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            content = f.read()
                            out.write(content)
                    except Exception as e:
                        out.write(f"# Erro ao ler arquivo: {e}")
                    
                    out.write("\n\n" + "="*50 + "\n\n")
    
    print("âœ… Arquivo gerado com sucesso!")
    print("Agora vocÃª pode anexar 'contexto_completo_para_ia.txt' no chat da IA.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/export_project_context.py


START FILE: scripts/auditor_item.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb
from datetime import datetime
import math

# ConfiguraÃ§Ã£o de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    print("ğŸ•µï¸  AUDITOR DE CÃLCULO DE COMPRAS (RAIO-X - DB INTEGRADO)")
    print("==========================================")
    cod_alvo = input("Digite o CÃ“DIGO DO PRODUTO para auditar: ").strip()

    # 1. CONEXÃƒO COM DADOS
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    
    if not db_path.exists():
        print("âŒ Banco de dados vendas.db nÃ£o encontrado!")
        return

    conn = duckdb.connect()
    conn.execute("INSTALL sqlite; LOAD sqlite;")
    conn.execute(f"ATTACH '{db_path}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
    
    print(f"\nğŸ” 1. DADOS BRUTOS (Banco de Dados)")
    print("-" * 50)

    # --- BUSCA DADOS CADASTRAIS ---
    try:
        cadastro = conn.execute(f"""
            SELECT ativo, qtd_economica, marca 
            FROM sqlite_db.produtos_gerais 
            WHERE cod_produto = '{cod_alvo}'
        """).fetchone()
        
        ativo = cadastro[0] if cadastro else "SIM (NÃ£o encontrado)"
        lote = cadastro[1] if cadastro and cadastro[1] else 1
        marca = cadastro[2] if cadastro else "N/D"
    except:
        ativo = "ERRO LEITURA"
        lote = 1
        marca = "?"
    
    print(f"â€¢ Cadastro: Ativo={ativo} | Lote={lote} | Marca={marca}")

    # --- BUSCA ESTOQUE (NOVA TABELA) ---
    try:
        estoque_data = conn.execute(f"""
            SELECT saldo_estoque, saldo_oc, custo_unitario, ultima_entrada
            FROM sqlite_db.saldo_custo_entrada
            WHERE CAST(cod_produto AS VARCHAR) = '{cod_alvo}'
        """).fetchone()
    except Exception as e:
        print(f"âŒ Erro ao ler tabela 'saldo_custo_entrada': {e}")
        estoque_data = None
    
    if not estoque_data:
        print("âŒ ERRO: Item nÃ£o encontrado na tabela de saldo!")
        return

    saldo = estoque_data[0] if estoque_data[0] else 0
    saldo_oc = estoque_data[1] if estoque_data[1] else 0
    custo = estoque_data[2] if estoque_data[2] else 0.0
    ult_entrada = estoque_data[3]
    
    print(f"â€¢ Estoque: FÃ­sico={saldo} | OC={saldo_oc} | Custo=R${custo:.2f}")
    print(f"â€¢ Ãšltima Entrada: {ult_entrada}")

    # --- BUSCA VENDAS (MÃ‰DIA REAL 365 DIAS) ---
    vendas_365 = conn.execute(f"""
        SELECT SUM(quantidade) 
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
        AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
    """).fetchone()
    
    total_vendas_ano = vendas_365[0] if vendas_365[0] else 0
    media_diaria_real = total_vendas_ano / 365.0
    
    print(f"â€¢ Vendas 365 dias: {total_vendas_ano} peÃ§as")
    print(f"â€¢ MÃ©dia DiÃ¡ria (Total/365): {media_diaria_real:.4f}")

    # ... (O restante do cÃ³digo de cÃ¡lculo permanece igual, pois usa as variÃ¡veis carregadas acima) ...
    # Para economizar espaÃ§o, mantive apenas a parte de extraÃ§Ã£o de dados que mudou.
    
    # ... [CÃ“DIGO DE CÃLCULO MANTIDO IGUAL AO ORIGINAL] ...

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/auditor_item.py


START FILE: scripts/fix_toml.py
--------------------------------------------------------------------------------
from pathlib import Path

# ConteÃºdo correto do pyproject.toml
content = """[project]
name = "compras-estoque-sistema"
version = "1.0.0"
description = "Sistema modular de compras e gestÃ£o de estoque"
requires-python = ">=3.11"
dependencies = [
    "duckdb>=1.1.0",
    "polars>=1.12.0",
    "pydantic>=2.9.0",
    "pyyaml>=6.0.2",
    "pandera[polars]>=0.20.4",
    "structlog>=24.4.0",
    "openpyxl>=3.1.5",
    "reportlab>=4.2.5",
    "pyinstaller>=6.11.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.3",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "hypothesis>=6.115.6",
    "ruff>=0.7.4",
    "mypy>=1.13.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
dev-dependencies = ["ruff", "mypy", "pytest"]

# Esta seÃ§Ã£o ensina o hatchling onde encontrar o cÃ³digo
[tool.hatch.build.targets.wheel]
packages = ["src/compras_sistema"]
"""

# Reescreve o arquivo na raiz do projeto
root_dir = Path(__file__).parent.parent
toml_path = root_dir / "pyproject.toml"

print(f"ğŸ”§ Corrigindo: {toml_path}")
with open(toml_path, "w", encoding="utf-8") as f:
    f.write(content)

print("âœ… pyproject.toml corrigido com sucesso!")
--------------------------------------------------------------------------------
END FILE: scripts/fix_toml.py


START FILE: scripts/setup_database.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path
import sys

# Setup de caminhos
ROOT_DIR = Path(__file__).parent.parent
DATA_DIR = ROOT_DIR / "data"
DB_PATH = DATA_DIR / "vendas.db"

def setup_database():
    print("ğŸš€ Iniciando criaÃ§Ã£o do Banco de Dados de Vendas...")
    
    # 1. Encontrar o arquivo de vendas (CSV)
    # Procura arquivos que contenham "Movimento" ou "Vendas" no nome
    sales_files = list(DATA_DIR.glob("*ovimento*.csv")) + list(DATA_DIR.glob("*endas*.csv"))
    
    if not sales_files:
        print("âŒ Nenhum arquivo de vendas encontrado na pasta 'data/'!")
        print("   Por favor, coloque o arquivo CSV de vendas (ex: 'Movimento.csv') lÃ¡.")
        return
    
    csv_path = sales_files[0]
    print(f"ğŸ“‚ Arquivo de origem detectado: {csv_path.name}")

    # 2. Conectar ao DuckDB (em memÃ³ria para processamento rÃ¡pido)
    con = duckdb.connect()
    
    try:
        # 3. Ler o CSV e tratar colunas
        # Baseado no PDF, mapeamos os nomes originais para o padrÃ£o do sistema
        print("â³ Lendo CSV e convertendo dados...")
        
        # Cria uma view temporÃ¡ria lendo o CSV
        con.execute(f"""
            CREATE VIEW raw_vendas AS 
            SELECT * FROM read_csv_auto('{str(csv_path)}', normalize_names=True)
        """)
        
        # Verifica quais colunas existem para garantir o mapeamento
        columns = [c[0] for c in con.execute("DESCRIBE raw_vendas").fetchall()]
        print(f"   Colunas detectadas: {columns}")
        
        # Query de transformaÃ§Ã£o (Adapte os nomes 'cod_produto', 'data', etc se necessÃ¡rio)
        # O DuckDB normalize_names remove acentos e espaÃ§os (ex: "CÃ³d. Produto" vira "cod_produto")
        query = """
            SELECT 
                CAST(cod_produto AS VARCHAR) as cod_produto,
                CAST(data AS DATE) as data_movimento,
                CAST(qtde AS INTEGER) as quantidade,
                CAST(total AS DECIMAL(10,2)) as valor_total,
                CAST(cod_clifor AS INTEGER) as cod_cliente,
                uf as uf_cliente
            FROM raw_vendas
            WHERE data IS NOT NULL
        """
        
        # 4. Salvar no SQLite
        print(f"ğŸ’¾ Salvando em {DB_PATH.name}...")
        
        # Remove banco antigo se existir para recriar do zero
        if DB_PATH.exists():
            DB_PATH.unlink()
            
        con.execute(f"ATTACH '{str(DB_PATH)}' AS sqlite_db (TYPE SQLITE)")
        con.execute(f"CREATE TABLE sqlite_db.vendas AS {query}")
        
        # ValidaÃ§Ã£o
        count = con.execute("SELECT COUNT(*) FROM sqlite_db.vendas").fetchone()[0]
        print(f"\nâœ… Sucesso! {count:,} registros de vendas importados.")
        
        # Mostra prÃ©via
        print("\nğŸ“Š Amostra dos dados gravados:")
        print(con.execute("SELECT * FROM sqlite_db.vendas LIMIT 5").df())
        
    except Exception as e:
        print(f"\nâŒ Erro durante a importaÃ§Ã£o: {e}")
        print("Dica: Verifique se os nomes das colunas no CSV batem com a query.")
        
    finally:
        con.close()

if __name__ == "__main__":
    setup_database()
--------------------------------------------------------------------------------
END FILE: scripts/setup_database.py


START FILE: scripts/verificar_ambiente.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path

# Adiciona o src ao path para poder importar os mÃ³dulos
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root / "src"))

import structlog
from compras_sistema.core.config import ConfigManager
from compras_sistema.data_engine.duckdb_manager import DuckDBManager

# Configurar logger simples para o teste
structlog.configure(
    processors=[structlog.processors.JSONRenderer()],
)

def main():
    print("ğŸš€ Iniciando verificaÃ§Ã£o do ambiente...\n")
    
    # 1. Teste de ConfiguraÃ§Ã£o
    try:
        config_mgr = ConfigManager()
        config_mgr.load_configs(project_root / "config")
        print("âœ… ConfiguraÃ§Ãµes carregadas com sucesso!")
    except Exception as e:
        print(f"âŒ Erro ao carregar configuraÃ§Ãµes: {e}")
        return

    # 2. Teste de Banco de Dados
    sqlite_path = project_root / "data" / "vendas.db" 
    
    if not sqlite_path.exists():
        print(f"âš ï¸  Banco de dados nÃ£o encontrado em: {sqlite_path}")
    
    try:
        db = DuckDBManager()
        db.initialize(sqlite_path)
        
        with db.get_connection() as conn:
            # Verifica se a nova tabela existe
            print("â³ Verificando tabela 'saldo_custo_entrada'...")
            try:
                res = conn.execute("SELECT * FROM sqlite_db.saldo_custo_entrada LIMIT 3").pl()
                print("\nâœ… Tabela de Estoque encontrada no Banco de Dados!")
                print("\nğŸ“Š PrÃ©via dos Dados:")
                print(res)
            except Exception as e:
                print(f"\nâŒ Tabela 'saldo_custo_entrada' NÃƒO encontrada no banco! Erro: {e}")
                
    except Exception as e:
        print(f"âŒ Erro no DuckDB: {e}")

    print("\nğŸ VerificaÃ§Ã£o concluÃ­da.")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/verificar_ambiente.py


START FILE: scripts/testar_analytics.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import polars as pl

# Setup de Caminhos
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.analytics_service import AnalyticsService

def main():
    print("--- ğŸ“Š TESTE DO SERVIÃ‡O DE ANALYTICS (CORRIGIDO) ---")
    
    # 1. ConexÃ£o
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    print(f"ğŸ“‚ Conectando ao banco: {db_path}")
    
    db = DuckDBManager()
    db.initialize(db_path)
    
    # --- DIAGNÃ“STICO DO BANCO DE DADOS ---
    print("\nğŸ” Verificando tabelas existentes no DuckDB:")
    with db.get_connection() as conn:
        tabelas = conn.execute("SHOW TABLES").fetchall()
        lista_tabelas = [t[0] for t in tabelas]
        print(f"   Tabelas encontradas: {lista_tabelas}")
        
        if "historico_snapshots" not in lista_tabelas:
            print("   âš ï¸ AVISO CRÃTICO: Tabela 'historico_snapshots' NÃƒO EXISTE.")
            print("   -> SoluÃ§Ã£o: Rode 'python scripts/gerar_relatorio_final.py' novamente para criar a tabela.")
        else:
            qtd = conn.execute("SELECT COUNT(*) FROM historico_snapshots").fetchone()[0]
            print(f"   âœ… Tabela 'historico_snapshots' existe com {qtd} registros.")

    service = AnalyticsService(db)
    
    # 2. Teste de KPIs Atuais
    print("\n1. Buscando KPIs Atuais...")
    kpis = service.get_kpis_atuais()
    print(f"   Resultado: {kpis}")
    
    # 3. Teste de TendÃªncia (GrÃ¡fico)
    print("\n2. Buscando TendÃªncia de Cobertura (HistÃ³rico)...")
    
    # CORREÃ‡ÃƒO AQUI: O parÃ¢metro correto Ã© 'dias_historico', nÃ£o 'dias'
    df_tendencia = service.get_tendencia_cobertura(dias_historico=30)
    
    if df_tendencia.is_empty():
        print("âš ï¸ DataFrame vazio! O serviÃ§o rodou, mas nÃ£o achou dados no perÃ­odo.")
    else:
        print(f"âœ… Sucesso! Retornou {len(df_tendencia)} linhas.")
        print(df_tendencia)
        
        print("\n--- PrÃ©via dos Dados para o GrÃ¡fico ---")
        for row in df_tendencia.iter_rows(named=True):
            print(f"Data: {row['data']} | Curva: {row['curva_abc']} | Cobertura: {row['cobertura_meses']} meses")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/testar_analytics.py


START FILE: scripts/debug_item.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    cod_alvo = input("Digite o cÃ³digo do produto problemÃ¡tico: ")
    
    db_path = PROJECT_ROOT / "data" / "vendas.db"
    conn = duckdb.connect()
    conn.execute("INSTALL sqlite; LOAD sqlite;")
    conn.execute(f"ATTACH '{db_path}' AS sqlite_db (TYPE SQLITE)")
    
    print(f"\nğŸ” INVESTIGANDO O ITEM: {cod_alvo}")
    print("-" * 50)
    
    # 1. Vendas Totais da HistÃ³ria
    total_hist = conn.execute(f"""
        SELECT SUM(quantidade), MIN(data_movimento), MAX(data_movimento) 
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
    """).fetchone()
    print(f"HistÃ³rico Completo: {total_hist[0]} peÃ§as vendidas de {total_hist[1]} atÃ© {total_hist[2]}")
    
    # 2. Vendas nos Ãšltimos 12 Meses (O que importa para o cÃ¡lculo)
    venda_12m = conn.execute(f"""
        SELECT SUM(quantidade)
        FROM sqlite_db.vendas 
        WHERE cod_produto = '{cod_alvo}'
        AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
    """).fetchone()[0]
    
    venda_12m = venda_12m if venda_12m else 0
    media_calc = venda_12m / 365.0
    
    print(f"Venda Ãšltimos 365 dias: {venda_12m} peÃ§as")
    print(f"MÃ©dia DiÃ¡ria Real (Total/365): {media_calc:.4f}")
    print("-" * 50)
    
    if venda_12m == 0:
        print("âœ… DIAGNÃ“STICO: O item estÃ¡ MORTO (0 vendas em 1 ano).")
        print("A mÃ©dia DEVE ser 0.00.")
    else:
        print("âš ï¸ DIAGNÃ“STICO: Existem vendas ocultas nos Ãºltimos 12 meses.")
        # Mostra as vendas fantasmas
        print("\nğŸ“… Detalhe das vendas encontradas (Ãºltimos 12 meses):")
        detalhe = conn.execute(f"""
            SELECT data_movimento, quantidade 
            FROM sqlite_db.vendas 
            WHERE cod_produto = '{cod_alvo}'
            AND CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '365 days')
            ORDER BY data_movimento DESC
        """).df()
        print(detalhe)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/debug_item.py


START FILE: scripts/calcular_sazonalidade.py
--------------------------------------------------------------------------------
import sys
from pathlib import Path
import duckdb

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

def main():
    print("ğŸŒŠ Calculando Ãndices de Sazonalidade...")
    
    # Caminhos dos arquivos
    sqlite_path = PROJECT_ROOT / "data" / "vendas.db"
    
    # Usaremos um arquivo DuckDB persistente para salvar os Ã­ndices
    # Assim o outro script consegue ler depois
    duck_path = PROJECT_ROOT / "data" / "analytics.duckdb"
    
    # Conecta (ou cria) o banco analÃ­tico
    conn = duckdb.connect(str(duck_path))
    
    try:
        # 1. Instala suporte a SQLite (caso nÃ£o tenha)
        conn.execute("INSTALL sqlite; LOAD sqlite;")
        
        # 2. Anexa o banco de vendas (O PULO DO GATO QUE FALTAVA)
        # Agora o DuckDB enxerga o 'sqlite_db'
        print(f"ğŸ”Œ Conectando ao histÃ³rico: {sqlite_path}")
        conn.execute(f"ATTACH '{sqlite_path}' AS sqlite_db (TYPE SQLITE)")
        
        # 3. Cria tabela de Ã­ndices
        print("ğŸ“Š Processando estatÃ­sticas mensais...")
        conn.execute("""
            CREATE OR REPLACE TABLE indices_sazonais AS
            WITH vendas_mensais AS (
                SELECT 
                    EXTRACT(MONTH FROM CAST(data_movimento AS DATE)) as mes,
                    SUM(quantidade) as qtd_total
                FROM sqlite_db.vendas
                WHERE CAST(data_movimento AS DATE) >= (CURRENT_DATE - INTERVAL '24 months')
                GROUP BY 1
            ),
            media_global AS (
                SELECT AVG(qtd_total) as media_ano FROM vendas_mensais
            )
            SELECT 
                mes,
                qtd_total / media_global.media_ano as indice_sazonal
            FROM vendas_mensais, media_global
            ORDER BY mes;
        """)
        
        print("âœ… Ãndices calculados e salvos em 'analytics.duckdb':")
        print(conn.execute("SELECT * FROM indices_sazonais").df())
        
    except Exception as e:
        print(f"âŒ Erro: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
END FILE: scripts/calcular_sazonalidade.py


START FILE: scripts/inspect_db.py
--------------------------------------------------------------------------------
import duckdb
from pathlib import Path

# Caminhos
BASE_DIR = Path(__file__).parent.parent
DB_PATH = BASE_DIR / "data" / "vendas.db"

def inspect():
    print(f"ğŸ” Inspecionando banco de dados: {DB_PATH}")
    
    if not DB_PATH.exists():
        print("âŒ ERRO: O arquivo 'vendas.db' nÃ£o foi encontrado na pasta 'data/'")
        return

    try:
        con = duckdb.connect(":memory:")
        con.execute(f"ATTACH '{str(DB_PATH)}' AS sqlite_db (TYPE SQLITE, READ_ONLY)")
        
        # Verifica tabela
        print("\nğŸ“‹ Estrutura da tabela 'vendas':")
        print(f"{'Nome da Coluna':<25} | {'Tipo de Dado'}")
        print("-" * 45)
        
        # CORREÃ‡ÃƒO: Usamos fetchall() (listas nativas) em vez de .df()
        columns = con.execute("DESCRIBE sqlite_db.vendas").fetchall()
        
        for col in columns:
            name = col[0]
            dtype = col[1]
            print(f"{name:<25} | {dtype}")

        print("\nğŸ“Š Amostra de dados (Via Polars):")
        # Aqui usamos .pl() porque o Polars jÃ¡ estÃ¡ instalado e testado
        print(con.execute("SELECT * FROM sqlite_db.vendas LIMIT 3").pl())

    except Exception as e:
        print(f"âŒ Erro ao ler o banco: {e}")

if __name__ == "__main__":
    inspect()

--------------------------------------------------------------------------------
END FILE: scripts/inspect_db.py


START FILE: .pytest_cache/README.md
--------------------------------------------------------------------------------
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

--------------------------------------------------------------------------------
END FILE: .pytest_cache/README.md


START FILE: backups/antes_melhorias/gerar_relatorio_final.py
--------------------------------------------------------------------------------
codigo_relatorio = '''"""
Script principal de geraÃ§Ã£o de relatÃ³rios - VERSÃƒO MELHORADA
Aplica sazonalidade preservando mÃ©dia base
"""
import sys
import argparse
import json
from pathlib import Path
from datetime import datetime
import polars as pl
import traceback

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from compras_sistema.core.config import ConfigManager
from compras_sistema.core.system_guard import SystemGuard
from compras_sistema.data_engine.duckdb_manager import DuckDBManager
from compras_sistema.data_engine.history_recorder import HistoryRecorder
from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
from compras_sistema.rule_engine.classification.xyz_classifier import XYZClassifier
from compras_sistema.rule_engine.classification.trend_classifier import TrendClassifier
from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
from compras_sistema.export.excel_exporter import ExcelExporter


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--marca", type=str, default="TODAS", help="Filtrar por marca")
    parser.add_argument("--simulacao", action="store_true", help="NÃ£o gera Excel, apenas calcula")
    args = parser.parse_args()
    
    guard = SystemGuard(PROJECT_ROOT / "logs")
    print(f"--- LOG START ---")
    guard.log(f"Processamento Iniciado - Marca: {args.marca}")
    
    # InicializaÃ§Ã£o
    config_mgr = ConfigManager()
    config_mgr.load_configs(PROJECT_ROOT / "config")
    
    db = DuckDBManager()
    db.initialize(PROJECT_ROOT / "data" / "vendas.db")
    
    recorder = HistoryRecorder(db) if not args.simulacao else None
    if recorder:
        recorder.inicializar_tabela()
    
    try:
        # --- 1. CLASSIFICAÃ‡Ã•ES ESTATÃSTICAS ---
        guard.log("Calculando ClassificaÃ§Ãµes ABC, XYZ, TendÃªncias...")
        abc_engine = ABCClassifier(db)
        xyz_engine = XYZClassifier(db, config_mgr.parametros)
        trend_engine = TrendClassifier(db)
        
        df_abc = abc_engine.run()
        df_xyz = xyz_engine.run()
        df_trend = trend_engine.run()
        
        # --- 2. LEITURA DE DADOS ---
        guard.log("Lendo Estoques e Cadastro Completo...")
        with db.get_connection() as conn:
            df_saldo = conn.execute("""
                SELECT 
                    CAST(cod_produto AS VARCHAR) as cod_produto,
                    saldo_estoque,
                    saldo_oc,
                    custo_unitario,
                    ultima_entrada
                FROM sqlite_db.saldo_custo_entrada
            """).pl()
            
            # Leitura dinÃ¢mica do cadastro
            try:
                cols_db = [c[1] for c in conn.execute("PRAGMA table_info(sqlite_db.produtos_gerais)").fetchall()]
                
                if "descricao_produto" in cols_db:
                    col_desc = "descricao_produto"
                elif "descricao" in cols_db:
                    col_desc = "descricao"
                else:
                    col_desc = "''" 
                
                col_data = "CAST(data_cadastro AS DATE)" if "data_cadastro" in cols_db else "CAST('2000-01-01' AS DATE)"
                col_ref = "ref_fornecedor" if "ref_fornecedor" in cols_db else "''"
                
                df_cadastro = conn.execute(f"""
                    SELECT 
                        CAST(cod_produto AS VARCHAR) as cod_produto,
                        CAST(qtd_economica AS INTEGER) as lote_economico,
                        marca,
                        {col_desc} as descricao,
                        {col_ref} as ref_fornecedor,
                        ativo,
                        {col_data} as data_cadastro
                    FROM sqlite_db.produtos_gerais
                """).pl()
            except Exception as e:
                guard.log(f"Erro ao ler cadastro: {e}. Usando estrutura vazia de seguranÃ§a.")
                df_cadastro = pl.DataFrame(schema={
                    "cod_produto": pl.Utf8, "lote_economico": pl.Int64, "marca": pl.Utf8,
                    "descricao": pl.Utf8, "ref_fornecedor": pl.Utf8, "ativo": pl.Utf8,
                    "data_cadastro": pl.Date
                })
        
        # Carrega Sazonalidade
        indices_dict = {}
        try:
            analytics_path = PROJECT_ROOT / "data" / "analytics.duckdb"
            if analytics_path.exists():
                conn.execute(f"ATTACH '{analytics_path}' AS analytics")
                rows = conn.execute("SELECT mes, indice_sazonal FROM analytics.indices_sazonais").fetchall()
                for r in rows:
                    indices_dict[r[0]] = r[1]
        except:
            pass
        
        # --- 3. UNIFICAÃ‡ÃƒO (JOIN) ---
        guard.log("Cruzando dados...")
        df_universe = pl.concat([
            df_xyz.select("cod_produto"),
            df_saldo.select("cod_produto"),
            df_cadastro.select("cod_produto")
        ]).unique(subset="cod_produto")
        
        df_final = df_universe \\
            .join(df_xyz, on="cod_produto", how="left") \\
            .join(df_abc, on="cod_produto", how="left") \\
            .join(df_trend, on="cod_produto", how="left") \\
            .join(df_saldo, on="cod_produto", how="left") \\
            .join(df_cadastro, on="cod_produto", how="left")
        
        # Tratamento de descriÃ§Ã£o duplicada
        if "descricao" not in df_final.columns:
            if "descricao_right" in df_final.columns:
                df_final = df_final.rename({"descricao_right": "descricao"})
            else:
                df_final = df_final.with_columns(pl.lit("SEM DESCRIÃ‡ÃƒO").alias("descricao"))
        
        # Preenchimento de Nulos
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").fill_null(0.0),
            pl.col("std_venda_dia").fill_null(0.0),
            pl.col("curva_xyz").fill_null("Z"),
            pl.col("dias_sem_venda").fill_null(0).alias("dias_sem_venda"),
            pl.col("saldo_estoque").fill_null(0),
            pl.col("saldo_oc").fill_null(0),
            pl.col("custo_unitario").fill_null(0.0),
            pl.col("curva_abc").fill_null("C"),
            pl.col("marca").fill_null("N/D"),
            pl.col("descricao").fill_null("DESCRIÃ‡ÃƒO NÃƒO ENCONTRADA"),
            pl.col("ref_fornecedor").fill_null(""),
            pl.col("lote_economico").fill_null(1),
            pl.col("ativo").fill_null("SIM"),
            pl.col("data_cadastro").fill_null(pl.lit(datetime(2000,1,1))),
            pl.lit(config_mgr.parametros.lead_time.padrao_dias).alias("lead_time_dias"),
        ])
        
        # --- 4. MOTOR DE CÃLCULO (COM MELHORIAS) ---
        guard.log("Executando Motor MatemÃ¡tico...")
        
        # MELHORIA 1: Salva mÃ©dia base ANTES da sazonalidade
        df_final = df_final.with_columns([
            pl.col("media_venda_dia").alias("media_venda_base")
        ])
        
        # Aplica sazonalidade
        df_final = EstoqueMath.aplicar_sazonalidade_projetada(df_final, indices_dict)
        
        # MELHORIA 2: Aplica sazonalidade SEM sobrescrever a base
        df_final = df_final.with_columns([
            pl.col("fator_sazonal_projetado").alias("fator_sazonal"),
            (pl.col("media_venda_base") * pl.col("fator_sazonal_projetado")).alias("media_venda_dia")
        ])
        
        # Continua com os cÃ¡lculos
        df_final = EstoqueMath.calcular_tendencias(df_final)
        df_final = EstoqueMath.calcular_seguranca(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_necessidades(df_final, config_mgr.parametros)
        df_final = EstoqueMath.aplicar_lote_economico(df_final, config_mgr.parametros)
        df_final = EstoqueMath.calcular_score(df_final)
        df_final = EstoqueMath.gerar_diagnostico(df_final, config_mgr.parametros)
        
        df_final = df_final.with_columns([
            (pl.col("saldo_estoque") + pl.col("saldo_oc") + pl.col("sugestao_final")).alias("meta_pos_compra")
        ])
        
        # --- 5. FILTRO DE MARCA ---
        if args.marca and args.marca != "TODAS":
            guard.log(f"Filtrando relatÃ³rio para marca: {args.marca}")
            df_final = df_final.filter(pl.col("marca") == args.marca)
        
        # --- 6. ESTATÃSTICAS PARA GUI ---
        try:
            val_estoque_atual = df_final.select((pl.col("saldo_estoque") * pl.col("custo_unitario")).sum()).item()
            val_venda_mensal = df_final.select((pl.col("media_venda_dia") * 30 * pl.col("custo_unitario")).sum()).item()
            
            if val_venda_mensal > 0:
                cobertura = val_estoque_atual / val_venda_mensal
            else:
                cobertura = 0.0
        except:
            val_estoque_atual = 0.0
            cobertura = 0.0
        
        df_compra = df_final.filter(pl.col("sugestao_final") > 0)
        
        stats = {
            "total_valor": df_compra["subtotal"].sum(),
            "total_skus": len(df_compra),
            "total_pecas": df_compra["sugestao_final"].sum(),
            "estoque_atual": val_estoque_atual,
            "cobertura_meses": cobertura
        }
        
        print(f"STATS_DATA={json.dumps(stats)}")
        
        # --- 7. EXPORTAÃ‡ÃƒO ---
        if not args.simulacao:
            guard.log("Gerando relatÃ³rio Excel...")
            exporter = ExcelExporter(PROJECT_ROOT / "data" / "exports")
            arquivo = exporter.exportar_sugestao(df_final.sort("score", descending=True))
            guard.log(f"RelatÃ³rio gerado: {arquivo}")
            
            if recorder:
                recorder.gravar_snapshot(df_final)
        
        guard.log("Processamento concluÃ­do com sucesso!")
        
    except Exception as e:
        guard.log(f"ERRO CRÃTICO: {e}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        db.close()


if __name__ == "__main__":
    main()
'''

print("\nâœ… Arquivo gerar_relatorio_final.py melhorado criado!")
print("\nğŸ“‹ MUDANÃ‡AS NO FLUXO:")
print("1. âœ… Salva 'media_venda_base' ANTES da sazonalidade")
print("2. âœ… Aplica sazonalidade criando nova coluna ao invÃ©s de sobrescrever")
print("3. âœ… Fluxo agora tem auditoria completa de valores intermediÃ¡rios")

--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/gerar_relatorio_final.py


START FILE: backups/antes_melhorias/excel_exporter.py
--------------------------------------------------------------------------------
codigo_excel = '''"""
Exportador de Excel com formataÃ§Ã£o profissional - VERSÃƒO MELHORADA
Adiciona novas colunas para auditoria
"""
import polars as pl
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)


class ExcelExporter:
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def exportar_sugestao(self, df: pl.DataFrame, filename: str = None):
        if filename is None:
            data_hoje = datetime.now().strftime("%Y%m%d_%H%M")
            filename = f"sugestao_compras_{data_hoje}.xlsx"
        
        filepath = self.output_dir / filename
        logger.info("iniciando_export_excel", path=str(filepath))
        
        # ======== ORDEM DAS COLUNAS (COM NOVAS) ========
        cols_export = [
            "status_diagnostico",
            "cod_produto",
            "descricao",
            "ref_fornecedor",
            "marca",
            "curva_abc",
            "curva_xyz",
            "sugestao_final",
            "sugestao_calculada",  # NOVA: Antes do bloqueio
            "calculado_mas_bloqueado",  # NOVA: Flag
            "motivo_bloqueio",  # NOVA: RazÃ£o do bloqueio
            "meta_pos_compra",
            "fator_sazonal",
            "lote_economico",
            "subtotal",
            "saldo_estoque",
            "saldo_oc",
            "cobertura_virtual_meses",
            "media_venda_base",  # NOVA: Sem sazonalidade
            "media_venda_dia",  # Ajustada
            "tendencia_vendas",
            "tendencia_clientes",
            "perfil_cliente",
            "validacao_giro",
            "custo_unitario",
            "score"
        ]
        
        cols_presentes = [c for c in cols_export if c in df.columns]
        records = df.select(cols_presentes).to_dicts()
        
        # ======== CRIAÃ‡ÃƒO DO EXCEL ========
        wb = Workbook()
        ws = wb.active
        ws.title = "Analise Compras"
        
        # Estilos
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
        center_align = Alignment(horizontal="center")
        left_align = Alignment(horizontal="left")
        thin_border = Border(
            left=Side(style="thin"), right=Side(style="thin"),
            top=Side(style="thin"), bottom=Side(style="thin")
        )
        
        fill_green = PatternFill(start_color="CCFFCC", fill_type="solid")
        fill_yellow = PatternFill(start_color="FFFFE0", fill_type="solid")
        fill_orange = PatternFill(start_color="FFD700", fill_type="solid")
        fill_blue_light = PatternFill(start_color="E6F3FF", fill_type="solid")
        fill_implanta = PatternFill(start_color="E0FFFF", fill_type="solid")
        fill_red = PatternFill(start_color="FFB6C1", fill_type="solid")  # NOVA: Para bloqueados
        
        # Mapeamento de nomes amigÃ¡veis
        mapa_nomes = {
            "META_POS_COMPRA": "POSIÃ‡ÃƒO FINAL",
            "FATOR_SAZONAL": "IDX SAZONAL",
            "MEDIA_VENDA_DIA": "GIRO DIA (AJUST)",
            "MEDIA_VENDA_BASE": "GIRO DIA (BASE)",  # NOVO
            "COBERTURA_VIRTUAL_MESES": "COBERTURA MESES",
            "REF_FORNECEDOR": "REF. FABRICA",
            "SUGESTAO_CALCULADA": "CALC. ORIGINAL",  # NOVO
            "CALCULADO_MAS_BLOQUEADO": "BLOQUEADO?",  # NOVO
            "MOTIVO_BLOQUEIO": "MOTIVO"  # NOVO
        }
        
        headers = [c.replace("_", " ").upper() for c in cols_presentes]
        headers = [mapa_nomes.get(h, h) for h in headers]
        
        ws.append(headers)
        
        # Formata cabeÃ§alho
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_align
        
        # Preenche dados
        for row_idx, row_data in enumerate(records, 2):
            for col_idx, col_name in enumerate(cols_presentes, 1):
                val = row_data[col_name]
                cell = ws.cell(row=row_idx, column=col_idx, value=val)
                cell.border = thin_border
                
                # Alinhamento
                if col_name == "descricao":
                    cell.alignment = left_align
                else:
                    cell.alignment = center_align
                
                # FormataÃ§Ã£o numÃ©rica
                if col_name in ["custo_unitario", "subtotal"]:
                    cell.number_format = 'R$ #,##0.00'
                elif col_name in ["media_venda_dia", "media_venda_base", "fator_sazonal"]:
                    cell.number_format = '0.00'
                elif col_name in ["cobertura_virtual_meses"]:
                    cell.number_format = '0.0'
                elif col_name == "score":
                    cell.number_format = '#,##0'
                
                # ======== FORMATAÃ‡ÃƒO CONDICIONAL ========
                
                # SugestÃµes de compra
                if col_name in ["sugestao_final", "subtotal"] and row_data.get("sugestao_final", 0) > 0:
                    cell.font = Font(bold=True, color="006400")
                    cell.fill = fill_green
                
                # NOVA: Destaque para produtos bloqueados
                if col_name == "calculado_mas_bloqueado" and val == "SIM":
                    cell.fill = fill_red
                    cell.font = Font(bold=True, color="8B0000")
                
                # NOVA: Motivo do bloqueio em vermelho
                if col_name == "motivo_bloqueio" and val:
                    cell.font = Font(color="DC143C", italic=True)
                
                # Fator sazonal
                if col_name == "fator_sazonal":
                    if isinstance(val, (int, float)):
                        if val < 0.90:
                            cell.font = Font(color="0000FF")
                            cell.fill = fill_blue_light
                        elif val > 1.10:
                            cell.font = Font(color="B22222", bold=True)
                
                # Status diagnÃ³stico
                if col_name == "status_diagnostico":
                    val_str = str(val).upper()
                    if "IMPLANTAÃ‡ÃƒO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "RUPTURA" in val_str:
                        cell.fill = PatternFill(start_color="FF0000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "BLOQUEADO" in val_str:
                        cell.fill = PatternFill(start_color="808080", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "INATIVO" in val_str:
                        cell.fill = PatternFill(start_color="000000", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "ALERTA" in val_str:
                        cell.fill = PatternFill(start_color="FF8C00", fill_type="solid")
                        cell.font = Font(color="FFFFFF", bold=True)
                    elif "EXCESSO" in val_str:
                        cell.fill = fill_yellow
                    elif "COMPRAR" in val_str:
                        cell.fill = fill_green
                
                # TendÃªncia vendas
                if col_name == "tendencia_vendas":
                    val_str = str(val).upper()
                    if "ALTA" in val_str:
                        cell.font = Font(color="006400", bold=True)
                    elif "QUEDA" in val_str:
                        cell.font = Font(color="FF0000", bold=True)
                
                # ValidaÃ§Ã£o de giro
                if col_name == "validacao_giro":
                    val_str = str(val)
                    if "ITEM NOVO" in val_str:
                        cell.fill = fill_implanta
                        cell.font = Font(color="00008B", bold=True)
                    elif "SEM MOVIMENTO" in val_str:
                        cell.font = Font(color="808080", italic=True)
                    elif "Excesso" in val_str:
                        cell.font = Font(bold=True, color="B22222")
                        cell.fill = fill_orange
        
        # Auto-ajuste de largura
        for col_idx, column_cells in enumerate(ws.columns, 1):
            max_length = 0
            column = get_column_letter(col_idx)
            limit = 60 if cols_presentes[col_idx-1] == "descricao" else 40
            
            for cell in column_cells:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            ws.column_dimensions[column].width = min(max_length + 3, limit)
        
        wb.save(filepath)
        logger.info("export_excel_concluido")
        return filepath
'''

print("\nâœ… Arquivo excel_exporter.py melhorado criado!")
print("\nğŸ“‹ NOVAS COLUNAS NO EXCEL:")
print("1. âœ… MEDIA_VENDA_BASE (GIRO DIA BASE) - Sem ajuste sazonal")
print("2. âœ… SUGESTAO_CALCULADA - Valor antes do bloqueio")
print("3. âœ… CALCULADO_MAS_BLOQUEADO - Flag SIM/NÃƒO")
print("4. âœ… MOTIVO_BLOQUEIO - RazÃ£o especÃ­fica do bloqueio")
print("5. âœ… FormataÃ§Ã£o condicional para produtos bloqueados (vermelho)")
--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/excel_exporter.py


START FILE: backups/antes_melhorias/estoque_math.py
--------------------------------------------------------------------------------
# Vou criar o arquivo estoque_math.py melhorado

codigo_estoque_math = '''"""
MÃ³dulo de cÃ¡lculos matemÃ¡ticos de estoque - VERSÃƒO MELHORADA
Implementa lÃ³gica de reposiÃ§Ã£o com validaÃ§Ãµes aprimoradas
"""
import polars as pl
import numpy as np
from datetime import datetime


class EstoqueMath:
    """Classe com mÃ©todos estÃ¡ticos para cÃ¡lculos de estoque"""
    
    @staticmethod
    def aplicar_sazonalidade_projetada(df: pl.DataFrame, indices_dict: dict) -> pl.DataFrame:
        """
        Calcula o fator sazonal baseando-se na DATA DE CHEGADA da mercadoria.
        MELHORIA: Preserva media_venda_base antes de aplicar sazonalidade
        """
        if not indices_dict or len(indices_dict) != 12:
            return df.with_columns(pl.lit(1.0).alias("fator_sazonal_projetado"))
        
        lista_indices = [indices_dict.get(m, 1.0) for m in range(1, 13)]
        mes_atual = datetime.now().month
        
        def calcular_fator_futuro(leadtime):
            if leadtime is None:
                leadtime = 7
            
            meses_espera = leadtime / 30.0
            duracao_estoque = 1.5
            soma_indices = 0.0
            pontos_verificados = 0
            cursor = meses_espera
            fim_janela = meses_espera + duracao_estoque
            
            while cursor < fim_janela:
                mes_futuro_absoluto = mes_atual + int(cursor)
                index_lista = (mes_futuro_absoluto - 1) % 12
                soma_indices += lista_indices[index_lista]
                pontos_verificados += 1
                cursor += 0.5
            
            if pontos_verificados == 0:
                return 1.0
            
            fator = soma_indices / pontos_verificados
            return max(0.5, min(fator, 2.5))
        
        return df.with_columns([
            pl.col("lead_time_dias").map_elements(
                calcular_fator_futuro, return_dtype=pl.Float64
            ).alias("fator_sazonal_projetado")
        ])

    @staticmethod
    def calcular_tendencias(df: pl.DataFrame) -> pl.DataFrame:
        """
        Calcula as classificaÃ§Ãµes de TendÃªncia e Perfil de Cliente.
        Trata valores nulos como zero para evitar erro de classificaÃ§Ã£o.
        """
        if "var_vendas" not in df.columns:
            df = df.with_columns([
                pl.lit(0.0).alias("var_vendas"),
                pl.lit(0).alias("saldo_clientes"),
                pl.lit(0).alias("qtd_clientes_ativos")
            ])
        
        return df.with_columns([
            # 1. TENDÃŠNCIA VENDAS
            pl.when(pl.col("var_vendas").fill_null(0.0) > 0.20).then(pl.lit("EM ALTA"))
            .when(pl.col("var_vendas").fill_null(0.0) < -0.20).then(pl.lit("EM QUEDA"))
            .otherwise(pl.lit("ESTÃVEL")).alias("tendencia_vendas"),
            
            # 2. TENDÃŠNCIA CLIENTES
            pl.when(pl.col("saldo_clientes").fill_null(0) > 0)
            .then(pl.format("GANHO +{}", pl.col("saldo_clientes")))
            .when(pl.col("saldo_clientes").fill_null(0) < 0)
            .then(pl.format("PERDA {}", pl.col("saldo_clientes")))
            .otherwise(pl.lit("MANTEVE")).alias("tendencia_clientes"),
            
            # 3. PERFIL CLIENTE
            pl.when(pl.col("qtd_clientes_ativos").fill_null(0) == 0).then(pl.lit("Sem Venda"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 2).then(pl.lit("Dedicado (1-2)"))
            .when(pl.col("qtd_clientes_ativos").fill_null(0) <= 9).then(pl.lit("Concentrado (3-9)"))
            .otherwise(pl.lit("Pulverizado (10+)")).alias("perfil_cliente")
        ])

    @staticmethod
    def calcular_seguranca(df: pl.DataFrame, config) -> pl.DataFrame:
        """Calcula Estoque de Seguran com proteo contra Lead Time Nulo."""
        def get_z_factor(xyz):
            if xyz == "X":
                return 1.65
            if xyz == "Y":
                return 1.28
            return 0.84
        
        return df.with_columns([
            pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64).alias("fator_z"),
            (
                pl.col("curva_xyz").map_elements(get_z_factor, return_dtype=pl.Float64) *
                pl.col("std_venda_dia") *
                pl.col("lead_time_dias").fill_null(7).sqrt()
            ).fill_null(0).alias("estoque_seguranca")
        ])

    @staticmethod
    def calcular_necessidades(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Calcula Ponto de Suprimento e Estoque Meta
        MELHORIA: Valida dias_vida ANTES de aplicar boost anti-ruptura
        """
        meses_cobertura = config.compras.meses_cobertura
        dias_novo = config.produto.dias_lancamento  # Normalmente 60
        
        # MELHORIA 1: Calcula dias_vida ANTES do boost
        df = df.with_columns([
            (pl.lit(datetime.now()) - pl.col("data_cadastro").dt.total_days()).alias("dias_vida")
        ])
        
        # MELHORIA 2: Boost anti-ruptura apenas para itens VELHOS
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                pl.col("curva_abc").is_in(["A", "B"]) &
                (pl.col("dias_vida") > dias_novo)  # <-- NOVA CONDIÃ‡ÃƒO
            )
            .then(
                pl.when(pl.col("dias_sem_venda") > 30).then(pl.col("media_venda_dia") * 1.20)
                .when(pl.col("dias_sem_venda") > 90).then(pl.col("media_venda_dia") * 1.50)
                .otherwise(pl.col("media_venda_dia") * 2.00)
            )
            .otherwise(pl.col("media_venda_dia"))
            .alias("media_calculo")
        ])
        
        return df.with_columns([
            (pl.col("media_calculo") * pl.col("lead_time_dias") + pl.col("estoque_seguranca")).round(0).alias("ponto_suprimento"),
            (pl.col("media_calculo") * 30 * meses_cobertura + pl.col("estoque_seguranca")).round(0).alias("estoque_meta")
        ]).with_columns([
            (pl.col("estoque_meta") - pl.col("saldo_estoque") - pl.col("saldo_oc")).alias("sugestao_bruta")
        ])

    @staticmethod
    def aplicar_lote_economico(df: pl.DataFrame, config) -> pl.DataFrame:
        """Arredonda para lotes econÃ´micos"""
        return df.with_columns([
            pl.when(pl.col("sugestao_bruta") <= 0).then(0).otherwise(pl.col("sugestao_bruta")).alias("necessidade_liquida")
        ]).with_columns([
            (pl.col("necessidade_liquida") / pl.col("lote_economico")).ceil().alias("lotes_cheios")
        ]).with_columns([
            (pl.col("lotes_cheios") * pl.col("lote_economico")).cast(pl.Int32).alias("sugestao_final")
        ]).with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal")
        ])

    @staticmethod
    def calcular_score(df: pl.DataFrame) -> pl.DataFrame:
        """Calcula pontuaÃ§Ã£o inicial de prioridade"""
        return df.with_columns([
            (
                pl.when(pl.col("saldo_estoque") == 0).then(5000).otherwise(0) +
                pl.when(pl.col("saldo_estoque") < pl.col("media_venda_dia") * pl.col("lead_time_dias")).then(2500).otherwise(0) +
                pl.when(pl.col("curva_abc") == "A").then(1000).when(pl.col("curva_abc") == "B").then(500).otherwise(100) +
                pl.when(pl.col("tendencia_vendas") == "EM ALTA").then(500).otherwise(0) +
                (pl.col("media_venda_dia") * pl.col("custo_unitario")).fill_null(0)
            ).round(0).cast(pl.Int32).alias("score")
        ])

    @staticmethod
    def gerar_diagnostico(df: pl.DataFrame, config) -> pl.DataFrame:
        """
        Gera diagnÃ³sticos e aplica a lÃ³gica de ITEM NOVO (ImplantaÃ§Ã£o)
        MELHORIAS:
        - Adiciona motivo_bloqueio
        - Adiciona calculado_mas_bloqueado
        - Recalcula score apÃ³s bloqueios
        """
        estoque_total = pl.col("saldo_estoque") + pl.col("saldo_oc")
        venda_mensal = pl.col("media_venda_dia") * 30
        dias_novo = config.produto.dias_lancamento
        
        # Calcula dias_vida se ainda nÃ£o existir
        if "dias_vida" not in df.columns:
            df = df.with_columns([
                (pl.lit(datetime.now()) - pl.col("data_cadastro").dt.total_days()).alias("dias_vida")
            ])
        
        # CÃ¡lculo de Cobertura
        base_calc = pl.when(estoque_total == 0).then(0.0).otherwise(estoque_total / venda_mensal)
        calc_cobertura = pl.when(base_calc.is_infinite()).then(99.0).otherwise(base_calc).fill_nan(99.0)
        
        df = df.with_columns([calc_cobertura.alias("cobertura_virtual_meses")])
        
        # 1. VALIDAÃ‡ÃƒO DE GIRO (O Juiz)
        df = df.with_columns([
            pl.when(
                (pl.col("saldo_estoque") == 0) &
                (pl.col("saldo_oc") == 0) &
                (pl.col("media_venda_dia") == 0)
            )
            .then(
                pl.when(pl.col("dias_vida") <= dias_novo)
                .then(pl.lit("SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)"))
                .otherwise(pl.lit("SEM MOVIMENTO (Item velho parado)"))
            )
            .when(pl.col("cobertura_virtual_meses") > 6).then(pl.lit("ALERTA: Excesso > 6m"))
            .when((pl.col("media_venda_dia") < 0.05) & (pl.col("sugestao_final") > 0)).then(pl.lit("ALERTA: Sem Venda Recente"))
            .otherwise(pl.lit("COERENTE")).alias("validacao_giro")
        ])
        
        # MELHORIA: Salva sugestÃ£o original antes do bloqueio
        df = df.with_columns([
            pl.col("sugestao_final").alias("sugestao_calculada")
        ])
        
        # 2. APLICA BLOQUEIOS E DEFINE MOTIVO
        df = df.with_columns([
            # Define motivo do bloqueio
            pl.when(pl.col("ativo") == "NO").then(pl.lit("Produto inativo no cadastro"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.col("validacao_giro"))
            .otherwise(pl.lit("")).alias("motivo_bloqueio"),
            
            # Flag: Foi calculado mas bloqueado?
            pl.when(
                (pl.col("sugestao_final") > 0) &
                ((pl.col("ativo") == "NO") | pl.col("validacao_giro").str.contains("ALERTA"))
            ).then(pl.lit("SIM")).otherwise(pl.lit("NÃƒO")).alias("calculado_mas_bloqueado"),
            
            # Aplica bloqueio na sugestÃ£o
            pl.when(pl.col("ativo") == "NO").then(0)
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)")
            .then(pl.col("lote_economico"))  # Item novo = 1 lote
            .otherwise(pl.col("sugestao_final")).alias("sugestao_final")
        ])
        
        # MELHORIA 3: RECALCULA SCORE APÃ“S BLOQUEIOS
        df = df.with_columns([
            pl.when(pl.col("sugestao_final") == 0).then(0)
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit(9999))
            .otherwise(pl.col("score")).alias("score")
        ])
        
        # 4. STATUS DIAGNÃ“STICO FINAL
        df = df.with_columns([
            (pl.col("sugestao_final") * pl.col("custo_unitario")).alias("subtotal"),
            
            pl.when(pl.col("ativo") == "NO").then(pl.lit("INATIVO"))
            .when(pl.col("validacao_giro").str.contains("ALERTA")).then(pl.lit("BLOQUEADO"))
            .when(pl.col("validacao_giro") == "SEM MOVIMENTO - ITEM NOVO (ImplantaÃ§Ã£o)").then(pl.lit("IMPLANTAÃ‡ÃƒO"))
            .when(pl.col("saldo_estoque") == 0).then(pl.lit("RUPTURA"))
            .when(pl.col("sugestao_final") > 0).then(pl.lit("COMPRAR"))
            .when(pl.col("cobertura_virtual_meses") > 12).then(pl.lit("EXCESSO"))
            .otherwise(pl.lit("OK")).alias("status_diagnostico")
        ])
        
        return df
'''

print("âœ… Arquivo estoque_math.py melhorado criado!")
print("\nğŸ“‹ MELHORIAS IMPLEMENTADAS:")
print("1. âœ… media_venda_base preservada (nÃ£o sobrescrita pela sazonalidade)")
print("2. âœ… ValidaÃ§Ã£o dias_vida ANTES do boost anti-ruptura")
print("3. âœ… Coluna 'motivo_bloqueio' adicionada")
print("4. âœ… Coluna 'calculado_mas_bloqueado' adicionada")
print("5. âœ… Score recalculado apÃ³s bloqueios")
print("6. âœ… Coluna 'sugestao_calculada' salva antes dos bloqueios")

--------------------------------------------------------------------------------
END FILE: backups/antes_melhorias/estoque_math.py


START FILE: config/parametros.yaml
--------------------------------------------------------------------------------
abc:
  A: 80.0
  B: 15.0
  C: 5.0
compras:
  meses_cobertura: 3.0
estoque:
  fator_z:
    X: 1.65
    Y: 1.28
    Z: 0.84
giro:
  limite_meses_cobertura: 6
  minimo_venda_dia: 0.05
historico:
  meses_analise: 36
  meses_tendencia: 6
lead_time:
  desvio_padrao: 2.0
  padrao_dias: 17
lote:
  limite_virada: 0.5
  minima_absoluta: 1
outlier:
  fator_multiplicador: 2.0
produto:
  dias_lancamento: 180
  dias_sem_entrada_obsoleto: 365
  dias_sem_venda_obsoleto: 180
risco:
  clientes_dependencia_alerta_A: 5
  clientes_dependencia_alerta_B: 2
  clientes_dependencia_total_A: 2
  limite_excesso: 6
  valor_alto_item_C: 1000.0
ruptura:
  boost_demanda_curva_AB: 1.2
sazonalidade:
  ativada: true
  fator_maximo: 2.5
  fator_minimo: 0.5
tolerancia_abc:
  A: 0.3
  B: 0.2
  C: 0.1
xyz:
  X:
    threshold: 0.5
    z_score: 1.65
  Y:
    threshold: 1.0
    z_score: 1.28
  Z:
    threshold: 999.0
    z_score: 0.84

--------------------------------------------------------------------------------
END FILE: config/parametros.yaml


START FILE: tests_refactor/test_04_abc.py
--------------------------------------------------------------------------------
import pytest
import polars as pl
import sys
from pathlib import Path

# Setup de ImportaÃ§Ã£o
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

try:
    from compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier
except ImportError:
    from src.compras_sistema.rule_engine.classification.abc_classifier import ABCClassifier

def test_classificacao_abc_pareto_perfeito():
    """
    Testa a lÃ³gica ABC pura usando Polars.
    CenÃ¡rio: Venda Total = 1000
    - Produto 1: 800 (80%) -> Deve ser A
    - Produto 2: 150 (15%) -> Acumulado 95% -> Deve ser B
    - Produto 3: 50  (5%)  -> Acumulado 100% -> Deve ser C
    """
    
    # 1. Setup
    df_vendas = pl.DataFrame({
        "cod_produto": ["P1", "P2", "P3"],
        "total_vendido": [800.0, 150.0, 50.0]
    })

    # 2. ConfiguraÃ§Ã£o Simulada (Lida do YAML)
    config_abc = {
        "A": 80.0,
        "B": 15.0,
        "C": 5.0
    }

    # 3. Act
    df_resultado = ABCClassifier.calcular_abc_polars(df_vendas, config_abc)

    # 4. Assert
    cat_p1 = df_resultado.filter(pl.col("cod_produto") == "P1")["curva_abc"].item()
    assert cat_p1 == "A", f"P1 deveria ser A, mas foi {cat_p1}"

    cat_p2 = df_resultado.filter(pl.col("cod_produto") == "P2")["curva_abc"].item()
    assert cat_p2 == "B", f"P2 deveria ser B, mas foi {cat_p2}"

    cat_p3 = df_resultado.filter(pl.col("cod_produto") == "P3")["curva_abc"].item()
    assert cat_p3 == "C", f"P3 deveria ser C, mas foi {cat_p3}"

def test_classificacao_abc_configuracao_personalizada():
    """
    Teste de MutaÃ§Ã£o:
    Alteramos a regra para ser super rigorosa: Classe A Ã© apenas 50% do faturamento.
    
    CenÃ¡rio:
    - Produto X vendeu 600 de um total de 1000 (60%).
    
    Na regra PadrÃ£o (A=80%): 60% < 80% -> Seria 'A'.
    Na regra Mutante (A=50%): 60% > 50% -> Cai para 'B'.
    """
    
    df_vendas = pl.DataFrame({
        "cod_produto": ["PROD_X", "PROD_RESTO"],
        "total_vendido": [600.0, 400.0] # Total 1000
    })

    # ConfiguraÃ§Ã£o Mutante (Rigorosa)
    config_mutante = {
        "A": 50.0, # SÃ³ os top 50% sÃ£o A
        "B": 40.0,
        "C": 10.0
    }

    # Executa
    df_resultado = ABCClassifier.calcular_abc_polars(df_vendas, config_mutante)

    # Verifica
    cat_x = df_resultado.filter(pl.col("cod_produto") == "PROD_X")["curva_abc"].item()
    
    # Como o acumulado do PROD_X Ã© 0.60 (60%), e o corte A Ã© 0.50 (50%),
    # ele deve cair para a prÃ³xima faixa (B).
    assert cat_x == "B", f"Falha na configuraÃ§Ã£o dinÃ¢mica. Esperado B, recebeu {cat_x}"
--------------------------------------------------------------------------------
END FILE: tests_refactor/test_04_abc.py


START FILE: tests_refactor/test_02_estoque_math.py
--------------------------------------------------------------------------------
import pytest
import polars as pl
import sys
from pathlib import Path

# Adiciona o diretÃ³rio src ao path para garantir importaÃ§Ã£o correta
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

try:
    # Tenta importar do jeito que funcionou no seu ambiente
    from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
except ImportError:
    # Fallback caso o path precise ser explÃ­cito
    from src.compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

def test_calculo_seguranca_valores_padrao():
    """
    Testa se o cÃ¡lculo de Estoque de SeguranÃ§a respeita a fÃ³rmula padrÃ£o
    quando nÃ£o hÃ¡ configuraÃ§Ã£o especÃ­fica (Fallback).
    ES = FatorZ * StdDev * Raiz(LeadTime)
    """
    
    # 1. Setup: Dados controlados
    df_input = pl.DataFrame({
        "cod_produto": ["PROD_X", "PROD_Y", "PROD_Z"],
        "curva_xyz": ["X", "Y", "Z"],
        "std_venda_dia": [1.0, 1.0, 1.0],
        "lead_time_dias": [1, 1, 1] 
    })

    # Config Mock (Vazio -> ForÃ§a o fallback para 1.65, 1.28, 0.84)
    config_mock = {} 

    # 2. Act
    df_result = EstoqueMath.calcular_seguranca(df_input, config_mock)

    # 3. Assert
    res_x = df_result.filter(pl.col("curva_xyz") == "X")["estoque_seguranca"].item()
    assert res_x == 1.65, f"Erro no fator X. Esperado 1.65, obtido {res_x}"

    res_y = df_result.filter(pl.col("curva_xyz") == "Y")["estoque_seguranca"].item()
    assert res_y == 1.28, f"Erro no fator Y. Esperado 1.28, obtido {res_y}"

    res_z = df_result.filter(pl.col("curva_xyz") == "Z")["estoque_seguranca"].item()
    assert res_z == 0.84, f"Erro no fator Z. Esperado 0.84, obtido {res_z}"

def test_calculo_seguranca_com_lead_time_variavel():
    """
    Testa a fÃ³rmula completa: ES = 1.65 * 2.0 * Sqrt(4)
    Esperado: 1.65 * 2 * 2 = 6.6
    """
    df_input = pl.DataFrame({
        "cod_produto": ["TESTE_COMPLEXO"],
        "curva_xyz": ["X"],        
        "std_venda_dia": [2.0],    
        "lead_time_dias": [4]      # Raiz de 4 Ã© 2
    })
    
    df_result = EstoqueMath.calcular_seguranca(df_input, {})
    
    val = df_result["estoque_seguranca"].item()
    assert val == pytest.approx(6.6, 0.01)

def test_calculo_seguranca_lendo_configuracao_personalizada():
    """
    Teste de MutaÃ§Ã£o:
    Injetamos uma configuraÃ§Ã£o com valores 'estranhos' (ex: X=10.0)
    para garantir que o sistema obedece ao config e nÃ£o ao hardcode.
    """
    df_input = pl.DataFrame({
        "cod_produto": ["PROD_TESTE"],
        "curva_xyz": ["X"],
        "std_venda_dia": [1.0],
        "lead_time_dias": [1] 
    })

    # Simula o objeto de configuraÃ§Ã£o (Dict) com valores alterados
    config_custom = {
        "estoque": {
            "fator_z": {
                "X": 10.0, # Valor exagerado para prova de conceito
                "Y": 5.0,
                "Z": 1.0
            }
        }
    }

    # Executa
    df_result = EstoqueMath.calcular_seguranca(df_input, config_custom)
    
    # Verifica
    # Se estivesse usando hardcode, seria 1.65.
    # Como injetamos 10.0, o resultado tem de ser 10.0.
    resultado = df_result["estoque_seguranca"].item()
    
    assert resultado == 10.0, f"Falha: O sistema ignorou o config. Esperado 10.0, recebeu {resultado}"
--------------------------------------------------------------------------------
END FILE: tests_refactor/test_02_estoque_math.py


START FILE: tests_refactor/test_01_blindagem_entrada.py
--------------------------------------------------------------------------------
import pytest
import polars as pl

# --- A FUNÃ‡ÃƒO NOVA QUE ESTAMOS CRIANDO ---
# (Futuramente ela irÃ¡ para src/utils/sanitizer.py)
def sanear_dados_dataframe(df: pl.DataFrame) -> pl.DataFrame:
    """
    Blindagem de Dados (Fase 1):
    Garante que nÃºmeros crÃ­ticos para a matemÃ¡tica nÃ£o quebrem o cÃ¡lculo.
    """
    # 1. Lead Time: NÃ£o pode ser negativo. Se for, assume 0.
    # (ProteÃ§Ã£o contra erro humano no cadastro ou hardcoding incorreto)
    if "lead_time_dias" in df.columns:
        df = df.with_columns(
            pl.when(pl.col("lead_time_dias") < 0)
            .then(0)
            .otherwise(pl.col("lead_time_dias"))
            .alias("lead_time_dias")
        )
    
    # 2. MÃ©dia de Venda: Nulo vira 0.0 (Essencial)
    if "media_venda_dia" in df.columns:
        df = df.with_columns(
            pl.col("media_venda_dia").fill_null(0.0)
        )
    
    # 3. Estoque e OC: Nulos viram 0 (Essencial)
    # NOTA: NÃ£o removemos negativos do estoque (pois estoque negativo = dÃ­vida tÃ©cnica/venda sem baixa),
    # mas garantimos que nÃ£o seja Nulo/None.
    cols_zero = ["saldo_estoque", "saldo_oc"]
    cols_existentes = [c for c in cols_zero if c in df.columns]
    
    if cols_existentes:
        df = df.with_columns([
            pl.col(c).fill_null(0) for c in cols_existentes
        ])
    
    return df

# --- OS TESTES ---

def test_deve_corrigir_lead_time_negativo():
    # CenÃ¡rio: Lead time veio negativo do banco ou config
    df_sujo = pl.DataFrame({
        "cod_produto": ["A1", "B2"],
        "lead_time_dias": [-5, 10], 
        "media_venda_dia": [1.0, 2.0],
        "saldo_estoque": [10, 20]
    })

    # AÃ§Ã£o
    df_limpo = sanear_dados_dataframe(df_sujo)

    # VerificaÃ§Ã£o
    lead_times = df_limpo["lead_time_dias"].to_list()
    assert lead_times == [0, 10], f"Erro: Lead time negativo deveria ser 0. Recebido: {lead_times}"

def test_deve_preencher_nulos_criticos():
    # CenÃ¡rio: Dados nulos que quebrariam a matemÃ¡tica (ex: multiplicar None por 10 falha)
    df_sujo = pl.DataFrame({
        "cod_produto": ["C3"],
        "lead_time_dias": [10],
        "media_venda_dia": [None], # Perigo!
        "saldo_estoque": [None],   # Perigo!
        "saldo_oc": [None]
    })

    df_limpo = sanear_dados_dataframe(df_sujo)

    # Polars trata None numÃ©rico como null, fill_null(0) deve resolver
    assert df_limpo["media_venda_dia"].item(0) == 0.0
    assert df_limpo["saldo_estoque"].item(0) == 0
    assert df_limpo["saldo_oc"].item(0) == 0

def test_nao_deve_alterar_estoque_negativo():
    # CenÃ¡rio: Estoque negativo Ã© vÃ¡lido (significa furo de estoque), nÃ£o devemos zerar
    df_sujo = pl.DataFrame({
        "cod_produto": ["D4"],
        "saldo_estoque": [-5]
    })
    
    df_limpo = sanear_dados_dataframe(df_sujo)
    
    assert df_limpo["saldo_estoque"].item(0) == -5
--------------------------------------------------------------------------------
END FILE: tests_refactor/test_01_blindagem_entrada.py


START FILE: tests_refactor/test_03_diagnostico.py
--------------------------------------------------------------------------------
import pytest
import polars as pl
import sys
from pathlib import Path

# Setup de ImportaÃ§Ã£o
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

try:
    from compras_sistema.rule_engine.stock.estoque_math import EstoqueMath
except ImportError:
    from src.compras_sistema.rule_engine.stock.estoque_math import EstoqueMath

# --- TESTE 1: Regra PadrÃ£o (Excesso) ---
def test_diagnostico_excesso_estoque():
    """
    Testa se o sistema detecta Excesso de Estoque.
    """
    df_input = pl.DataFrame({
        "cod_produto": ["PROD_OK", "PROD_EXCESSO"],
        "saldo_estoque": [100, 1000],
        "saldo_oc": [0, 0],
        "media_venda_dia": [1.0, 1.0], # Venda mensal = 30
        "dias_vida": [500, 500],
        "ativo": ["SIM", "SIM"],
        "sugestao_final": [0, 0],
        "score": [100, 100],
        "lote_economico": [10, 10],
        "custo_unitario": [10.0, 10.0] 
    })

    # Mock de ConfiguraÃ§Ã£o PadrÃ£o
    config_mock = {
        "produto": {"dias_lancamento": 180},
        "giro": {"limite_meses_cobertura": 6, "minimo_venda_dia": 0.05}
    }

    df_result = EstoqueMath.gerar_diagnostico(df_input, config_mock)

    diag_ok = df_result.filter(pl.col("cod_produto") == "PROD_OK")["validacao_giro"].item()
    assert "ALERTA" not in diag_ok

    diag_excesso = df_result.filter(pl.col("cod_produto") == "PROD_EXCESSO")["validacao_giro"].item()
    assert "ALERTA: Excesso" in diag_excesso

# --- TESTE 2: Regra PadrÃ£o (Venda Baixa) ---
def test_diagnostico_venda_irrisoria():
    """
    Testa se detecta venda muito baixa (< 0.05/dia).
    """
    df_input = pl.DataFrame({
        "cod_produto": ["PROD_LENTO"],
        "saldo_estoque": [0],
        "saldo_oc": [0],
        "media_venda_dia": [0.01], 
        "dias_vida": [500],
        "ativo": ["SIM"],
        "sugestao_final": [10], 
        "score": [100],
        "lote_economico": [12],
        "custo_unitario": [5.50]
    })
    
    config_mock = {
        "produto": {"dias_lancamento": 180},
        "giro": {"limite_meses_cobertura": 6, "minimo_venda_dia": 0.05}
    }

    df_result = EstoqueMath.gerar_diagnostico(df_input, config_mock)
    
    diag = df_result["validacao_giro"].item()
    assert "ALERTA: Sem Venda Recente" in diag

# --- TESTE 3: Regra ConfigurÃ¡vel (A PROVA REAL) ---
def test_diagnostico_obedece_configuracao_personalizada():
    """
    Teste de MutaÃ§Ã£o:
    Alteramos o limite de cobertura para 1 mÃªs.
    Um produto com 3 meses de estoque (que seria OK antes) agora deve dar ALERTA.
    """
    df_input = pl.DataFrame({
        "cod_produto": ["PROD_MUTANTE"],
        "saldo_estoque": [90],
        "saldo_oc": [0],
        "media_venda_dia": [1.0], # Venda mÃªs = 30. Cobertura = 3 meses.
        "dias_vida": [500],
        "ativo": ["SIM"],
        "sugestao_final": [0],
        "score": [100],
        "lote_economico": [10],
        "custo_unitario": [10.0]
    })

    # Config Rigorosa: Limite de cobertura Ã© apenas 1.0 mÃªs
    config_rigorosa = {
        "produto": {"dias_lancamento": 180},
        "giro": {
            "limite_meses_cobertura": 1.0, # MUDANÃ‡A CRÃTICA
            "minimo_venda_dia": 0.05
        }
    }

    df_result = EstoqueMath.gerar_diagnostico(df_input, config_rigorosa)
    
    diag = df_result["validacao_giro"].item()
    
    # Se passar aqui, o seu sistema Ã© oficialmente Config-Driven
    assert "ALERTA: Excesso > 1.0m" in diag
--------------------------------------------------------------------------------
END FILE: tests_refactor/test_03_diagnostico.py


